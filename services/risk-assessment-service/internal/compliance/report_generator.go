package compliance

import (
	"context"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"go.uber.org/zap"

	"kyb-platform/services/risk-assessment-service/internal/audit"
)

// ReportGenerator handles report generation and export operations
type ReportGenerator struct {
	reporter   *ComplianceReporter
	logger     *zap.Logger
	exportPath string
}

// NewReportGenerator creates a new report generator
func NewReportGenerator(reporter *ComplianceReporter, exportPath string, logger *zap.Logger) *ReportGenerator {
	return &ReportGenerator{
		reporter:   reporter,
		logger:     logger,
		exportPath: exportPath,
	}
}

// GenerateAndExportReport generates a report and exports it in the specified format
func (rg *ReportGenerator) GenerateAndExportReport(ctx context.Context, req *GenerateReportRequest, format string) (*audit.AuditExport, error) {
	// Generate the compliance report
	report, err := rg.reporter.GenerateComplianceReport(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to generate compliance report: %w", err)
	}

	// Create export record
	export := &audit.AuditExport{
		ID:          generateExportID(),
		TenantID:    req.TenantID,
		ExportType:  format,
		Status:      "processing",
		RequestedBy: req.GeneratedBy,
		RequestedAt: time.Now(),
		ExpiresAt:   time.Now().AddDate(0, 0, 30), // 30 days retention
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	// Generate export file
	filePath, recordCount, err := rg.exportReportToFile(ctx, report, format)
	if err != nil {
		export.Status = "failed"
		export.UpdatedAt = time.Now()
		return export, fmt.Errorf("failed to export report: %w", err)
	}

	// Update export record
	export.Status = "completed"
	export.FilePath = filePath
	export.RecordCount = recordCount
	completedAt := time.Now()
	export.CompletedAt = &completedAt
	export.UpdatedAt = time.Now()

	// Get file size
	if stat, err := os.Stat(filePath); err == nil {
		export.FileSize = stat.Size()
	}

	// Log export creation
	rg.reporter.auditLogger.LogAdminAction(ctx, req.TenantID, req.GeneratedBy, "export_compliance_report", "audit_export", export.ID, map[string]interface{}{
		"report_id":    report.ID,
		"export_type":  format,
		"file_path":    filePath,
		"record_count": recordCount,
	})

	return export, nil
}

// exportReportToFile exports a report to a file in the specified format
func (rg *ReportGenerator) exportReportToFile(ctx context.Context, report *audit.ComplianceReport, format string) (string, int64, error) {
	// Create export directory if it doesn't exist
	exportDir := filepath.Join(rg.exportPath, report.TenantID)
	if err := os.MkdirAll(exportDir, 0755); err != nil {
		return "", 0, fmt.Errorf("failed to create export directory: %w", err)
	}

	// Generate filename
	timestamp := time.Now().Format("20060102_150405")
	filename := fmt.Sprintf("%s_%s_%s.%s", report.ReportType, report.ID, timestamp, format)
	filePath := filepath.Join(exportDir, filename)

	// Export based on format
	var recordCount int64
	var err error

	switch strings.ToLower(format) {
	case "json":
		recordCount, err = rg.exportToJSON(report, filePath)
	case "csv":
		recordCount, err = rg.exportToCSV(report, filePath)
	case "pdf":
		recordCount, err = rg.exportToPDF(report, filePath)
	default:
		return "", 0, fmt.Errorf("unsupported export format: %s", format)
	}

	if err != nil {
		return "", 0, fmt.Errorf("failed to export to %s: %w", format, err)
	}

	return filePath, recordCount, nil
}

// exportToJSON exports a report to JSON format
func (rg *ReportGenerator) exportToJSON(report *audit.ComplianceReport, filePath string) (int64, error) {
	file, err := os.Create(filePath)
	if err != nil {
		return 0, fmt.Errorf("failed to create JSON file: %w", err)
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")

	if err := encoder.Encode(report); err != nil {
		return 0, fmt.Errorf("failed to encode JSON: %w", err)
	}

	// Count records in the report data
	recordCount := rg.countRecordsInData(report.Data)

	return recordCount, nil
}

// exportToCSV exports a report to CSV format
func (rg *ReportGenerator) exportToCSV(report *audit.ComplianceReport, filePath string) (int64, error) {
	file, err := os.Create(filePath)
	if err != nil {
		return 0, fmt.Errorf("failed to create CSV file: %w", err)
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	// Write header
	header := []string{
		"Report ID", "Report Type", "Report Name", "Period", "Start Date", "End Date",
		"Status", "Generated By", "Generated At", "Hash",
	}
	if err := writer.Write(header); err != nil {
		return 0, fmt.Errorf("failed to write CSV header: %w", err)
	}

	// Write report metadata
	record := []string{
		report.ID,
		report.ReportType,
		report.ReportName,
		report.Period,
		report.StartDate.Format(time.RFC3339),
		report.EndDate.Format(time.RFC3339),
		report.Status,
		report.GeneratedBy,
		report.GeneratedAt.Format(time.RFC3339),
		report.Hash,
	}
	if err := writer.Write(record); err != nil {
		return 0, fmt.Errorf("failed to write CSV record: %w", err)
	}

	// Write data section header
	if err := writer.Write([]string{"", "", "", "", "", "", "", "", "", ""}); err != nil {
		return 0, fmt.Errorf("failed to write CSV separator: %w", err)
	}

	// Export report data to CSV
	recordCount, err := rg.exportDataToCSV(writer, report.Data)
	if err != nil {
		return 0, fmt.Errorf("failed to export data to CSV: %w", err)
	}

	return recordCount + 1, nil // +1 for the metadata record
}

// exportToPDF exports a report to PDF format (simplified implementation)
func (rg *ReportGenerator) exportToPDF(report *audit.ComplianceReport, filePath string) (int64, error) {
	// This is a simplified PDF export implementation
	// In production, you would use a proper PDF library like unidoc/unipdf or gofpdf

	// For now, we'll create a text file with PDF-like content
	file, err := os.Create(filePath)
	if err != nil {
		return 0, fmt.Errorf("failed to create PDF file: %w", err)
	}
	defer file.Close()

	// Write PDF-like content (simplified)
	content := fmt.Sprintf(`
COMPLIANCE REPORT
================

Report ID: %s
Report Type: %s
Report Name: %s
Period: %s
Start Date: %s
End Date: %s
Status: %s
Generated By: %s
Generated At: %s
Hash: %s

REPORT DATA
===========
%s

Generated by Risk Assessment Service
%s
`,
		report.ID,
		report.ReportType,
		report.ReportName,
		report.Period,
		report.StartDate.Format(time.RFC3339),
		report.EndDate.Format(time.RFC3339),
		report.Status,
		report.GeneratedBy,
		report.GeneratedAt.Format(time.RFC3339),
		report.Hash,
		rg.formatDataAsText(report.Data),
		time.Now().Format(time.RFC3339),
	)

	if _, err := file.WriteString(content); err != nil {
		return 0, fmt.Errorf("failed to write PDF content: %w", err)
	}

	// Count records in the report data
	recordCount := rg.countRecordsInData(report.Data)

	return recordCount, nil
}

// exportDataToCSV exports report data to CSV format
func (rg *ReportGenerator) exportDataToCSV(writer *csv.Writer, data map[string]interface{}) (int64, error) {
	var recordCount int64

	// Handle different data structures
	for key, value := range data {
		switch v := value.(type) {
		case []interface{}:
			// Array of records
			for i, item := range v {
				if itemMap, ok := item.(map[string]interface{}); ok {
					recordCount++
					if err := rg.writeMapToCSV(writer, itemMap, fmt.Sprintf("%s_%d", key, i)); err != nil {
						return recordCount, err
					}
				}
			}
		case map[string]interface{}:
			// Single record
			recordCount++
			if err := rg.writeMapToCSV(writer, v, key); err != nil {
				return recordCount, err
			}
		default:
			// Simple value
			recordCount++
			if err := writer.Write([]string{key, fmt.Sprintf("%v", v)}); err != nil {
				return recordCount, err
			}
		}
	}

	return recordCount, nil
}

// writeMapToCSV writes a map to CSV format
func (rg *ReportGenerator) writeMapToCSV(writer *csv.Writer, data map[string]interface{}, prefix string) error {
	for key, value := range data {
		row := []string{
			prefix + "." + key,
			fmt.Sprintf("%v", value),
		}
		if err := writer.Write(row); err != nil {
			return fmt.Errorf("failed to write CSV row: %w", err)
		}
	}
	return nil
}

// formatDataAsText formats report data as text
func (rg *ReportGenerator) formatDataAsText(data map[string]interface{}) string {
	var result strings.Builder

	for key, value := range data {
		result.WriteString(fmt.Sprintf("\n%s:\n", strings.ToUpper(key)))
		result.WriteString(strings.Repeat("-", len(key)+1))
		result.WriteString("\n")

		switch v := value.(type) {
		case map[string]interface{}:
			for subKey, subValue := range v {
				result.WriteString(fmt.Sprintf("  %s: %v\n", subKey, subValue))
			}
		case []interface{}:
			for i, item := range v {
				result.WriteString(fmt.Sprintf("  [%d]: %v\n", i, item))
			}
		default:
			result.WriteString(fmt.Sprintf("  %v\n", v))
		}
	}

	return result.String()
}

// countRecordsInData counts the number of records in report data
func (rg *ReportGenerator) countRecordsInData(data map[string]interface{}) int64 {
	var count int64

	for _, value := range data {
		switch v := value.(type) {
		case []interface{}:
			count += int64(len(v))
		case map[string]interface{}:
			count++
		default:
			count++
		}
	}

	return count
}

// ScheduleReportGeneration schedules automatic report generation
func (rg *ReportGenerator) ScheduleReportGeneration(ctx context.Context, schedule *ReportSchedule) error {
	// This would integrate with a job scheduler like cron or a task queue
	// For now, we'll log the schedule request
	rg.logger.Info("Report generation scheduled",
		zap.String("tenant_id", schedule.TenantID),
		zap.String("template_id", schedule.TemplateID),
		zap.String("schedule", schedule.CronExpression),
		zap.String("created_by", schedule.CreatedBy))

	// Log schedule creation
	rg.reporter.auditLogger.LogAdminAction(ctx, schedule.TenantID, schedule.CreatedBy, "schedule_report_generation", "report_schedule", schedule.ID, map[string]interface{}{
		"template_id":     schedule.TemplateID,
		"cron_expression": schedule.CronExpression,
		"enabled":         schedule.Enabled,
	})

	return nil
}

// CleanupExpiredExports removes expired export files
func (rg *ReportGenerator) CleanupExpiredExports(ctx context.Context) error {
	// Walk through export directory and remove expired files
	return filepath.Walk(rg.exportPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip directories
		if info.IsDir() {
			return nil
		}

		// Check if file is older than 30 days
		if time.Since(info.ModTime()) > 30*24*time.Hour {
			rg.logger.Info("Removing expired export file", zap.String("path", path))
			return os.Remove(path)
		}

		return nil
	})
}

// ReportSchedule represents a scheduled report generation
type ReportSchedule struct {
	ID             string    `json:"id"`
	TenantID       string    `json:"tenant_id"`
	TemplateID     string    `json:"template_id"`
	CronExpression string    `json:"cron_expression"`
	Enabled        bool      `json:"enabled"`
	CreatedBy      string    `json:"created_by"`
	CreatedAt      time.Time `json:"created_at"`
	UpdatedAt      time.Time `json:"updated_at"`
}

// Helper function
func generateExportID() string {
	return fmt.Sprintf("exp_%d_%d", time.Now().UnixNano(), time.Now().Unix())
}
