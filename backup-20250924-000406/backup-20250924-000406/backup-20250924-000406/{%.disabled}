package observability

import (
	"context"
	"fmt"
	"sync"
	"time"

	"go.uber.org/zap"
)

// MemoryMonitorImpl implements the MemoryMonitor interface
type MemoryMonitorImpl struct {
	logger         *zap.Logger
	config         *MemoryOptimizationConfig
	isMonitoring   bool
	mu             sync.RWMutex
	metricsHistory []*MemoryMetrics
	leakDetector   *MemoryLeakDetector
	alertManager   *MemoryAlertManager
	stopChan       chan struct{}
}

// MemoryLeakDetector provides memory leak detection capabilities
type MemoryLeakDetector struct {
	logger          *zap.Logger
	config          *MemoryOptimizationConfig
	baselineMetrics *MemoryMetrics
	leakHistory     []*MemoryLeakDetection
	mu              sync.RWMutex
}

// MemoryAlertManager provides memory alert management
type MemoryAlertManager struct {
	logger *zap.Logger
	config *MemoryOptimizationConfig
	alerts []*MemoryAlert
	mu     sync.RWMutex
}

// MemoryAlert represents a memory-related alert
type MemoryAlert struct {
	ID        string                 `json:"id"`
	Type      string                 `json:"type"`     // threshold, leak, anomaly
	Severity  string                 `json:"severity"` // low, medium, high, critical
	Message   string                 `json:"message"`
	Timestamp time.Time              `json:"timestamp"`
	Metrics   *MemoryMetrics         `json:"metrics"`
	Threshold float64                `json:"threshold"`
	Current   float64                `json:"current"`
	Metadata  map[string]interface{} `json:"metadata"`
}

// NewMemoryMonitorImpl creates a new memory monitor implementation
func NewMemoryMonitorImpl(logger *zap.Logger) *MemoryMonitorImpl {
	return &MemoryMonitorImpl{
		logger:         logger,
		metricsHistory: make([]*MemoryMetrics, 0),
		leakDetector:   NewMemoryLeakDetector(logger),
		alertManager:   NewMemoryAlertManager(logger),
		stopChan:       make(chan struct{}),
	}
}

// StartMonitoring starts memory monitoring
func (mm *MemoryMonitorImpl) StartMonitoring(ctx context.Context, config *MemoryOptimizationConfig) error {
	mm.mu.Lock()
	defer mm.mu.Unlock()

	if mm.isMonitoring {
		return fmt.Errorf("memory monitoring is already running")
	}

	mm.config = config
	mm.leakDetector.config = config
	mm.alertManager.config = config

	// Initialize baseline metrics
	mm.leakDetector.baselineMetrics = collectMemoryMetrics()

	mm.isMonitoring = true
	mm.logger.Info("memory monitoring started")
	return nil
}

// StopMonitoring stops memory monitoring
func (mm *MemoryMonitorImpl) StopMonitoring(ctx context.Context) error {
	mm.mu.Lock()
	defer mm.mu.Unlock()

	if !mm.isMonitoring {
		return fmt.Errorf("memory monitoring is not running")
	}

	mm.isMonitoring = false
	close(mm.stopChan)
	mm.logger.Info("memory monitoring stopped")
	return nil
}

// GetCurrentMetrics returns current memory metrics
func (mm *MemoryMonitorImpl) GetCurrentMetrics(ctx context.Context) (*MemoryMetrics, error) {
	metrics := collectMemoryMetrics()

	// Store in history
	mm.mu.Lock()
	mm.metricsHistory = append(mm.metricsHistory, metrics)

	// Keep only recent history (last 1000 metrics)
	if len(mm.metricsHistory) > 1000 {
		mm.metricsHistory = mm.metricsHistory[len(mm.metricsHistory)-1000:]
	}
	mm.mu.Unlock()

	return metrics, nil
}

// GetMetricsHistory returns memory metrics history
func (mm *MemoryMonitorImpl) GetMetricsHistory(ctx context.Context, duration time.Duration) ([]*MemoryMetrics, error) {
	mm.mu.RLock()
	defer mm.mu.RUnlock()

	cutoff := time.Now().Add(-duration)
	var history []*MemoryMetrics

	for _, metrics := range mm.metricsHistory {
		if metrics.Timestamp.After(cutoff) {
			history = append(history, metrics)
		}
	}

	return history, nil
}

// DetectLeaks detects memory leaks
func (mm *MemoryMonitorImpl) DetectLeaks(ctx context.Context, config *MemoryOptimizationConfig) (*MemoryLeakDetection, error) {
	return mm.leakDetector.DetectLeaks(ctx, config)
}

// GetAlerts returns memory alerts
func (mm *MemoryMonitorImpl) GetAlerts(ctx context.Context) ([]*MemoryAlert, error) {
	return mm.alertManager.GetAlerts(ctx)
}

// GetMonitoringStats returns monitoring statistics
func (mm *MemoryMonitorImpl) GetMonitoringStats() map[string]interface{} {
	mm.mu.RLock()
	defer mm.mu.RUnlock()

	return map[string]interface{}{
		"is_monitoring":     mm.isMonitoring,
		"metrics_count":     len(mm.metricsHistory),
		"leak_detections":   len(mm.leakDetector.leakHistory),
		"alerts_count":      len(mm.alertManager.alerts),
		"last_metrics":      mm.getLastMetrics(),
		"monitoring_uptime": mm.getMonitoringUptime(),
	}
}

// Helper methods
func (mm *MemoryMonitorImpl) getLastMetrics() *MemoryMetrics {
	if len(mm.metricsHistory) == 0 {
		return nil
	}
	return mm.metricsHistory[len(mm.metricsHistory)-1]
}

func (mm *MemoryMonitorImpl) getMonitoringUptime() time.Duration {
	if len(mm.metricsHistory) < 2 {
		return 0
	}
	return mm.metricsHistory[len(mm.metricsHistory)-1].Timestamp.Sub(mm.metricsHistory[0].Timestamp)
}

// MemoryLeakDetector implementation
func NewMemoryLeakDetector(logger *zap.Logger) *MemoryLeakDetector {
	return &MemoryLeakDetector{
		logger:      logger,
		leakHistory: make([]*MemoryLeakDetection, 0),
	}
}

// DetectLeaks detects memory leaks using various algorithms
func (mld *MemoryLeakDetector) DetectLeaks(ctx context.Context, config *MemoryOptimizationConfig) (*MemoryLeakDetection, error) {
	mld.mu.Lock()
	defer mld.mu.Unlock()

	detection := &MemoryLeakDetection{
		ID:               generateMemoryLeakDetectionID(),
		Timestamp:        time.Now(),
		Leaks:            make([]*LeakInfo, 0),
		GoroutineLeaks:   make([]*GoroutineLeak, 0),
		TotalLeakedBytes: 0,
		RiskLevel:        "low",
		Recommendations:  make([]string, 0),
		Metadata:         make(map[string]interface{}),
	}

	// Get current metrics
	currentMetrics := collectMemoryMetrics()

	// Detect heap memory leaks
	if heapLeaks := mld.detectHeapLeaks(currentMetrics); len(heapLeaks) > 0 {
		detection.Leaks = append(detection.Leaks, heapLeaks...)
		for _, leak := range heapLeaks {
			detection.TotalLeakedBytes += leak.Bytes
		}
	}

	// Detect goroutine leaks
	if goroutineLeaks := mld.detectGoroutineLeaks(currentMetrics); len(goroutineLeaks) > 0 {
		detection.GoroutineLeaks = append(detection.GoroutineLeaks, goroutineLeaks...)
	}

	// Determine risk level
	detection.RiskLevel = mld.determineRiskLevel(detection)

	// Generate recommendations
	detection.Recommendations = mld.generateRecommendations(detection)

	// Store detection
	mld.leakHistory = append(mld.leakHistory, detection)

	mld.logger.Info("memory leak detection completed",
		zap.String("detection_id", detection.ID),
		zap.String("risk_level", detection.RiskLevel),
		zap.Int("heap_leaks", len(detection.Leaks)),
		zap.Int("goroutine_leaks", len(detection.GoroutineLeaks)),
		zap.Uint64("total_leaked_bytes", detection.TotalLeakedBytes))

	return detection, nil
}

// detectHeapLeaks detects heap memory leaks
func (mld *MemoryLeakDetector) detectHeapLeaks(metrics *MemoryMetrics) []*LeakInfo {
	var leaks []*LeakInfo

	// Check for continuous heap growth
	if mld.baselineMetrics != nil {
		growthRate := float64(metrics.HeapAlloc-mld.baselineMetrics.HeapAlloc) / float64(mld.baselineMetrics.HeapAlloc)

		if growthRate > 0.2 { // 20% growth threshold
			leaks = append(leaks, &LeakInfo{
				ID:             generateMemoryLeakDetectionID(),
				Type:           "heap",
				Severity:       mld.determineLeakSeverity(growthRate),
				Description:    fmt.Sprintf("Heap memory growth detected: %.2f%% increase", growthRate*100),
				Location:       "runtime",
				Bytes:          metrics.HeapAlloc - mld.baselineMetrics.HeapAlloc,
				Objects:        metrics.HeapObjects - mld.baselineMetrics.HeapObjects,
				DetectedAt:     time.Now(),
				GrowthRate:     growthRate,
				Recommendation: "Review memory allocation patterns and implement proper cleanup",
			})
		}
	}

	// Check for high heap allocation percentage
	if metrics.HeapAllocPercent > 80 {
		leaks = append(leaks, &LeakInfo{
			ID:             generateMemoryLeakDetectionID(),
			Type:           "heap",
			Severity:       "high",
			Description:    fmt.Sprintf("High heap allocation: %.2f%% of heap system", metrics.HeapAllocPercent),
			Location:       "runtime",
			Bytes:          metrics.HeapAlloc,
			Objects:        metrics.HeapObjects,
			DetectedAt:     time.Now(),
			GrowthRate:     0,
			Recommendation: "Consider forcing garbage collection or optimizing memory usage",
		})
	}

	// Check for low heap release
	if metrics.HeapReleased < metrics.HeapIdle*50/100 { // Less than 50% of idle memory released
		leaks = append(leaks, &LeakInfo{
			ID:             generateMemoryLeakDetectionID(),
			Type:           "heap",
			Severity:       "medium",
			Description:    "Low heap memory release to OS",
			Location:       "runtime",
			Bytes:          metrics.HeapIdle - metrics.HeapReleased,
			Objects:        0,
			DetectedAt:     time.Now(),
			GrowthRate:     0,
			Recommendation: "Consider forcing memory release or optimizing allocation patterns",
		})
	}

	return leaks
}

// detectGoroutineLeaks detects goroutine leaks
func (mld *MemoryLeakDetector) detectGoroutineLeaks(metrics *MemoryMetrics) []*GoroutineLeak {
	var leaks []*GoroutineLeak

	// Check for high goroutine count
	if metrics.Goroutines > 1000 {
		leaks = append(leaks, &GoroutineLeak{
			ID:             generateMemoryLeakDetectionID(),
			Function:       "runtime",
			File:           "runtime",
			Line:           0,
			Count:          metrics.Goroutines,
			GrowthRate:     0,
			DetectedAt:     time.Now(),
			Recommendation: "Review goroutine lifecycle management and implement proper cleanup",
		})
	}

	// Check for goroutine growth compared to baseline
	if mld.baselineMetrics != nil {
		growthRate := float64(metrics.Goroutines-mld.baselineMetrics.Goroutines) / float64(mld.baselineMetrics.Goroutines)

		if growthRate > 0.5 { // 50% growth threshold
			leaks = append(leaks, &GoroutineLeak{
				ID:             generateMemoryLeakDetectionID(),
				Function:       "runtime",
				File:           "runtime",
				Line:           0,
				Count:          metrics.Goroutines,
				GrowthRate:     growthRate,
				DetectedAt:     time.Now(),
				Recommendation: "Review goroutine creation patterns and implement proper cancellation",
			})
		}
	}

	return leaks
}

// determineLeakSeverity determines the severity of a leak based on growth rate
func (mld *MemoryLeakDetector) determineLeakSeverity(growthRate float64) string {
	switch {
	case growthRate > 1.0:
		return "critical"
	case growthRate > 0.5:
		return "high"
	case growthRate > 0.2:
		return "medium"
	default:
		return "low"
	}
}

// determineRiskLevel determines the overall risk level of leak detection
func (mld *MemoryLeakDetector) determineRiskLevel(detection *MemoryLeakDetection) string {
	highestSeverity := "low"

	for _, leak := range detection.Leaks {
		switch leak.Severity {
		case "critical":
			return "critical"
		case "high":
			highestSeverity = "high"
		case "medium":
			if highestSeverity == "low" {
				highestSeverity = "medium"
			}
		}
	}

	return highestSeverity
}

// generateRecommendations generates recommendations based on detected leaks
func (mld *MemoryLeakDetector) generateRecommendations(detection *MemoryLeakDetection) []string {
	var recommendations []string

	if len(detection.Leaks) > 0 {
		recommendations = append(recommendations, "Review memory allocation patterns in application code")
		recommendations = append(recommendations, "Implement proper object lifecycle management")
		recommendations = append(recommendations, "Consider using object pools for frequently allocated objects")
	}

	if len(detection.GoroutineLeaks) > 0 {
		recommendations = append(recommendations, "Review goroutine creation and cleanup patterns")
		recommendations = append(recommendations, "Implement proper context cancellation for long-running goroutines")
		recommendations = append(recommendations, "Use worker pools to limit concurrent goroutines")
	}

	if detection.TotalLeakedBytes > 1024*1024*100 { // 100MB
		recommendations = append(recommendations, "Consider implementing memory monitoring and alerting")
		recommendations = append(recommendations, "Review application architecture for memory efficiency")
	}

	return recommendations
}

// MemoryAlertManager implementation
func NewMemoryAlertManager(logger *zap.Logger) *MemoryAlertManager {
	return &MemoryAlertManager{
		logger: logger,
		alerts: make([]*MemoryAlert, 0),
	}
}

// CheckAlerts checks for memory-related alerts
func (mam *MemoryAlertManager) CheckAlerts(ctx context.Context, metrics *MemoryMetrics) error {
	mam.mu.Lock()
	defer mam.mu.Unlock()

	// Check memory threshold alerts
	if mam.config != nil && metrics.HeapAllocPercent > mam.config.MemoryThresholdPercent {
		alert := &MemoryAlert{
			ID:        generateMemoryAlertID(),
			Type:      "threshold",
			Severity:  mam.determineAlertSeverity(metrics.HeapAllocPercent, mam.config.MemoryThresholdPercent),
			Message:   fmt.Sprintf("Memory usage threshold exceeded: %.2f%% (threshold: %.2f%%)", metrics.HeapAllocPercent, mam.config.MemoryThresholdPercent),
			Timestamp: time.Now(),
			Metrics:   metrics,
			Threshold: mam.config.MemoryThresholdPercent,
			Current:   metrics.HeapAllocPercent,
			Metadata:  make(map[string]interface{}),
		}
		mam.alerts = append(mam.alerts, alert)
	}

	// Check GC threshold alerts
	if mam.config != nil && metrics.GCCPUFraction > mam.config.GCThresholdPercent {
		alert := &MemoryAlert{
			ID:        generateMemoryAlertID(),
			Type:      "gc_threshold",
			Severity:  mam.determineAlertSeverity(metrics.GCCPUFraction, mam.config.GCThresholdPercent),
			Message:   fmt.Sprintf("GC CPU fraction threshold exceeded: %.2f%% (threshold: %.2f%%)", metrics.GCCPUFraction, mam.config.GCThresholdPercent),
			Timestamp: time.Now(),
			Metrics:   metrics,
			Threshold: mam.config.GCThresholdPercent,
			Current:   metrics.GCCPUFraction,
			Metadata:  make(map[string]interface{}),
		}
		mam.alerts = append(mam.alerts, alert)
	}

	// Check goroutine count alerts
	if metrics.Goroutines > 1000 {
		alert := &MemoryAlert{
			ID:        generateMemoryAlertID(),
			Type:      "goroutine_count",
			Severity:  "high",
			Message:   fmt.Sprintf("High goroutine count: %d", metrics.Goroutines),
			Timestamp: time.Now(),
			Metrics:   metrics,
			Threshold: 1000,
			Current:   float64(metrics.Goroutines),
			Metadata:  make(map[string]interface{}),
		}
		mam.alerts = append(mam.alerts, alert)
	}

	return nil
}

// GetAlerts returns all alerts
func (mam *MemoryAlertManager) GetAlerts(ctx context.Context) ([]*MemoryAlert, error) {
	mam.mu.RLock()
	defer mam.mu.RUnlock()

	alerts := make([]*MemoryAlert, len(mam.alerts))
	copy(alerts, mam.alerts)
	return alerts, nil
}

// ClearAlerts clears old alerts
func (mam *MemoryAlertManager) ClearAlerts(ctx context.Context, olderThan time.Duration) error {
	mam.mu.Lock()
	defer mam.mu.Unlock()

	cutoff := time.Now().Add(-olderThan)
	var newAlerts []*MemoryAlert

	for _, alert := range mam.alerts {
		if alert.Timestamp.After(cutoff) {
			newAlerts = append(newAlerts, alert)
		}
	}

	mam.alerts = newAlerts
	return nil
}

// determineAlertSeverity determines alert severity based on threshold comparison
func (mam *MemoryAlertManager) determineAlertSeverity(current, threshold float64) string {
	ratio := current / threshold
	switch {
	case ratio > 2.0:
		return "critical"
	case ratio > 1.5:
		return "high"
	case ratio > 1.2:
		return "medium"
	default:
		return "low"
	}
}

// Helper function to generate alert ID
func generateMemoryAlertID() string {
	return fmt.Sprintf("mem_alert_%d", time.Now().UnixNano())
}
