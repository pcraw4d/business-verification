
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>middleware: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/pcraw4d/business-verification/internal/api/middleware/audit.go (0.0%)</option>
				
				<option value="file1">github.com/pcraw4d/business-verification/internal/api/middleware/auth.go (0.0%)</option>
				
				<option value="file2">github.com/pcraw4d/business-verification/internal/api/middleware/auth_rate_limit.go (0.0%)</option>
				
				<option value="file3">github.com/pcraw4d/business-verification/internal/api/middleware/ip_block.go (0.0%)</option>
				
				<option value="file4">github.com/pcraw4d/business-verification/internal/api/middleware/permission.go (88.6%)</option>
				
				<option value="file5">github.com/pcraw4d/business-verification/internal/api/middleware/rate_limit.go (0.0%)</option>
				
				<option value="file6">github.com/pcraw4d/business-verification/internal/api/middleware/validation.go (0.0%)</option>
				
				<option value="file7">github.com/pcraw4d/business-verification/internal/classification/data_loader.go (90.4%)</option>
				
				<option value="file8">github.com/pcraw4d/business-verification/internal/classification/fuzzy.go (85.7%)</option>
				
				<option value="file9">github.com/pcraw4d/business-verification/internal/classification/mapping.go (18.8%)</option>
				
				<option value="file10">github.com/pcraw4d/business-verification/internal/classification/normalize.go (93.3%)</option>
				
				<option value="file11">github.com/pcraw4d/business-verification/internal/classification/service.go (49.9%)</option>
				
				<option value="file12">github.com/pcraw4d/business-verification/internal/compliance/alert_system.go (58.5%)</option>
				
				<option value="file13">github.com/pcraw4d/business-verification/internal/compliance/audit_trails.go (0.0%)</option>
				
				<option value="file14">github.com/pcraw4d/business-verification/internal/compliance/check_engine.go (0.0%)</option>
				
				<option value="file15">github.com/pcraw4d/business-verification/internal/compliance/data_retention.go (0.0%)</option>
				
				<option value="file16">github.com/pcraw4d/business-verification/internal/compliance/export_system.go (0.0%)</option>
				
				<option value="file17">github.com/pcraw4d/business-verification/internal/compliance/framework_mapping.go (0.0%)</option>
				
				<option value="file18">github.com/pcraw4d/business-verification/internal/compliance/gap_analysis.go (0.0%)</option>
				
				<option value="file19">github.com/pcraw4d/business-verification/internal/compliance/gdpr_framework.go (0.0%)</option>
				
				<option value="file20">github.com/pcraw4d/business-verification/internal/compliance/gdpr_tracking.go (0.0%)</option>
				
				<option value="file21">github.com/pcraw4d/business-verification/internal/compliance/pci_dss_framework.go (0.0%)</option>
				
				<option value="file22">github.com/pcraw4d/business-verification/internal/compliance/pci_dss_tracking.go (0.0%)</option>
				
				<option value="file23">github.com/pcraw4d/business-verification/internal/compliance/recommendations.go (0.0%)</option>
				
				<option value="file24">github.com/pcraw4d/business-verification/internal/compliance/regional_framework.go (100.0%)</option>
				
				<option value="file25">github.com/pcraw4d/business-verification/internal/compliance/regional_tracking.go (0.0%)</option>
				
				<option value="file26">github.com/pcraw4d/business-verification/internal/compliance/report_generation.go (41.9%)</option>
				
				<option value="file27">github.com/pcraw4d/business-verification/internal/compliance/rule_engine.go (0.0%)</option>
				
				<option value="file28">github.com/pcraw4d/business-verification/internal/compliance/scoring.go (0.0%)</option>
				
				<option value="file29">github.com/pcraw4d/business-verification/internal/compliance/soc2_framework.go (0.0%)</option>
				
				<option value="file30">github.com/pcraw4d/business-verification/internal/compliance/soc2_tracking.go (0.0%)</option>
				
				<option value="file31">github.com/pcraw4d/business-verification/internal/compliance/status_tracking.go (6.8%)</option>
				
				<option value="file32">github.com/pcraw4d/business-verification/internal/compliance/tracking.go (0.0%)</option>
				
				<option value="file33">github.com/pcraw4d/business-verification/internal/config/config.go (71.0%)</option>
				
				<option value="file34">github.com/pcraw4d/business-verification/internal/database/backup.go (0.0%)</option>
				
				<option value="file35">github.com/pcraw4d/business-verification/internal/database/factory.go (0.0%)</option>
				
				<option value="file36">github.com/pcraw4d/business-verification/internal/database/migrations.go (2.5%)</option>
				
				<option value="file37">github.com/pcraw4d/business-verification/internal/database/models.go (100.0%)</option>
				
				<option value="file38">github.com/pcraw4d/business-verification/internal/database/monitoring.go (0.0%)</option>
				
				<option value="file39">github.com/pcraw4d/business-verification/internal/database/postgres.go (0.0%)</option>
				
				<option value="file40">github.com/pcraw4d/business-verification/internal/database/seeds.go (0.0%)</option>
				
				<option value="file41">github.com/pcraw4d/business-verification/internal/datasource/datasource.go (0.0%)</option>
				
				<option value="file42">github.com/pcraw4d/business-verification/internal/datasource/db_source.go (0.0%)</option>
				
				<option value="file43">github.com/pcraw4d/business-verification/internal/datasource/health.go (0.0%)</option>
				
				<option value="file44">github.com/pcraw4d/business-verification/internal/observability/health.go (0.0%)</option>
				
				<option value="file45">github.com/pcraw4d/business-verification/internal/observability/logger.go (83.8%)</option>
				
				<option value="file46">github.com/pcraw4d/business-verification/internal/observability/metrics.go (0.0%)</option>
				
				<option value="file47">github.com/pcraw4d/business-verification/internal/observability/request_id.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package middleware

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/pcraw4d/business-verification/internal/compliance"
        "github.com/pcraw4d/business-verification/internal/observability"
)

// AuditMiddleware provides automatic audit logging for API requests
type AuditMiddleware struct {
        auditSystem *compliance.ComplianceAuditSystem
        logger      *observability.Logger
        enabled     bool
}

// NewAuditMiddleware creates a new audit middleware
func NewAuditMiddleware(auditSystem *compliance.ComplianceAuditSystem, logger *observability.Logger, enabled bool) *AuditMiddleware <span class="cov0" title="0">{
        return &amp;AuditMiddleware{
                auditSystem: auditSystem,
                logger:      logger,
                enabled:     enabled,
        }
}</span>

// AuditLoggingMiddleware wraps HTTP handlers to automatically log audit events
func (m *AuditMiddleware) AuditLoggingMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if !m.enabled </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">start := time.Now()
                ctx := r.Context()

                // Extract user information from context (set by auth middleware)
                userID := extractUserID(ctx)
                userName := extractUserName(ctx)
                userRole := extractUserRole(ctx)
                userEmail := extractUserEmail(ctx)

                // Extract business ID from request
                businessID := extractBusinessID(r)

                // Create a custom response writer to capture status code
                responseWriter := &amp;auditResponseWriter{
                        ResponseWriter: w,
                        statusCode:     http.StatusOK,
                }

                // Process the request
                next.ServeHTTP(responseWriter, r)

                // Calculate duration
                duration := time.Since(start)

                // Determine event type based on request path and method
                eventType := determineEventType(r.Method, r.URL.Path)
                eventCategory := determineEventCategory(r.URL.Path)
                entityType := determineEntityType(r.URL.Path)
                entityID := extractEntityID(r.URL.Path)

                // Determine severity based on request characteristics
                severity := determineSeverity(r.Method, r.URL.Path, responseWriter.statusCode)
                impact := determineImpact(r.Method, r.URL.Path)

                // Create audit event
                event := &amp;compliance.AuditEvent{
                        ID:            generateAuditID(),
                        BusinessID:    businessID,
                        EventType:     eventType,
                        EventCategory: eventCategory,
                        EntityType:    entityType,
                        EntityID:      entityID,
                        Action:        determineAuditAction(r.Method),
                        Description:   fmt.Sprintf("%s %s", r.Method, r.URL.Path),
                        UserID:        userID,
                        UserName:      userName,
                        UserRole:      userRole,
                        UserEmail:     userEmail,
                        IPAddress:     extractIPAddress(r),
                        UserAgent:     r.UserAgent(),
                        SessionID:     extractSessionID(ctx),
                        RequestID:     extractRequestID(ctx),
                        Timestamp:     start,
                        Duration:      duration,
                        Success:       responseWriter.statusCode &lt; 400,
                        ErrorCode:     extractErrorCode(responseWriter.statusCode),
                        ErrorMessage:  extractErrorMessage(responseWriter.statusCode),
                        Metadata: map[string]interface{}{
                                "method":     r.Method,
                                "path":       r.URL.Path,
                                "query":      r.URL.RawQuery,
                                "status":     responseWriter.statusCode,
                                "duration":   duration.String(),
                                "user_agent": r.UserAgent(),
                        },
                        Severity: severity,
                        Impact:   impact,
                        Tags:     extractTags(r.URL.Path),
                }

                // Record the audit event asynchronously to avoid blocking the response
                go func() </span><span class="cov0" title="0">{
                        if err := m.auditSystem.RecordAuditEvent(context.Background(), event); err != nil </span><span class="cov0" title="0">{
                                m.logger.WithComponent("audit").LogAPIRequest(context.Background(), "AUDIT", "record_event", "system", http.StatusInternalServerError, time.Since(start))
                        }</span>
                }()
        })
}

// auditResponseWriter wraps http.ResponseWriter to capture status code
type auditResponseWriter struct {
        http.ResponseWriter
        statusCode int
}

func (w *auditResponseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        w.statusCode = statusCode
        w.ResponseWriter.WriteHeader(statusCode)
}</span>

func (w *auditResponseWriter) Write(data []byte) (int, error) <span class="cov0" title="0">{
        return w.ResponseWriter.Write(data)
}</span>

// Helper functions for extracting information from requests

func extractUserID(ctx context.Context) string <span class="cov0" title="0">{
        if userID, ok := ctx.Value("user_id").(string); ok </span><span class="cov0" title="0">{
                return userID
        }</span>
        <span class="cov0" title="0">return "anonymous"</span>
}

func extractUserName(ctx context.Context) string <span class="cov0" title="0">{
        if userName, ok := ctx.Value("user_name").(string); ok </span><span class="cov0" title="0">{
                return userName
        }</span>
        <span class="cov0" title="0">return "Anonymous User"</span>
}

func extractUserRole(ctx context.Context) string <span class="cov0" title="0">{
        if userRole, ok := ctx.Value("user_role").(string); ok </span><span class="cov0" title="0">{
                return userRole
        }</span>
        <span class="cov0" title="0">return "guest"</span>
}

func extractUserEmail(ctx context.Context) string <span class="cov0" title="0">{
        if userEmail, ok := ctx.Value("user_email").(string); ok </span><span class="cov0" title="0">{
                return userEmail
        }</span>
        <span class="cov0" title="0">return "anonymous@example.com"</span>
}

func extractBusinessID(r *http.Request) string <span class="cov0" title="0">{
        // Try to extract from query parameters
        if businessID := r.URL.Query().Get("business_id"); businessID != "" </span><span class="cov0" title="0">{
                return businessID
        }</span>

        // Try to extract from path parameters
        <span class="cov0" title="0">if businessID := extractPathParam(r.URL.Path, "business_id"); businessID != "" </span><span class="cov0" title="0">{
                return businessID
        }</span>

        // Try to extract from request body for POST/PUT requests
        <span class="cov0" title="0">if r.Method == "POST" || r.Method == "PUT" </span><span class="cov0" title="0">{
                if businessID := extractBusinessIDFromBody(r); businessID != "" </span><span class="cov0" title="0">{
                        return businessID
                }</span>
        }

        <span class="cov0" title="0">return "unknown"</span>
}

func extractBusinessIDFromBody(r *http.Request) string <span class="cov0" title="0">{
        // Read the body
        body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Restore the body for other middleware/handlers
        <span class="cov0" title="0">r.Body = io.NopCloser(bytes.NewReader(body))

        // Try to parse as JSON
        var data map[string]interface{}
        if err := json.Unmarshal(body, &amp;data); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Extract business_id
        <span class="cov0" title="0">if businessID, ok := data["business_id"].(string); ok </span><span class="cov0" title="0">{
                return businessID
        }</span>

        <span class="cov0" title="0">return ""</span>
}

func extractPathParam(path, paramName string) string <span class="cov0" title="0">{
        // Simple path parameter extraction
        // This could be enhanced with a proper router
        // For now, we'll look for common patterns
        if paramName == "business_id" </span><span class="cov0" title="0">{
                // Look for patterns like /business/{business_id}/...
                // This is a simplified implementation
                return ""
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func extractIPAddress(r *http.Request) string <span class="cov0" title="0">{
        // Check for forwarded headers first
        if forwarded := r.Header.Get("X-Forwarded-For"); forwarded != "" </span><span class="cov0" title="0">{
                return forwarded
        }</span>
        <span class="cov0" title="0">if realIP := r.Header.Get("X-Real-IP"); realIP != "" </span><span class="cov0" title="0">{
                return realIP
        }</span>
        <span class="cov0" title="0">return r.RemoteAddr</span>
}

func extractSessionID(ctx context.Context) string <span class="cov0" title="0">{
        if sessionID, ok := ctx.Value("session_id").(string); ok </span><span class="cov0" title="0">{
                return sessionID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func extractRequestID(ctx context.Context) string <span class="cov0" title="0">{
        if requestID, ok := ctx.Value("request_id").(string); ok </span><span class="cov0" title="0">{
                return requestID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func extractErrorCode(statusCode int) string <span class="cov0" title="0">{
        if statusCode &gt;= 400 </span><span class="cov0" title="0">{
                switch </span>{
                case statusCode &gt;= 500:<span class="cov0" title="0">
                        return "server_error"</span>
                case statusCode &gt;= 400:<span class="cov0" title="0">
                        return "client_error"</span>
                default:<span class="cov0" title="0">
                        return "unknown_error"</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

func extractErrorMessage(statusCode int) string <span class="cov0" title="0">{
        if statusCode &gt;= 400 </span><span class="cov0" title="0">{
                switch statusCode </span>{
                case 400:<span class="cov0" title="0">
                        return "Bad Request"</span>
                case 401:<span class="cov0" title="0">
                        return "Unauthorized"</span>
                case 403:<span class="cov0" title="0">
                        return "Forbidden"</span>
                case 404:<span class="cov0" title="0">
                        return "Not Found"</span>
                case 500:<span class="cov0" title="0">
                        return "Internal Server Error"</span>
                default:<span class="cov0" title="0">
                        return "Unknown Error"</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

// Event type determination functions

func determineEventType(method, path string) string <span class="cov0" title="0">{
        switch </span>{
        case path == "/v1/compliance/check":<span class="cov0" title="0">
                return "compliance_check"</span>
        case path == "/v1/compliance/status":<span class="cov0" title="0">
                return "status_check"</span>
        case path == "/v1/compliance/report":<span class="cov0" title="0">
                return "report_generation"</span>
        case path == "/v1/compliance/audit":<span class="cov0" title="0">
                return "audit_access"</span>
        case method == "GET":<span class="cov0" title="0">
                return "data_access"</span>
        case method == "POST":<span class="cov0" title="0">
                return "data_creation"</span>
        case method == "PUT":<span class="cov0" title="0">
                return "data_update"</span>
        case method == "DELETE":<span class="cov0" title="0">
                return "data_deletion"</span>
        default:<span class="cov0" title="0">
                return "api_request"</span>
        }
}

func determineEventCategory(path string) string <span class="cov0" title="0">{
        switch </span>{
        case contains(path, "/compliance/"):<span class="cov0" title="0">
                return "compliance"</span>
        case contains(path, "/audit/"):<span class="cov0" title="0">
                return "audit"</span>
        case contains(path, "/risk/"):<span class="cov0" title="0">
                return "risk"</span>
        case contains(path, "/auth/"):<span class="cov0" title="0">
                return "authentication"</span>
        case contains(path, "/admin/"):<span class="cov0" title="0">
                return "administration"</span>
        default:<span class="cov0" title="0">
                return "general"</span>
        }
}

func determineEntityType(path string) string <span class="cov0" title="0">{
        switch </span>{
        case contains(path, "/compliance/"):<span class="cov0" title="0">
                return "compliance"</span>
        case contains(path, "/audit/"):<span class="cov0" title="0">
                return "audit"</span>
        case contains(path, "/risk/"):<span class="cov0" title="0">
                return "risk"</span>
        case contains(path, "/auth/"):<span class="cov0" title="0">
                return "authentication"</span>
        case contains(path, "/admin/"):<span class="cov0" title="0">
                return "administration"</span>
        default:<span class="cov0" title="0">
                return "api"</span>
        }
}

func extractEntityID(path string) string <span class="cov0" title="0">{
        // Extract entity ID from path
        // This is a simplified implementation
        return path
}</span>

func determineAuditAction(method string) compliance.AuditAction <span class="cov0" title="0">{
        switch method </span>{
        case "GET":<span class="cov0" title="0">
                return compliance.AuditActionRead</span>
        case "POST":<span class="cov0" title="0">
                return compliance.AuditActionCreate</span>
        case "PUT":<span class="cov0" title="0">
                return compliance.AuditActionUpdate</span>
        case "DELETE":<span class="cov0" title="0">
                return compliance.AuditActionDelete</span>
        default:<span class="cov0" title="0">
                return compliance.AuditActionRead</span>
        }
}

func determineSeverity(method, path string, statusCode int) string <span class="cov0" title="0">{
        // High severity for admin operations
        if contains(path, "/admin/") </span><span class="cov0" title="0">{
                return "high"
        }</span>

        // High severity for authentication operations
        <span class="cov0" title="0">if contains(path, "/auth/") </span><span class="cov0" title="0">{
                return "high"
        }</span>

        // Medium severity for compliance operations
        <span class="cov0" title="0">if contains(path, "/compliance/") </span><span class="cov0" title="0">{
                return "medium"
        }</span>

        // High severity for errors
        <span class="cov0" title="0">if statusCode &gt;= 400 </span><span class="cov0" title="0">{
                return "high"
        }</span>

        // Low severity for read operations
        <span class="cov0" title="0">if method == "GET" </span><span class="cov0" title="0">{
                return "low"
        }</span>

        <span class="cov0" title="0">return "medium"</span>
}

func determineImpact(method, path string) string <span class="cov0" title="0">{
        // Critical impact for admin operations
        if contains(path, "/admin/") </span><span class="cov0" title="0">{
                return "critical"
        }</span>

        // High impact for compliance operations
        <span class="cov0" title="0">if contains(path, "/compliance/") </span><span class="cov0" title="0">{
                return "high"
        }</span>

        // Medium impact for write operations
        <span class="cov0" title="0">if method == "POST" || method == "PUT" || method == "DELETE" </span><span class="cov0" title="0">{
                return "medium"
        }</span>

        // Low impact for read operations
        <span class="cov0" title="0">return "low"</span>
}

func extractTags(path string) []string <span class="cov0" title="0">{
        tags := []string{"api_request"}

        if contains(path, "/compliance/") </span><span class="cov0" title="0">{
                tags = append(tags, "compliance")
        }</span>
        <span class="cov0" title="0">if contains(path, "/audit/") </span><span class="cov0" title="0">{
                tags = append(tags, "audit")
        }</span>
        <span class="cov0" title="0">if contains(path, "/risk/") </span><span class="cov0" title="0">{
                tags = append(tags, "risk")
        }</span>
        <span class="cov0" title="0">if contains(path, "/auth/") </span><span class="cov0" title="0">{
                tags = append(tags, "authentication")
        }</span>
        <span class="cov0" title="0">if contains(path, "/admin/") </span><span class="cov0" title="0">{
                tags = append(tags, "administration")
        }</span>

        <span class="cov0" title="0">return tags</span>
}

// Utility functions

func contains(s, substr string) bool <span class="cov0" title="0">{
        return len(s) &gt;= len(substr) &amp;&amp; (s == substr || (len(s) &gt; len(substr) &amp;&amp; (s[:len(substr)] == substr || s[len(s)-len(substr):] == substr || containsSubstring(s, substr))))
}</span>

func containsSubstring(s, substr string) bool <span class="cov0" title="0">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov0" title="0">{
                if s[i:i+len(substr)] == substr </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func generateAuditID() string <span class="cov0" title="0">{
        return fmt.Sprintf("audit-%d", time.Now().UnixNano())
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package middleware

import (
        "context"
        "net/http"
        "strings"

        "github.com/pcraw4d/business-verification/internal/auth"
        "github.com/pcraw4d/business-verification/internal/observability"
)

// AuthMiddleware provides JWT authentication middleware
type AuthMiddleware struct {
        authService *auth.AuthService
        logger      *observability.Logger
}

// NewAuthMiddleware creates a new authentication middleware
func NewAuthMiddleware(authService *auth.AuthService, logger *observability.Logger) *AuthMiddleware <span class="cov0" title="0">{
        return &amp;AuthMiddleware{
                authService: authService,
                logger:      logger,
        }
}</span>

// RequireAuth middleware requires a valid JWT token
func (m *AuthMiddleware) RequireAuth(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := r.Context()

                // Get token from Authorization header
                authHeader := r.Header.Get("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        m.logger.WithComponent("auth").Info("Missing authorization header", "path", r.URL.Path, "method", r.Method)
                        http.Error(w, "Authorization header required", http.StatusUnauthorized)
                        return
                }</span>

                // Extract token (remove "Bearer " prefix)
                <span class="cov0" title="0">tokenString := ""
                if len(authHeader) &gt; 7 &amp;&amp; strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                        tokenString = authHeader[7:]
                }</span> else<span class="cov0" title="0"> {
                        m.logger.WithComponent("auth").Info("Invalid authorization header format", "path", r.URL.Path, "method", r.Method)
                        http.Error(w, "Invalid authorization header format", http.StatusUnauthorized)
                        return
                }</span>

                // Validate token
                <span class="cov0" title="0">user, err := m.authService.ValidateToken(ctx, tokenString)
                if err != nil </span><span class="cov0" title="0">{
                        m.logger.WithComponent("auth").Info("Invalid token", "error", err, "path", r.URL.Path, "method", r.Method)
                        http.Error(w, "Invalid or expired token", http.StatusUnauthorized)
                        return
                }</span>

                // Add user information to context
                <span class="cov0" title="0">ctx = context.WithValue(ctx, "user_id", user.ID)
                ctx = context.WithValue(ctx, "user_email", user.Email)
                ctx = context.WithValue(ctx, "user_role", user.Role)

                // Continue to next handler
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

// RequireRole middleware requires a specific role
func (m *AuthMiddleware) RequireRole(role string) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        ctx := r.Context()

                        // Get user role from context (set by RequireAuth middleware)
                        userRole, ok := ctx.Value("user_role").(string)
                        if !ok </span><span class="cov0" title="0">{
                                m.logger.WithComponent("auth").Error("User role not found in context", "path", r.URL.Path, "method", r.Method)
                                http.Error(w, "Authentication required", http.StatusUnauthorized)
                                return
                        }</span>

                        // Check if user has required role
                        <span class="cov0" title="0">if userRole != role &amp;&amp; userRole != "admin" </span><span class="cov0" title="0">{ // admin has access to everything
                                userID, _ := ctx.Value("user_id").(string)
                                m.logger.WithComponent("auth").Info("Insufficient permissions", "user_id", userID, "required_role", role, "user_role", userRole, "path", r.URL.Path, "method", r.Method)
                                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                                return
                        }</span>

                        // Continue to next handler
                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

// RequireEmailVerified middleware requires email verification
func (m *AuthMiddleware) RequireEmailVerified(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := r.Context()

                // Get user ID from context (set by RequireAuth middleware)
                userID, ok := ctx.Value("user_id").(string)
                if !ok </span><span class="cov0" title="0">{
                        m.logger.WithComponent("auth").Error("User ID not found in context", "path", r.URL.Path, "method", r.Method)
                        http.Error(w, "Authentication required", http.StatusUnauthorized)
                        return
                }</span>

                // Get user details
                <span class="cov0" title="0">user, err := m.authService.GetUserByID(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        m.logger.WithComponent("auth").Error("Failed to get user", "error", err, "user_id", userID, "path", r.URL.Path, "method", r.Method)
                        http.Error(w, "Failed to verify user", http.StatusInternalServerError)
                        return
                }</span>

                // Check if email is verified
                <span class="cov0" title="0">if !user.EmailVerified </span><span class="cov0" title="0">{
                        m.logger.WithComponent("auth").Info("Email not verified", "user_id", userID, "email", user.Email, "path", r.URL.Path, "method", r.Method)
                        http.Error(w, "Email verification required", http.StatusForbidden)
                        return
                }</span>

                // Continue to next handler
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// OptionalAuth middleware adds user information to context if token is provided
func (m *AuthMiddleware) OptionalAuth(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := r.Context()

                // Get token from Authorization header
                authHeader := r.Header.Get("Authorization")
                if authHeader != "" </span><span class="cov0" title="0">{
                        // Extract token (remove "Bearer " prefix)
                        if len(authHeader) &gt; 7 &amp;&amp; strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                                tokenString := authHeader[7:]

                                // Validate token
                                user, err := m.authService.ValidateToken(ctx, tokenString)
                                if err == nil </span><span class="cov0" title="0">{
                                        // Add user information to context
                                        ctx = context.WithValue(ctx, "user_id", user.ID)
                                        ctx = context.WithValue(ctx, "user_email", user.Email)
                                        ctx = context.WithValue(ctx, "user_role", user.Role)
                                }</span>
                        }
                }

                // Continue to next handler (with or without user context)
                <span class="cov0" title="0">next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package middleware

import (
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// AuthRateLimitConfig holds authentication-specific rate limiting configuration
type AuthRateLimitConfig struct {
        Enabled                  bool
        LoginAttemptsPer         int           // Login attempts per window
        RegisterAttemptsPer      int           // Registration attempts per window
        PasswordResetAttemptsPer int           // Password reset attempts per window
        WindowSize               time.Duration // Time window for rate limiting
        LockoutDuration          time.Duration // Duration to lock out after exceeding limits
}

// AuthRateLimiter implements specialized rate limiting for authentication endpoints
type AuthRateLimiter struct {
        config    *AuthRateLimitConfig
        logger    *observability.Logger
        buckets   map[string]*authBucket
        mu        sync.RWMutex
        cleanupCh chan struct{}
}

// authBucket represents a rate limiting bucket for authentication endpoints
type authBucket struct {
        loginAttempts            int
        registerAttempts         int
        passwordResetAttempts    int
        lastLoginAttempt         time.Time
        lastRegisterAttempt      time.Time
        lastPasswordResetAttempt time.Time
        lockedUntil              *time.Time
        mu                       sync.Mutex
}

// NewAuthRateLimiter creates a new authentication rate limiting middleware
func NewAuthRateLimiter(config *AuthRateLimitConfig, logger *observability.Logger) *AuthRateLimiter <span class="cov0" title="0">{
        arl := &amp;AuthRateLimiter{
                config:    config,
                logger:    logger,
                buckets:   make(map[string]*authBucket),
                cleanupCh: make(chan struct{}),
        }

        // Start cleanup goroutine to remove stale buckets
        go arl.cleanup()

        return arl
}</span>

// Middleware returns the authentication rate limiting middleware
func (arl *AuthRateLimiter) Middleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if !arl.config.Enabled </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Only apply to authentication endpoints
                <span class="cov0" title="0">if !arl.isAuthEndpoint(r.URL.Path) </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">clientIP := arl.getClientIP(r)
                endpointType := arl.getEndpointType(r.URL.Path)

                // Check if client is locked out
                if arl.isLockedOut(clientIP) </span><span class="cov0" title="0">{
                        arl.logger.WithComponent("auth_rate_limiter").Warn("Authentication endpoint access blocked - client locked out",
                                "client_ip", clientIP,
                                "path", r.URL.Path,
                                "method", r.Method)

                        w.Header().Set("X-RateLimit-Limit", "0")
                        w.Header().Set("X-RateLimit-Remaining", "0")
                        w.Header().Set("Retry-After", "300") // 5 minutes
                        http.Error(w, "Too many authentication attempts. Please try again later.", http.StatusTooManyRequests)
                        return
                }</span>

                // Check rate limit for specific endpoint type
                <span class="cov0" title="0">if !arl.allowRequest(clientIP, endpointType) </span><span class="cov0" title="0">{
                        arl.logger.WithComponent("auth_rate_limiter").Warn("Authentication rate limit exceeded",
                                "client_ip", clientIP,
                                "path", r.URL.Path,
                                "method", r.Method,
                                "endpoint_type", endpointType)

                        w.Header().Set("X-RateLimit-Limit", arl.getLimitForEndpoint(endpointType))
                        w.Header().Set("X-RateLimit-Remaining", "0")
                        w.Header().Set("Retry-After", "60")
                        http.Error(w, "Too many authentication attempts. Please try again later.", http.StatusTooManyRequests)
                        return
                }</span>

                // Add rate limit headers
                <span class="cov0" title="0">remaining := arl.getRemaining(clientIP, endpointType)
                w.Header().Set("X-RateLimit-Limit", arl.getLimitForEndpoint(endpointType))
                w.Header().Set("X-RateLimit-Remaining", string(rune(remaining)))

                next.ServeHTTP(w, r)</span>
        })
}

// isAuthEndpoint checks if the path is an authentication endpoint
func (arl *AuthRateLimiter) isAuthEndpoint(path string) bool <span class="cov0" title="0">{
        authEndpoints := []string{
                "/v1/auth/login",
                "/v1/auth/register",
                "/v1/auth/request-password-reset",
                "/v1/auth/reset-password",
                "/v1/auth/verify-email",
        }

        for _, endpoint := range authEndpoints </span><span class="cov0" title="0">{
                if strings.HasPrefix(path, endpoint) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// getEndpointType determines the type of authentication endpoint
func (arl *AuthRateLimiter) getEndpointType(path string) string <span class="cov0" title="0">{
        switch </span>{
        case strings.HasPrefix(path, "/v1/auth/login"):<span class="cov0" title="0">
                return "login"</span>
        case strings.HasPrefix(path, "/v1/auth/register"):<span class="cov0" title="0">
                return "register"</span>
        case strings.HasPrefix(path, "/v1/auth/request-password-reset"):<span class="cov0" title="0">
                return "password_reset"</span>
        case strings.HasPrefix(path, "/v1/auth/reset-password"):<span class="cov0" title="0">
                return "password_reset"</span>
        case strings.HasPrefix(path, "/v1/auth/verify-email"):<span class="cov0" title="0">
                return "email_verification"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// getLimitForEndpoint returns the rate limit for a specific endpoint type
func (arl *AuthRateLimiter) getLimitForEndpoint(endpointType string) string <span class="cov0" title="0">{
        switch endpointType </span>{
        case "login":<span class="cov0" title="0">
                return string(rune(arl.config.LoginAttemptsPer))</span>
        case "register":<span class="cov0" title="0">
                return string(rune(arl.config.RegisterAttemptsPer))</span>
        case "password_reset":<span class="cov0" title="0">
                return string(rune(arl.config.PasswordResetAttemptsPer))</span>
        default:<span class="cov0" title="0">
                return "10"</span>
        }
}

// isLockedOut checks if a client is currently locked out
func (arl *AuthRateLimiter) isLockedOut(clientIP string) bool <span class="cov0" title="0">{
        arl.mu.RLock()
        defer arl.mu.RUnlock()

        bucket, exists := arl.buckets[clientIP]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">bucket.mu.Lock()
        defer bucket.mu.Unlock()

        if bucket.lockedUntil != nil &amp;&amp; time.Now().Before(*bucket.lockedUntil) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Clear lockout if expired
        <span class="cov0" title="0">if bucket.lockedUntil != nil &amp;&amp; time.Now().After(*bucket.lockedUntil) </span><span class="cov0" title="0">{
                bucket.lockedUntil = nil
        }</span>

        <span class="cov0" title="0">return false</span>
}

// allowRequest checks if a request should be allowed for the given client and endpoint type
func (arl *AuthRateLimiter) allowRequest(clientIP, endpointType string) bool <span class="cov0" title="0">{
        arl.mu.Lock()
        defer arl.mu.Unlock()

        bucket, exists := arl.buckets[clientIP]
        if !exists </span><span class="cov0" title="0">{
                bucket = &amp;authBucket{}
                arl.buckets[clientIP] = bucket
        }</span>

        <span class="cov0" title="0">bucket.mu.Lock()
        defer bucket.mu.Unlock()

        now := time.Now()

        // Check if we need to reset counters based on window size
        arl.resetCountersIfNeeded(bucket, now)

        // Check limits based on endpoint type
        switch endpointType </span>{
        case "login":<span class="cov0" title="0">
                if bucket.loginAttempts &gt;= arl.config.LoginAttemptsPer </span><span class="cov0" title="0">{
                        arl.lockoutClient(bucket, now)
                        return false
                }</span>
                <span class="cov0" title="0">bucket.loginAttempts++
                bucket.lastLoginAttempt = now</span>

        case "register":<span class="cov0" title="0">
                if bucket.registerAttempts &gt;= arl.config.RegisterAttemptsPer </span><span class="cov0" title="0">{
                        arl.lockoutClient(bucket, now)
                        return false
                }</span>
                <span class="cov0" title="0">bucket.registerAttempts++
                bucket.lastRegisterAttempt = now</span>

        case "password_reset":<span class="cov0" title="0">
                if bucket.passwordResetAttempts &gt;= arl.config.PasswordResetAttemptsPer </span><span class="cov0" title="0">{
                        arl.lockoutClient(bucket, now)
                        return false
                }</span>
                <span class="cov0" title="0">bucket.passwordResetAttempts++
                bucket.lastPasswordResetAttempt = now</span>

        default:<span class="cov0" title="0">
                // Allow unknown endpoint types
                return true</span>
        }

        <span class="cov0" title="0">return true</span>
}

// resetCountersIfNeeded resets counters if the window has passed
func (arl *AuthRateLimiter) resetCountersIfNeeded(bucket *authBucket, now time.Time) <span class="cov0" title="0">{
        windowAgo := now.Add(-arl.config.WindowSize)

        if bucket.lastLoginAttempt.Before(windowAgo) </span><span class="cov0" title="0">{
                bucket.loginAttempts = 0
        }</span>
        <span class="cov0" title="0">if bucket.lastRegisterAttempt.Before(windowAgo) </span><span class="cov0" title="0">{
                bucket.registerAttempts = 0
        }</span>
        <span class="cov0" title="0">if bucket.lastPasswordResetAttempt.Before(windowAgo) </span><span class="cov0" title="0">{
                bucket.passwordResetAttempts = 0
        }</span>
}

// lockoutClient locks out a client for the configured duration
func (arl *AuthRateLimiter) lockoutClient(bucket *authBucket, now time.Time) <span class="cov0" title="0">{
        lockoutUntil := now.Add(arl.config.LockoutDuration)
        bucket.lockedUntil = &amp;lockoutUntil

        arl.logger.WithComponent("auth_rate_limiter").Warn("Client locked out due to excessive authentication attempts",
                "lockout_until", lockoutUntil.Format(time.RFC3339),
                "duration", arl.config.LockoutDuration)
}</span>

// getRemaining returns the number of remaining requests for a client and endpoint type
func (arl *AuthRateLimiter) getRemaining(clientIP, endpointType string) int <span class="cov0" title="0">{
        arl.mu.RLock()
        defer arl.mu.RUnlock()

        bucket, exists := arl.buckets[clientIP]
        if !exists </span><span class="cov0" title="0">{
                return arl.getLimitForEndpointType(endpointType)
        }</span>

        <span class="cov0" title="0">bucket.mu.Lock()
        defer bucket.mu.Unlock()

        // Reset counters if needed
        arl.resetCountersIfNeeded(bucket, time.Now())

        switch endpointType </span>{
        case "login":<span class="cov0" title="0">
                return max(0, arl.config.LoginAttemptsPer-bucket.loginAttempts)</span>
        case "register":<span class="cov0" title="0">
                return max(0, arl.config.RegisterAttemptsPer-bucket.registerAttempts)</span>
        case "password_reset":<span class="cov0" title="0">
                return max(0, arl.config.PasswordResetAttemptsPer-bucket.passwordResetAttempts)</span>
        default:<span class="cov0" title="0">
                return 10</span>
        }
}

// getLimitForEndpointType returns the limit for a specific endpoint type
func (arl *AuthRateLimiter) getLimitForEndpointType(endpointType string) int <span class="cov0" title="0">{
        switch endpointType </span>{
        case "login":<span class="cov0" title="0">
                return arl.config.LoginAttemptsPer</span>
        case "register":<span class="cov0" title="0">
                return arl.config.RegisterAttemptsPer</span>
        case "password_reset":<span class="cov0" title="0">
                return arl.config.PasswordResetAttemptsPer</span>
        default:<span class="cov0" title="0">
                return 10</span>
        }
}

// getClientIP extracts the client IP from the request
func (arl *AuthRateLimiter) getClientIP(r *http.Request) string <span class="cov0" title="0">{
        // Check X-Forwarded-For header
        if xff := r.Header.Get("X-Forwarded-For"); xff != "" </span><span class="cov0" title="0">{
                return xff
        }</span>

        // Check X-Real-IP header
        <span class="cov0" title="0">if xri := r.Header.Get("X-Real-IP"); xri != "" </span><span class="cov0" title="0">{
                return xri
        }</span>

        // Fall back to RemoteAddr
        <span class="cov0" title="0">return r.RemoteAddr</span>
}

// cleanup removes stale buckets to prevent memory leaks
func (arl *AuthRateLimiter) cleanup() <span class="cov0" title="0">{
        ticker := time.NewTicker(10 * time.Minute)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        arl.cleanupStale()</span>
                case &lt;-arl.cleanupCh:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// cleanupStale removes buckets that haven't been used recently
func (arl *AuthRateLimiter) cleanupStale() <span class="cov0" title="0">{
        arl.mu.Lock()
        defer arl.mu.Unlock()

        now := time.Now()
        staleThreshold := 30 * time.Minute

        for ip, bucket := range arl.buckets </span><span class="cov0" title="0">{
                bucket.mu.Lock()

                // Check if bucket is stale (no recent activity and not locked out)
                isStale := true
                if bucket.lockedUntil != nil &amp;&amp; now.Before(*bucket.lockedUntil) </span><span class="cov0" title="0">{
                        isStale = false
                }</span> else<span class="cov0" title="0"> if now.Sub(bucket.lastLoginAttempt) &lt; staleThreshold ||
                        now.Sub(bucket.lastRegisterAttempt) &lt; staleThreshold ||
                        now.Sub(bucket.lastPasswordResetAttempt) &lt; staleThreshold </span><span class="cov0" title="0">{
                        isStale = false
                }</span>

                <span class="cov0" title="0">if isStale </span><span class="cov0" title="0">{
                        delete(arl.buckets, ip)
                }</span>

                <span class="cov0" title="0">bucket.mu.Unlock()</span>
        }
}

// Stop stops the rate limiter and cleanup goroutine
func (arl *AuthRateLimiter) Stop() <span class="cov0" title="0">{
        close(arl.cleanupCh)
}</span>

// max returns the maximum of two integers
func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package middleware

import (
        "net"
        "net/http"
        "sync"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// IPBlocker blocks requests from abusive IPs based on response patterns
// Suspicious activity heuristic: many 4xx/401/403/429 within a short window.
type IPBlocker struct {
        enabled       bool
        threshold     int
        window        time.Duration
        blockDuration time.Duration
        whitelist     map[string]struct{}
        blacklist     map[string]struct{}
        logger        *observability.Logger

        mu       sync.RWMutex
        records  map[string]*ipRecord
        cleanupC chan struct{}
}

type ipRecord struct {
        failures    int
        firstSeen   time.Time
        blockedTill *time.Time
}

// NewIPBlocker constructs a new IP blocker middleware
func NewIPBlocker(enabled bool, threshold int, window, blockDuration time.Duration, whitelist, blacklist []string, logger *observability.Logger) *IPBlocker <span class="cov0" title="0">{
        b := &amp;IPBlocker{
                enabled:       enabled,
                threshold:     threshold,
                window:        window,
                blockDuration: blockDuration,
                whitelist:     sliceToSet(whitelist),
                blacklist:     sliceToSet(blacklist),
                logger:        logger,
                records:       make(map[string]*ipRecord),
                cleanupC:      make(chan struct{}),
        }
        go b.cleanup()
        return b
}</span>

// Middleware applies IP blocking to requests
func (b *IPBlocker) Middleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if !b.enabled </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">ip := clientIP(r)
                if b.isWhitelisted(ip) </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>
                <span class="cov0" title="0">if b.isBlacklisted(ip) || b.isBlocked(ip) </span><span class="cov0" title="0">{
                        b.logger.WithComponent("ip_block").Warn("Blocked request from IP", "client_ip", ip, "path", r.URL.Path)
                        http.Error(w, "Access from your IP is temporarily blocked", http.StatusTooManyRequests)
                        return
                }</span>

                // Wrap ResponseWriter to inspect status code after handler runs
                <span class="cov0" title="0">rec := &amp;statusRecorder{ResponseWriter: w, status: 200}
                next.ServeHTTP(rec, r)

                // Count suspicious responses
                if rec.status &gt;= 400 </span><span class="cov0" title="0">{
                        b.noteFailure(ip)
                }</span>
        })
}

type statusRecorder struct {
        http.ResponseWriter
        status int
}

func (sr *statusRecorder) WriteHeader(code int) <span class="cov0" title="0">{
        sr.status = code
        sr.ResponseWriter.WriteHeader(code)
}</span>

func (b *IPBlocker) isWhitelisted(ip string) bool <span class="cov0" title="0">{
        _, ok := b.whitelist[ip]
        return ok
}</span>

func (b *IPBlocker) isBlacklisted(ip string) bool <span class="cov0" title="0">{
        _, ok := b.blacklist[ip]
        return ok
}</span>

func (b *IPBlocker) isBlocked(ip string) bool <span class="cov0" title="0">{
        b.mu.RLock()
        rec, ok := b.records[ip]
        b.mu.RUnlock()
        if !ok || rec.blockedTill == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if time.Now().Before(*rec.blockedTill) </span><span class="cov0" title="0">{
                return true
        }</span>
        // unblock expired
        <span class="cov0" title="0">b.mu.Lock()
        rec.blockedTill = nil
        b.mu.Unlock()
        return false</span>
}

func (b *IPBlocker) noteFailure(ip string) <span class="cov0" title="0">{
        now := time.Now()

        b.mu.Lock()
        rec, ok := b.records[ip]
        if !ok </span><span class="cov0" title="0">{
                rec = &amp;ipRecord{failures: 0, firstSeen: now}
                b.records[ip] = rec
        }</span>

        // reset window if expired
        <span class="cov0" title="0">if now.Sub(rec.firstSeen) &gt; b.window </span><span class="cov0" title="0">{
                rec.failures = 0
                rec.firstSeen = now
        }</span>

        <span class="cov0" title="0">rec.failures++
        if rec.failures &gt;= b.threshold </span><span class="cov0" title="0">{
                until := now.Add(b.blockDuration)
                rec.blockedTill = &amp;until
                b.logger.WithComponent("ip_block").Warn("IP temporarily blocked due to suspicious activity",
                        "client_ip", ip,
                        "failures", rec.failures,
                        "block_until", until.Format(time.RFC3339))
        }</span>
        <span class="cov0" title="0">b.mu.Unlock()</span>
}

func (b *IPBlocker) cleanup() <span class="cov0" title="0">{
        t := time.NewTicker(10 * time.Minute)
        defer t.Stop()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-t.C:<span class="cov0" title="0">
                        b.gc()</span>
                case &lt;-b.cleanupC:<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (b *IPBlocker) gc() <span class="cov0" title="0">{
        now := time.Now()
        b.mu.Lock()
        for ip, rec := range b.records </span><span class="cov0" title="0">{
                if rec.blockedTill == nil &amp;&amp; now.Sub(rec.firstSeen) &gt; 2*b.window </span><span class="cov0" title="0">{
                        delete(b.records, ip)
                }</span>
        }
        <span class="cov0" title="0">b.mu.Unlock()</span>
}

func sliceToSet(values []string) map[string]struct{} <span class="cov0" title="0">{
        m := make(map[string]struct{}, len(values))
        for _, v := range values </span><span class="cov0" title="0">{
                if v == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">m[v] = struct{}{}</span>
        }
        <span class="cov0" title="0">return m</span>
}

func clientIP(r *http.Request) string <span class="cov0" title="0">{
        if xff := r.Header.Get("X-Forwarded-For"); xff != "" </span><span class="cov0" title="0">{
                return xff
        }</span>
        <span class="cov0" title="0">if xri := r.Header.Get("X-Real-IP"); xri != "" </span><span class="cov0" title="0">{
                return xri
        }</span>
        <span class="cov0" title="0">host, _, err := net.SplitHostPort(r.RemoteAddr)
        if err == nil </span><span class="cov0" title="0">{
                return host
        }</span>
        <span class="cov0" title="0">return r.RemoteAddr</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package middleware

import (
        "context"
        "fmt"
        "net/http"
        "strings"

        "github.com/pcraw4d/business-verification/internal/auth"
        "github.com/pcraw4d/business-verification/internal/observability"
)

// PermissionMiddleware handles RBAC permission checking for API endpoints
type PermissionMiddleware struct {
        rbacService auth.RBACServiceInterface
        logger      *observability.Logger
}

// NewPermissionMiddleware creates a new permission middleware instance
func NewPermissionMiddleware(rbacService auth.RBACServiceInterface, logger *observability.Logger) *PermissionMiddleware <span class="cov8" title="1">{
        return &amp;PermissionMiddleware{
                rbacService: rbacService,
                logger:      logger,
        }
}</span>

// Middleware function that checks permissions for each request
func (pm *PermissionMiddleware) Middleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Skip permission checking for public endpoints
                if pm.isPublicEndpoint(r.Method, r.URL.Path) </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Extract user context from request
                <span class="cov8" title="1">userID, userRole, err := pm.extractUserContext(r)
                if err != nil </span><span class="cov8" title="1">{
                        pm.logger.WithComponent("permission_middleware").WithError(err).Warn("Failed to extract user context")
                        http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        return
                }</span>

                // Check if user has permission for this endpoint
                <span class="cov8" title="1">if err := pm.rbacService.CheckPermission(r.Context(), userRole, r.Method, r.URL.Path); err != nil </span><span class="cov8" title="1">{
                        pm.logger.WithComponent("permission_middleware").WithFields(map[string]interface{}{
                                "user_id": userID,
                                "role":    userRole,
                                "method":  r.Method,
                                "path":    r.URL.Path,
                        }).Warn("Permission denied")

                        http.Error(w, "Forbidden", http.StatusForbidden)
                        return
                }</span>

                // Add user context to request for downstream handlers
                <span class="cov8" title="1">ctx := context.WithValue(r.Context(), "user_id", userID)
                ctx = context.WithValue(ctx, "user_role", userRole)
                r = r.WithContext(ctx)

                // Log successful permission check
                pm.logger.WithComponent("permission_middleware").WithFields(map[string]interface{}{
                        "user_id": userID,
                        "role":    userRole,
                        "method":  r.Method,
                        "path":    r.URL.Path,
                }).Debug("Permission check passed")

                next.ServeHTTP(w, r)</span>
        })
}

// isPublicEndpoint checks if an endpoint is publicly accessible
func (pm *PermissionMiddleware) isPublicEndpoint(method, path string) bool <span class="cov8" title="1">{
        publicEndpoints := map[string][]string{
                "GET": {
                        "/health",
                        "/v1/health",
                        "/docs",
                        "/docs/",
                        "/v1/docs",
                        "/v1/docs/",
                },
                "POST": {
                        "/v1/auth/login",
                        "/v1/auth/register",
                        "/v1/auth/refresh",
                        "/v1/auth/forgot-password",
                        "/v1/auth/reset-password",
                },
        }

        if endpoints, exists := publicEndpoints[method]; exists </span><span class="cov8" title="1">{
                for _, endpoint := range endpoints </span><span class="cov8" title="1">{
                        if strings.HasPrefix(path, endpoint) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

// extractUserContext extracts user information from the request
func (pm *PermissionMiddleware) extractUserContext(r *http.Request) (string, auth.Role, error) <span class="cov8" title="1">{
        // First try to get from JWT token in Authorization header
        if userID, userRole, err := pm.extractFromJWT(r); err == nil </span><span class="cov8" title="1">{
                return userID, userRole, nil
        }</span>

        // Then try to get from API key
        <span class="cov8" title="1">if userID, userRole, err := pm.extractFromAPIKey(r); err == nil </span><span class="cov8" title="1">{
                return userID, userRole, nil
        }</span>

        // Finally, check for system/internal requests
        <span class="cov8" title="1">if userID, userRole, err := pm.extractFromSystemContext(r); err == nil </span><span class="cov8" title="1">{
                return userID, userRole, nil
        }</span>

        <span class="cov8" title="1">return "", "", fmt.Errorf("no valid authentication found")</span>
}

// extractFromJWT extracts user context from JWT token
func (pm *PermissionMiddleware) extractFromJWT(r *http.Request) (string, auth.Role, error) <span class="cov8" title="1">{
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" </span><span class="cov8" title="1">{
                return "", "", fmt.Errorf("no authorization header")
        }</span>

        // Check for Bearer token
        <span class="cov8" title="1">if !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("invalid authorization header format")
        }</span>

        <span class="cov8" title="1">token := strings.TrimPrefix(authHeader, "Bearer ")

        // TODO: Implement JWT token validation and user extraction
        // For now, return a placeholder implementation
        // In a real implementation, you would:
        // 1. Validate the JWT token
        // 2. Extract user ID and role from claims
        // 3. Verify token hasn't expired
        // 4. Check if token is blacklisted

        // Placeholder implementation
        if token == "admin-token" </span><span class="cov8" title="1">{
                return "admin-user", auth.RoleAdmin, nil
        }</span>
        <span class="cov8" title="1">if token == "user-token" </span><span class="cov8" title="1">{
                return "user-1", auth.RoleUser, nil
        }</span>
        <span class="cov8" title="1">if token == "analyst-token" </span><span class="cov0" title="0">{
                return "analyst-1", auth.RoleAnalyst, nil
        }</span>
        <span class="cov8" title="1">if token == "manager-token" </span><span class="cov0" title="0">{
                return "manager-1", auth.RoleManager, nil
        }</span>
        <span class="cov8" title="1">if token == "guest-token" </span><span class="cov0" title="0">{
                return "guest-1", auth.RoleGuest, nil
        }</span>

        <span class="cov8" title="1">return "", "", fmt.Errorf("invalid token")</span>
}

// extractFromAPIKey extracts user context from API key
func (pm *PermissionMiddleware) extractFromAPIKey(r *http.Request) (string, auth.Role, error) <span class="cov8" title="1">{
        apiKey := r.Header.Get("X-API-Key")
        if apiKey == "" </span><span class="cov8" title="1">{
                return "", "", fmt.Errorf("no API key provided")
        }</span>

        // TODO: Implement API key validation
        // In a real implementation, you would:
        // 1. Look up the API key in the database
        // 2. Check if it's active and not expired
        // 3. Extract user ID and role from the API key record
        // 4. Update last used timestamp

        // Placeholder implementation
        <span class="cov8" title="1">if apiKey == "system-api-key" </span><span class="cov8" title="1">{
                return "system-user", auth.RoleSystem, nil
        }</span>

        <span class="cov0" title="0">return "", "", fmt.Errorf("invalid API key")</span>
}

// extractFromSystemContext extracts user context from system/internal requests
func (pm *PermissionMiddleware) extractFromSystemContext(r *http.Request) (string, auth.Role, error) <span class="cov8" title="1">{
        // Check for internal system headers
        systemToken := r.Header.Get("X-System-Token")
        if systemToken == "internal-system" </span><span class="cov8" title="1">{
                return "system-internal", auth.RoleSystem, nil
        }</span>

        // Check for health check or monitoring requests
        <span class="cov8" title="1">userAgent := r.Header.Get("User-Agent")
        if strings.Contains(userAgent, "health-check") || strings.Contains(userAgent, "monitoring") </span><span class="cov8" title="1">{
                return "monitoring-system", auth.RoleSystem, nil
        }</span>

        <span class="cov8" title="1">return "", "", fmt.Errorf("not a system request")</span>
}

// GetUserIDFromContext extracts user ID from request context
func GetUserIDFromContext(ctx context.Context) (string, bool) <span class="cov8" title="1">{
        userID, ok := ctx.Value("user_id").(string)
        return userID, ok
}</span>

// GetUserRoleFromContext extracts user role from request context
func GetUserRoleFromContext(ctx context.Context) (auth.Role, bool) <span class="cov8" title="1">{
        userRole, ok := ctx.Value("user_role").(auth.Role)
        return userRole, ok
}</span>

// RequirePermission creates a middleware that requires a specific permission
func (pm *PermissionMiddleware) RequirePermission(permission auth.Permission) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        userRole, ok := GetUserRoleFromContext(r.Context())
                        if !ok </span><span class="cov0" title="0">{
                                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov8" title="1">if !auth.HasPermission(userRole, permission) </span><span class="cov8" title="1">{
                                pm.logger.WithComponent("permission_middleware").WithFields(map[string]interface{}{
                                        "user_role":  userRole,
                                        "permission": permission,
                                        "method":     r.Method,
                                        "path":       r.URL.Path,
                                }).Warn("Permission denied for specific permission check")

                                http.Error(w, "Forbidden", http.StatusForbidden)
                                return
                        }</span>

                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                })
        }
}

// RequireRole creates a middleware that requires a specific role
func (pm *PermissionMiddleware) RequireRole(role auth.Role) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        userRole, ok := GetUserRoleFromContext(r.Context())
                        if !ok </span><span class="cov0" title="0">{
                                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov8" title="1">if userRole != role </span><span class="cov8" title="1">{
                                pm.logger.WithComponent("permission_middleware").WithFields(map[string]interface{}{
                                        "user_role": userRole,
                                        "required":  role,
                                        "method":    r.Method,
                                        "path":      r.URL.Path,
                                }).Warn("Role access denied")

                                http.Error(w, "Forbidden", http.StatusForbidden)
                                return
                        }</span>

                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                })
        }
}

// RequireMinimumRole creates a middleware that requires at least a specific role
func (pm *PermissionMiddleware) RequireMinimumRole(minRole auth.Role) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        userRole, ok := GetUserRoleFromContext(r.Context())
                        if !ok </span><span class="cov0" title="0">{
                                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov8" title="1">if !pm.hasMinimumRole(userRole, minRole) </span><span class="cov8" title="1">{
                                pm.logger.WithComponent("permission_middleware").WithFields(map[string]interface{}{
                                        "user_role":    userRole,
                                        "minimum_role": minRole,
                                        "method":       r.Method,
                                        "path":         r.URL.Path,
                                }).Warn("Minimum role requirement not met")

                                http.Error(w, "Forbidden", http.StatusForbidden)
                                return
                        }</span>

                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                })
        }
}

// hasMinimumRole checks if a user role meets the minimum requirement
func (pm *PermissionMiddleware) hasMinimumRole(userRole, minRole auth.Role) bool <span class="cov8" title="1">{
        roleHierarchy := map[auth.Role]int{
                auth.RoleGuest:   0,
                auth.RoleUser:    1,
                auth.RoleAnalyst: 2,
                auth.RoleManager: 3,
                auth.RoleAdmin:   4,
                auth.RoleSystem:  5,
        }

        userLevel, userExists := roleHierarchy[userRole]
        minLevel, minExists := roleHierarchy[minRole]

        if !userExists || !minExists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return userLevel &gt;= minLevel</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package middleware

import (
        "net/http"
        "sync"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// RateLimitConfig holds rate limiting configuration
type RateLimitConfig struct {
        RequestsPerMinute int
        BurstSize         int
        Enabled           bool
}

// RateLimiter implements a token bucket rate limiter
type RateLimiter struct {
        config    *RateLimitConfig
        logger    *observability.Logger
        buckets   map[string]*bucket
        mu        sync.RWMutex
        cleanupCh chan struct{}
}

// bucket represents a token bucket for a specific client
type bucket struct {
        tokens     int
        maxTokens  int
        refillRate time.Duration
        lastRefill time.Time
        mu         sync.Mutex
}

// NewRateLimiter creates a new rate limiting middleware
func NewRateLimiter(config *RateLimitConfig, logger *observability.Logger) *RateLimiter <span class="cov0" title="0">{
        rl := &amp;RateLimiter{
                config:    config,
                logger:    logger,
                buckets:   make(map[string]*bucket),
                cleanupCh: make(chan struct{}),
        }

        // Start cleanup goroutine to remove stale buckets
        go rl.cleanup()

        return rl
}</span>

// Middleware returns the rate limiting middleware
func (rl *RateLimiter) Middleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if !rl.config.Enabled </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">clientIP := rl.getClientIP(r)

                if !rl.allow(clientIP) </span><span class="cov0" title="0">{
                        rl.logger.WithComponent("rate_limiter").Warn("Rate limit exceeded",
                                "client_ip", clientIP,
                                "path", r.URL.Path,
                                "method", r.Method)

                        w.Header().Set("X-RateLimit-Limit", string(rune(rl.config.RequestsPerMinute)))
                        w.Header().Set("X-RateLimit-Remaining", "0")
                        w.Header().Set("Retry-After", "60")
                        http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
                        return
                }</span>

                // Add rate limit headers
                <span class="cov0" title="0">remaining := rl.getRemaining(clientIP)
                w.Header().Set("X-RateLimit-Limit", string(rune(rl.config.RequestsPerMinute)))
                w.Header().Set("X-RateLimit-Remaining", string(rune(remaining)))

                next.ServeHTTP(w, r)</span>
        })
}

// allow checks if a request should be allowed for the given client
func (rl *RateLimiter) allow(clientIP string) bool <span class="cov0" title="0">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        b, exists := rl.buckets[clientIP]
        if !exists </span><span class="cov0" title="0">{
                b = &amp;bucket{
                        tokens:     rl.config.BurstSize,
                        maxTokens:  rl.config.BurstSize,
                        refillRate: time.Minute / time.Duration(rl.config.RequestsPerMinute),
                        lastRefill: time.Now(),
                }
                rl.buckets[clientIP] = b
        }</span>

        <span class="cov0" title="0">b.mu.Lock()
        defer b.mu.Unlock()

        now := time.Now()
        elapsed := now.Sub(b.lastRefill)

        // Refill tokens based on elapsed time
        tokensToAdd := int(elapsed / b.refillRate)
        if tokensToAdd &gt; 0 </span><span class="cov0" title="0">{
                b.tokens = min(b.maxTokens, b.tokens+tokensToAdd)
                b.lastRefill = now
        }</span>

        // Check if we have tokens available
        <span class="cov0" title="0">if b.tokens &gt; 0 </span><span class="cov0" title="0">{
                b.tokens--
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// getRemaining returns the number of remaining requests for a client
func (rl *RateLimiter) getRemaining(clientIP string) int <span class="cov0" title="0">{
        rl.mu.RLock()
        defer rl.mu.RUnlock()

        b, exists := rl.buckets[clientIP]
        if !exists </span><span class="cov0" title="0">{
                return rl.config.BurstSize
        }</span>

        <span class="cov0" title="0">b.mu.Lock()
        defer b.mu.Unlock()

        return b.tokens</span>
}

// getClientIP extracts the client IP from the request
func (rl *RateLimiter) getClientIP(r *http.Request) string <span class="cov0" title="0">{
        // Check X-Forwarded-For header
        if xff := r.Header.Get("X-Forwarded-For"); xff != "" </span><span class="cov0" title="0">{
                return xff
        }</span>

        // Check X-Real-IP header
        <span class="cov0" title="0">if xri := r.Header.Get("X-Real-IP"); xri != "" </span><span class="cov0" title="0">{
                return xri
        }</span>

        // Fall back to RemoteAddr
        <span class="cov0" title="0">return r.RemoteAddr</span>
}

// cleanup removes stale buckets to prevent memory leaks
func (rl *RateLimiter) cleanup() <span class="cov0" title="0">{
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        rl.cleanupStale()</span>
                case &lt;-rl.cleanupCh:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// cleanupStale removes buckets that haven't been used recently
func (rl *RateLimiter) cleanupStale() <span class="cov0" title="0">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        now := time.Now()
        staleThreshold := 10 * time.Minute

        for ip, bucket := range rl.buckets </span><span class="cov0" title="0">{
                bucket.mu.Lock()
                if now.Sub(bucket.lastRefill) &gt; staleThreshold </span><span class="cov0" title="0">{
                        delete(rl.buckets, ip)
                }</span>
                <span class="cov0" title="0">bucket.mu.Unlock()</span>
        }
}

// Stop stops the rate limiter and cleanup goroutine
func (rl *RateLimiter) Stop() <span class="cov0" title="0">{
        close(rl.cleanupCh)
}</span>

// min returns the minimum of two integers
func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package middleware

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "reflect"
        "strings"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// ValidationConfig holds validation configuration
type ValidationConfig struct {
        MaxBodySize   int64    // Maximum request body size in bytes
        RequiredPaths []string // Paths that require validation
        Enabled       bool
}

// Validator provides request validation middleware
type Validator struct {
        config *ValidationConfig
        logger *observability.Logger
}

// NewValidator creates a new validation middleware
func NewValidator(config *ValidationConfig, logger *observability.Logger) *Validator <span class="cov0" title="0">{
        return &amp;Validator{
                config: config,
                logger: logger,
        }
}</span>

// Middleware returns the validation middleware
func (v *Validator) Middleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if !v.config.Enabled </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Check if this path requires validation
                <span class="cov0" title="0">if !v.shouldValidate(r.URL.Path, r.Method) </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Validate content type for POST/PUT requests
                <span class="cov0" title="0">if r.Method == "POST" || r.Method == "PUT" || r.Method == "PATCH" </span><span class="cov0" title="0">{
                        if err := v.validateContentType(r); err != nil </span><span class="cov0" title="0">{
                                v.logger.WithComponent("validator").Warn("Invalid content type",
                                        "error", err,
                                        "path", r.URL.Path,
                                        "method", r.Method,
                                        "content_type", r.Header.Get("Content-Type"))

                                http.Error(w, fmt.Sprintf("Invalid content type: %v", err), http.StatusBadRequest)
                                return
                        }</span>

                        // Validate request body size
                        <span class="cov0" title="0">if err := v.validateBodySize(r); err != nil </span><span class="cov0" title="0">{
                                v.logger.WithComponent("validator").Warn("Request body too large",
                                        "error", err,
                                        "path", r.URL.Path,
                                        "method", r.Method)

                                http.Error(w, fmt.Sprintf("Request body too large: %v", err), http.StatusRequestEntityTooLarge)
                                return
                        }</span>

                        // Validate JSON structure
                        <span class="cov0" title="0">if err := v.validateJSON(r); err != nil </span><span class="cov0" title="0">{
                                v.logger.WithComponent("validator").Warn("Invalid JSON",
                                        "error", err,
                                        "path", r.URL.Path,
                                        "method", r.Method)

                                http.Error(w, fmt.Sprintf("Invalid JSON: %v", err), http.StatusBadRequest)
                                return
                        }</span>
                }

                // Validate query parameters
                <span class="cov0" title="0">if err := v.validateQueryParams(r); err != nil </span><span class="cov0" title="0">{
                        v.logger.WithComponent("validator").Warn("Invalid query parameters",
                                "error", err,
                                "path", r.URL.Path,
                                "method", r.Method)

                        http.Error(w, fmt.Sprintf("Invalid query parameters: %v", err), http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// shouldValidate determines if a request should be validated
func (v *Validator) shouldValidate(path, method string) bool <span class="cov0" title="0">{
        // Always validate API endpoints
        if strings.HasPrefix(path, "/v1/") </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check specific paths
        <span class="cov0" title="0">for _, reqPath := range v.config.RequiredPaths </span><span class="cov0" title="0">{
                if strings.HasPrefix(path, reqPath) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// validateContentType checks if the content type is valid for the request
func (v *Validator) validateContentType(r *http.Request) error <span class="cov0" title="0">{
        contentType := r.Header.Get("Content-Type")
        if contentType == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("missing Content-Type header")
        }</span>

        // Extract the media type (ignore charset and other parameters)
        <span class="cov0" title="0">mediaType := strings.Split(contentType, ";")[0]
        mediaType = strings.TrimSpace(mediaType)

        switch mediaType </span>{
        case "application/json":<span class="cov0" title="0">
                return nil</span>
        case "application/x-www-form-urlencoded":<span class="cov0" title="0">
                return nil</span>
        case "multipart/form-data":<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported content type: %s", mediaType)</span>
        }
}

// validateBodySize checks if the request body size is within limits
func (v *Validator) validateBodySize(r *http.Request) error <span class="cov0" title="0">{
        if r.ContentLength &gt; v.config.MaxBodySize </span><span class="cov0" title="0">{
                return fmt.Errorf("request body size %d exceeds maximum %d bytes",
                        r.ContentLength, v.config.MaxBodySize)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateJSON validates that the request body contains valid JSON
func (v *Validator) validateJSON(r *http.Request) error <span class="cov0" title="0">{
        contentType := r.Header.Get("Content-Type")
        if !strings.Contains(contentType, "application/json") </span><span class="cov0" title="0">{
                return nil // Skip JSON validation for non-JSON requests
        }</span>

        // Read the body
        <span class="cov0" title="0">body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read request body: %w", err)
        }</span>

        // Restore the body for subsequent handlers
        <span class="cov0" title="0">r.Body = io.NopCloser(bytes.NewBuffer(body))

        // Skip validation for empty bodies
        if len(body) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Validate JSON structure
        <span class="cov0" title="0">var jsonData interface{}
        if err := json.Unmarshal(body, &amp;jsonData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid JSON structure: %w", err)
        }</span>

        // Basic structure validation
        <span class="cov0" title="0">if err := v.validateJSONStructure(jsonData, r.URL.Path); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateJSONStructure performs basic validation on JSON structure
func (v *Validator) validateJSONStructure(data interface{}, path string) error <span class="cov0" title="0">{
        switch value := data.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                return v.validateJSONObject(value, path)</span>
        case []interface{}:<span class="cov0" title="0">
                return v.validateJSONArray(value, path)</span>
        default:<span class="cov0" title="0">
                // Primitive types are generally acceptable
                return nil</span>
        }
}

// validateJSONObject validates JSON objects
func (v *Validator) validateJSONObject(obj map[string]interface{}, path string) error <span class="cov0" title="0">{
        // Check for excessively nested objects
        if err := v.checkNestingDepth(obj, 0, 10); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Path-specific validations
        <span class="cov0" title="0">switch </span>{
        case strings.Contains(path, "/classify"):<span class="cov0" title="0">
                return v.validateClassificationRequest(obj)</span>
        case strings.Contains(path, "/auth/register"):<span class="cov0" title="0">
                return v.validateRegistrationRequest(obj)</span>
        case strings.Contains(path, "/auth/login"):<span class="cov0" title="0">
                return v.validateLoginRequest(obj)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// validateJSONArray validates JSON arrays
func (v *Validator) validateJSONArray(arr []interface{}, path string) error <span class="cov0" title="0">{
        // Limit array size to prevent DoS attacks
        if len(arr) &gt; 1000 </span><span class="cov0" title="0">{
                return fmt.Errorf("array too large: %d items (max 1000)", len(arr))
        }</span>

        // Validate each item in the array
        <span class="cov0" title="0">for i, item := range arr </span><span class="cov0" title="0">{
                if err := v.validateJSONStructure(item, path); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid item at index %d: %w", i, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// checkNestingDepth prevents deeply nested objects that could cause stack overflow
func (v *Validator) checkNestingDepth(obj map[string]interface{}, currentDepth, maxDepth int) error <span class="cov0" title="0">{
        if currentDepth &gt; maxDepth </span><span class="cov0" title="0">{
                return fmt.Errorf("object nesting too deep: %d levels (max %d)", currentDepth, maxDepth)
        }</span>

        <span class="cov0" title="0">for _, value := range obj </span><span class="cov0" title="0">{
                if nestedObj, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if err := v.checkNestingDepth(nestedObj, currentDepth+1, maxDepth); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// validateClassificationRequest validates business classification requests
func (v *Validator) validateClassificationRequest(obj map[string]interface{}) error <span class="cov0" title="0">{
        // Check required fields
        businessName, hasName := obj["business_name"]
        if !hasName || businessName == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("missing required field: business_name")
        }</span>

        // Validate business_name is a non-empty string
        <span class="cov0" title="0">if name, ok := businessName.(string); !ok || strings.TrimSpace(name) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("business_name must be a non-empty string")
        }</span>

        // Validate optional fields if present
        <span class="cov0" title="0">if businessType, exists := obj["business_type"]; exists &amp;&amp; businessType != nil </span><span class="cov0" title="0">{
                if _, ok := businessType.(string); !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("business_type must be a string")
                }</span>
        }

        <span class="cov0" title="0">if industry, exists := obj["industry"]; exists &amp;&amp; industry != nil </span><span class="cov0" title="0">{
                if _, ok := industry.(string); !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("industry must be a string")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateRegistrationRequest validates user registration requests
func (v *Validator) validateRegistrationRequest(obj map[string]interface{}) error <span class="cov0" title="0">{
        requiredFields := []string{"username", "email", "password"}

        for _, field := range requiredFields </span><span class="cov0" title="0">{
                value, exists := obj[field]
                if !exists || value == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing required field: %s", field)
                }</span>

                <span class="cov0" title="0">if str, ok := value.(string); !ok || strings.TrimSpace(str) == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s must be a non-empty string", field)
                }</span>
        }

        // Additional email validation
        <span class="cov0" title="0">if email, ok := obj["email"].(string); ok </span><span class="cov0" title="0">{
                if !strings.Contains(email, "@") || !strings.Contains(email, ".") </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid email format")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateLoginRequest validates user login requests
func (v *Validator) validateLoginRequest(obj map[string]interface{}) error <span class="cov0" title="0">{
        requiredFields := []string{"email", "password"}

        for _, field := range requiredFields </span><span class="cov0" title="0">{
                value, exists := obj[field]
                if !exists || value == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing required field: %s", field)
                }</span>

                <span class="cov0" title="0">if str, ok := value.(string); !ok || strings.TrimSpace(str) == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s must be a non-empty string", field)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateQueryParams validates query parameters
func (v *Validator) validateQueryParams(r *http.Request) error <span class="cov0" title="0">{
        queryParams := r.URL.Query()

        // Check for suspicious patterns
        for key, values := range queryParams </span><span class="cov0" title="0">{
                for _, value := range values </span><span class="cov0" title="0">{
                        // Check for excessively long parameters
                        if len(value) &gt; 1000 </span><span class="cov0" title="0">{
                                return fmt.Errorf("query parameter '%s' too long: %d characters (max 1000)", key, len(value))
                        }</span>

                        // Check for suspicious characters that might indicate injection attempts
                        <span class="cov0" title="0">if strings.ContainsAny(value, "&lt;&gt;\"'&amp;") </span><span class="cov0" title="0">{
                                v.logger.WithComponent("validator").Info("Suspicious query parameter detected",
                                        "key", key,
                                        "value", value,
                                        "path", r.URL.Path)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidateStruct validates a struct using reflection (utility function)
func (v *Validator) ValidateStruct(s interface{}) error <span class="cov0" title="0">{
        val := reflect.ValueOf(s)
        typ := reflect.TypeOf(s)

        // Handle pointers
        if val.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                val = val.Elem()
                typ = typ.Elem()
        }</span>

        <span class="cov0" title="0">if val.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return fmt.Errorf("expected struct, got %s", val.Kind())
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; val.NumField(); i++ </span><span class="cov0" title="0">{
                field := val.Field(i)
                fieldType := typ.Field(i)

                // Check for required tag
                if tag := fieldType.Tag.Get("validate"); tag == "required" </span><span class="cov0" title="0">{
                        if v.isZeroValue(field) </span><span class="cov0" title="0">{
                                return fmt.Errorf("required field '%s' is missing or empty", fieldType.Name)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// isZeroValue checks if a reflect.Value is the zero value for its type
func (v *Validator) isZeroValue(val reflect.Value) bool <span class="cov0" title="0">{
        switch val.Kind() </span>{
        case reflect.String:<span class="cov0" title="0">
                return val.String() == ""</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                return val.Int() == 0</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return val.Uint() == 0</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return val.Float() == 0</span>
        case reflect.Bool:<span class="cov0" title="0">
                return !val.Bool()</span>
        case reflect.Ptr, reflect.Interface, reflect.Slice, reflect.Map, reflect.Chan, reflect.Func:<span class="cov0" title="0">
                return val.IsNil()</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package classification

import (
        "encoding/csv"
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

// IndustryCodeData holds all the industry code mappings
type IndustryCodeData struct {
        NAICS map[string]string // NAICS code -&gt; title
        MCC   map[string]string // MCC code -&gt; description
        SIC   map[string]string // SIC code -&gt; description
}

// LoadIndustryCodes loads all industry code data from CSV files
func LoadIndustryCodes(dataPath string) (*IndustryCodeData, error) <span class="cov8" title="1">{
        data := &amp;IndustryCodeData{
                NAICS: make(map[string]string),
                MCC:   make(map[string]string),
                SIC:   make(map[string]string),
        }

        // Load NAICS codes
        if err := loadNAICSCodes(dataPath, data); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to load NAICS codes: %w", err)
        }</span>

        // Load MCC codes
        <span class="cov8" title="1">if err := loadMCCCodes(dataPath, data); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load MCC codes: %w", err)
        }</span>

        // Load SIC codes
        <span class="cov8" title="1">if err := loadSICCodes(dataPath, data); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load SIC codes: %w", err)
        }</span>

        <span class="cov8" title="1">return data, nil</span>
}

// loadNAICSCodes loads NAICS codes from CSV file
func loadNAICSCodes(dataPath string, data *IndustryCodeData) error <span class="cov8" title="1">{
        filePath := filepath.Join(dataPath, "NAICS-2022-Codes_industries.csv")
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to open NAICS file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        reader := csv.NewReader(file)
        records, err := reader.ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read NAICS CSV: %w", err)
        }</span>

        // Skip header and empty rows
        <span class="cov8" title="1">for i, record := range records </span><span class="cov8" title="1">{
                if i == 0 || len(record) &lt; 2 || record[0] == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">code := strings.TrimSpace(record[0])
                title := strings.TrimSpace(record[1])

                if code != "" &amp;&amp; title != "" </span><span class="cov8" title="1">{
                        data.NAICS[code] = title
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// loadMCCCodes loads MCC codes from CSV file
func loadMCCCodes(dataPath string, data *IndustryCodeData) error <span class="cov8" title="1">{
        filePath := filepath.Join(dataPath, "mcc_codes.csv")
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open MCC file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        reader := csv.NewReader(file)
        records, err := reader.ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read MCC CSV: %w", err)
        }</span>

        // Skip header
        <span class="cov8" title="1">for i, record := range records </span><span class="cov8" title="1">{
                if i == 0 || len(record) &lt; 2 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">code := strings.TrimSpace(record[0])
                description := strings.TrimSpace(record[1])

                if code != "" &amp;&amp; description != "" </span><span class="cov8" title="1">{
                        data.MCC[code] = description
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// loadSICCodes loads SIC codes from CSV file
func loadSICCodes(dataPath string, data *IndustryCodeData) error <span class="cov8" title="1">{
        filePath := filepath.Join(dataPath, "sic-codes.csv")
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open SIC file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        reader := csv.NewReader(file)
        records, err := reader.ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read SIC CSV: %w", err)
        }</span>

        // Skip header
        <span class="cov8" title="1">for i, record := range records </span><span class="cov8" title="1">{
                if i == 0 || len(record) &lt; 5 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">division := strings.TrimSpace(record[0])
                majorGroup := strings.TrimSpace(record[1])
                industryGroup := strings.TrimSpace(record[2])
                sicCode := strings.TrimSpace(record[3])
                description := strings.TrimSpace(record[4])

                if sicCode != "" &amp;&amp; description != "" </span><span class="cov8" title="1">{
                        // Create a composite key for better organization
                        key := fmt.Sprintf("%s-%s-%s-%s", division, majorGroup, industryGroup, sicCode)
                        data.SIC[key] = description
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetNAICSName returns the NAICS title for a given code
func (d *IndustryCodeData) GetNAICSName(code string) string <span class="cov8" title="1">{
        if name, exists := d.NAICS[code]; exists </span><span class="cov8" title="1">{
                return name
        }</span>
        <span class="cov8" title="1">return "Unknown NAICS Industry"</span>
}

// GetMCCDescription returns the MCC description for a given code
func (d *IndustryCodeData) GetMCCDescription(code string) string <span class="cov8" title="1">{
        if description, exists := d.MCC[code]; exists </span><span class="cov8" title="1">{
                return description
        }</span>
        <span class="cov8" title="1">return "Unknown MCC Industry"</span>
}

// GetSICDescription returns the SIC description for a given code
func (d *IndustryCodeData) GetSICDescription(code string) string <span class="cov8" title="1">{
        if description, exists := d.SIC[code]; exists </span><span class="cov8" title="1">{
                return description
        }</span>
        <span class="cov8" title="1">return "Unknown SIC Industry"</span>
}

// SearchNAICSByKeyword searches NAICS codes by keyword in title
func (d *IndustryCodeData) SearchNAICSByKeyword(keyword string) []string <span class="cov8" title="1">{
        var results []string
        keyword = strings.ToLower(keyword)

        for code, title := range d.NAICS </span><span class="cov8" title="1">{
                if strings.Contains(strings.ToLower(title), keyword) </span><span class="cov8" title="1">{
                        results = append(results, code)
                }</span>
        }

        <span class="cov8" title="1">return results</span>
}

// SearchNAICSByFuzzy returns NAICS codes whose titles are similar to the query above the threshold
// threshold in [0,1]; typical values: 0.72-0.85
func (d *IndustryCodeData) SearchNAICSByFuzzy(query string, threshold float64) []string <span class="cov8" title="1">{
        var results []string
        if query == "" </span><span class="cov0" title="0">{
                return results
        }</span>
        <span class="cov8" title="1">for code, title := range d.NAICS </span><span class="cov8" title="1">{
                if tokenMaxSimilarity(query, title) &gt;= threshold </span><span class="cov8" title="1">{
                        results = append(results, code)
                }</span>
        }
        <span class="cov8" title="1">return results</span>
}

// SearchMCCByKeyword searches MCC codes by keyword in description
func (d *IndustryCodeData) SearchMCCByKeyword(keyword string) []string <span class="cov8" title="1">{
        var results []string
        keyword = strings.ToLower(keyword)

        for code, description := range d.MCC </span><span class="cov8" title="1">{
                if strings.Contains(strings.ToLower(description), keyword) </span><span class="cov8" title="1">{
                        results = append(results, code)
                }</span>
        }

        <span class="cov8" title="1">return results</span>
}

// SearchMCCByFuzzy returns MCC codes whose descriptions are similar to the query above the threshold
func (d *IndustryCodeData) SearchMCCByFuzzy(query string, threshold float64) []string <span class="cov8" title="1">{
        var results []string
        if query == "" </span><span class="cov0" title="0">{
                return results
        }</span>
        <span class="cov8" title="1">for code, desc := range d.MCC </span><span class="cov8" title="1">{
                if tokenMaxSimilarity(query, desc) &gt;= threshold </span><span class="cov0" title="0">{
                        results = append(results, code)
                }</span>
        }
        <span class="cov8" title="1">return results</span>
}

// SearchSICByKeyword searches SIC codes by keyword in description
func (d *IndustryCodeData) SearchSICByKeyword(keyword string) []string <span class="cov8" title="1">{
        var results []string
        keyword = strings.ToLower(keyword)

        for code, description := range d.SIC </span><span class="cov8" title="1">{
                if strings.Contains(strings.ToLower(description), keyword) </span><span class="cov8" title="1">{
                        results = append(results, code)
                }</span>
        }

        <span class="cov8" title="1">return results</span>
}

// SearchSICByFuzzy returns SIC codes whose descriptions are similar to the query above the threshold
func (d *IndustryCodeData) SearchSICByFuzzy(query string, threshold float64) []string <span class="cov8" title="1">{
        var results []string
        if query == "" </span><span class="cov0" title="0">{
                return results
        }</span>
        <span class="cov8" title="1">for code, desc := range d.SIC </span><span class="cov8" title="1">{
                if tokenMaxSimilarity(query, desc) &gt;= threshold </span><span class="cov8" title="1">{
                        results = append(results, code)
                }</span>
        }
        <span class="cov8" title="1">return results</span>
}

// GetNAICSCount returns the total number of NAICS codes loaded
func (d *IndustryCodeData) GetNAICSCount() int <span class="cov8" title="1">{
        return len(d.NAICS)
}</span>

// GetMCCCount returns the total number of MCC codes loaded
func (d *IndustryCodeData) GetMCCCount() int <span class="cov8" title="1">{
        return len(d.MCC)
}</span>

// GetSICCount returns the total number of SIC codes loaded
func (d *IndustryCodeData) GetSICCount() int <span class="cov8" title="1">{
        return len(d.SIC)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package classification

import (
        "math"
        "strings"
)

// levenshteinDistance computes the Levenshtein edit distance between two strings
func levenshteinDistance(a, b string) int <span class="cov8" title="1">{
        la := len(a)
        lb := len(b)
        if la == 0 </span><span class="cov0" title="0">{
                return lb
        }</span>
        <span class="cov8" title="1">if lb == 0 </span><span class="cov0" title="0">{
                return la
        }</span>

        // Initialize two rolling rows to reduce memory
        <span class="cov8" title="1">prev := make([]int, lb+1)
        curr := make([]int, lb+1)
        for j := 0; j &lt;= lb; j++ </span><span class="cov8" title="1">{
                prev[j] = j
        }</span>

        <span class="cov8" title="1">for i := 1; i &lt;= la; i++ </span><span class="cov8" title="1">{
                curr[0] = i
                ai := a[i-1]
                for j := 1; j &lt;= lb; j++ </span><span class="cov8" title="1">{
                        cost := 0
                        if ai != b[j-1] </span><span class="cov8" title="1">{
                                cost = 1
                        }</span>
                        <span class="cov8" title="1">deletion := prev[j] + 1
                        insertion := curr[j-1] + 1
                        substitution := prev[j-1] + cost
                        curr[j] = minInt(deletion, insertion, substitution)</span>
                }
                <span class="cov8" title="1">prev, curr = curr, prev</span>
        }
        <span class="cov8" title="1">return prev[lb]</span>
}

func minInt(a, b, c int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                if a &lt; c </span><span class="cov8" title="1">{
                        return a
                }</span>
                <span class="cov8" title="1">return c</span>
        }
        <span class="cov8" title="1">if b &lt; c </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">return c</span>
}

// similarity computes a normalized similarity score in [0,1] based on Levenshtein distance
// 1.0 means identical, 0.0 means completely different. Empty strings return 0 unless both empty.
func similarity(a, b string) float64 <span class="cov8" title="1">{
        if a == "" &amp;&amp; b == "" </span><span class="cov0" title="0">{
                return 1.0
        }</span>
        <span class="cov8" title="1">if a == "" || b == "" </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        // Normalize both inputs using our normalization pipeline
        <span class="cov8" title="1">na := normalizeText(a)
        nb := normalizeText(b)
        if na == "" &amp;&amp; nb == "" </span><span class="cov0" title="0">{
                return 1.0
        }</span>
        <span class="cov8" title="1">if na == "" || nb == "" </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov8" title="1">dist := float64(levenshteinDistance(na, nb))
        denom := float64(maxInt(len(na), len(nb)))
        if denom == 0 </span><span class="cov0" title="0">{
                return 1.0
        }</span>
        <span class="cov8" title="1">return 1.0 - (dist / denom)</span>
}

func maxInt(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

// tokenMaxSimilarity returns the maximum similarity between the query and any token of text
func tokenMaxSimilarity(query, text string) float64 <span class="cov8" title="1">{
        nq := normalizeText(query)
        nt := normalizeText(text)
        if nq == "" || nt == "" </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov8" title="1">maxScore := 0.0
        for _, tok := range strings.Fields(nt) </span><span class="cov8" title="1">{
                if len(tok) &lt; 3 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">s := similarity(nq, tok)
                if s &gt; maxScore </span><span class="cov8" title="1">{
                        maxScore = s
                }</span>
                <span class="cov8" title="1">if maxScore &gt;= 0.999 </span><span class="cov8" title="1">{
                        // Early exit for exact match
                        break</span>
                }
        }
        // Also compare against full text to capture multi-word closeness
        <span class="cov8" title="1">maxScore = math.Max(maxScore, similarity(nq, nt))
        return maxScore</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package classification

import (
        "sort"
)

// mapIndustryTextToNAICS returns NAICS codes most relevant to a free-text industry label
func mapIndustryTextToNAICS(industryText string, data *IndustryCodeData) []string <span class="cov0" title="0">{
        if data == nil || industryText == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Combine keyword and fuzzy approaches
        <span class="cov0" title="0">seen := make(map[string]struct{})
        var results []string

        for _, c := range data.SearchNAICSByKeyword(industryText) </span><span class="cov0" title="0">{
                if _, ok := seen[c]; ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">seen[c] = struct{}{}
                results = append(results, c)</span>
        }
        <span class="cov0" title="0">for _, c := range data.SearchNAICSByFuzzy(industryText, 0.82) </span><span class="cov0" title="0">{
                if _, ok := seen[c]; ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">seen[c] = struct{}{}
                results = append(results, c)</span>
        }
        <span class="cov0" title="0">return results</span>
}

type scoredCode struct {
        code  string
        score float64
}

// crosswalkFromNAICS finds related MCC and SIC codes for a given NAICS by text similarity
func crosswalkFromNAICS(naicsCode string, data *IndustryCodeData) (mcc []string, sic []string) <span class="cov8" title="1">{
        if data == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">title := data.GetNAICSName(naicsCode)
        if title == "" || title == "Unknown NAICS Industry" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Score all MCC/SIC descriptions against NAICS title and keep best matches
        <span class="cov8" title="1">var mccScored []scoredCode
        for code, desc := range data.MCC </span><span class="cov0" title="0">{
                // Use bidirectional comparison and token overlap to account for asymmetry
                s := bidirectionalSimilarity(title, desc)
                if s &lt; 0.55 </span><span class="cov0" title="0">{
                        // Fallback: token overlap heuristic
                        if overlap := tokenOverlapCount(title, desc); overlap &gt;= 1 </span><span class="cov0" title="0">{
                                s = 0.6 + 0.05*float64(overlap) // boost score modestly with overlap
                        }</span>
                }
                <span class="cov0" title="0">if s &gt;= 0.55 </span><span class="cov0" title="0">{
                        mccScored = append(mccScored, scoredCode{code: code, score: s})
                }</span>
        }
        <span class="cov8" title="1">sort.Slice(mccScored, func(i, j int) bool </span><span class="cov0" title="0">{ return mccScored[i].score &gt; mccScored[j].score }</span>)
        // take top 3
        <span class="cov8" title="1">for i := 0; i &lt; len(mccScored) &amp;&amp; i &lt; 3; i++ </span><span class="cov0" title="0">{
                mcc = append(mcc, mccScored[i].code)
        }</span>

        <span class="cov8" title="1">var sicScored []scoredCode
        for code, desc := range data.SIC </span><span class="cov0" title="0">{
                s := bidirectionalSimilarity(title, desc)
                if s &lt; 0.55 </span><span class="cov0" title="0">{
                        if overlap := tokenOverlapCount(title, desc); overlap &gt;= 1 </span><span class="cov0" title="0">{
                                s = 0.6 + 0.05*float64(overlap)
                        }</span>
                }
                <span class="cov0" title="0">if s &gt;= 0.55 </span><span class="cov0" title="0">{
                        sicScored = append(sicScored, scoredCode{code: code, score: s})
                }</span>
        }
        <span class="cov8" title="1">sort.Slice(sicScored, func(i, j int) bool </span><span class="cov0" title="0">{ return sicScored[i].score &gt; sicScored[j].score }</span>)
        <span class="cov8" title="1">for i := 0; i &lt; len(sicScored) &amp;&amp; i &lt; 3; i++ </span><span class="cov0" title="0">{
                sic = append(sic, sicScored[i].code)
        }</span>

        <span class="cov8" title="1">return mcc, sic</span>
}

// bidirectionalSimilarity takes the max similarity in both directions to mitigate length asymmetry
func bidirectionalSimilarity(a, b string) float64 <span class="cov0" title="0">{
        sa := tokenMaxSimilarity(a, b)
        sb := tokenMaxSimilarity(b, a)
        if sa &gt; sb </span><span class="cov0" title="0">{
                return sa
        }</span>
        <span class="cov0" title="0">return sb</span>
}

// tokenOverlapCount counts overlapping informative tokens between two strings
func tokenOverlapCount(a, b string) int <span class="cov0" title="0">{
        na := normalizeText(a)
        nb := normalizeText(b)
        ta := tokenize(na)
        tb := tokenize(nb)
        if len(ta) == 0 || len(tb) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">set := make(map[string]struct{}, len(ta))
        for _, t := range ta </span><span class="cov0" title="0">{
                set[t] = struct{}{}
        }</span>
        <span class="cov0" title="0">count := 0
        for _, t := range tb </span><span class="cov0" title="0">{
                if _, ok := set[t]; ok </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package classification

import (
        "regexp"
        "strings"
        "unicode"
)

// stopwords is a minimal English stopword set for normalization
var stopwords = map[string]struct{}{
        "the": {}, "and": {}, "of": {}, "for": {}, "to": {}, "in": {}, "a": {}, "an": {},
        "co": {}, "company": {}, "inc": {}, "llc": {}, "corp": {}, "corporation": {}, "ltd": {},
        "services": {}, "solutions": {}, "group": {}, "international": {}, "global": {},
}

var spaceCollapse = regexp.MustCompile(`\s+`)

// normalizeText lowercases, removes punctuation, collapses whitespace
func normalizeText(s string) string <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return s
        }</span>
        // Lowercase and remove punctuation
        <span class="cov8" title="1">b := strings.Builder{}
        b.Grow(len(s))
        for _, r := range s </span><span class="cov8" title="1">{
                if unicode.IsLetter(r) || unicode.IsDigit(r) || unicode.IsSpace(r) </span><span class="cov8" title="1">{
                        b.WriteRune(unicode.ToLower(r))
                }</span> else<span class="cov8" title="1"> {
                        // replace punctuation with space to keep token boundaries
                        b.WriteRune(' ')
                }</span>
        }
        <span class="cov8" title="1">out := spaceCollapse.ReplaceAllString(b.String(), " ")
        return strings.TrimSpace(out)</span>
}

// tokenize splits normalized text and removes simple stopwords
func tokenize(normalized string) []string <span class="cov8" title="1">{
        if normalized == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">parts := strings.Fields(normalized)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">tokens := make([]string, 0, len(parts))
        seen := make(map[string]struct{}, len(parts))
        for _, p := range parts </span><span class="cov8" title="1">{
                if _, skip := stopwords[p]; skip </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, exists := seen[p]; exists </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">seen[p] = struct{}{}
                tokens = append(tokens, p)</span>
        }
        <span class="cov8" title="1">return tokens</span>
}

// normalizeBusinessFields returns normalized free-text and tokens for request fields
func normalizeBusinessFields(name, description, keywords string) (normalized string, tokens []string) <span class="cov8" title="1">{
        n := normalizeText(name)
        d := normalizeText(description)
        k := normalizeText(keywords)
        joined := strings.TrimSpace(strings.Join([]string{n, d, k}, " "))
        return joined, tokenize(joined)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package classification

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/pcraw4d/business-verification/internal/config"
        "github.com/pcraw4d/business-verification/internal/database"
        "github.com/pcraw4d/business-verification/internal/datasource"
        "github.com/pcraw4d/business-verification/internal/observability"
        "github.com/pcraw4d/business-verification/pkg/validators"
)

// ClassificationService provides business classification functionality
type ClassificationService struct {
        config       *config.ExternalServicesConfig
        db           database.Database
        logger       *observability.Logger
        metrics      *observability.Metrics
        industryData *IndustryCodeData

        // in-memory cache
        cacheEnabled bool
        cacheTTL     time.Duration
        cacheMax     int
        cacheMu      sync.RWMutex
        cache        map[string]cacheEntry
        janitorStop  chan struct{}

        // enrichment
        enricher *datasource.Aggregator
}

// NewClassificationService creates a new business classification service
func NewClassificationService(cfg *config.ExternalServicesConfig, db database.Database, logger *observability.Logger, metrics *observability.Metrics) *ClassificationService <span class="cov8" title="1">{
        s := &amp;ClassificationService{
                config:       cfg,
                db:           db,
                logger:       logger,
                metrics:      metrics,
                industryData: nil, // Will be loaded separately
        }
        s.initCache()
        s.initEnrichment(db)
        return s
}</span>

// NewClassificationServiceWithData creates a new business classification service with industry data
func NewClassificationServiceWithData(cfg *config.ExternalServicesConfig, db database.Database, logger *observability.Logger, metrics *observability.Metrics, industryData *IndustryCodeData) *ClassificationService <span class="cov8" title="1">{
        s := &amp;ClassificationService{
                config:       cfg,
                db:           db,
                logger:       logger,
                metrics:      metrics,
                industryData: industryData,
        }
        s.initCache()
        s.initEnrichment(db)
        return s
}</span>

type cacheEntry struct {
        classifications []IndustryClassification
        expiresAt       time.Time
}

func (c *ClassificationService) initCache() <span class="cov8" title="1">{
        // defaults
        enabled := true
        ttl := 10 * time.Minute
        maxEntries := 10000
        janitorInterval := time.Minute
        if c.config != nil </span><span class="cov8" title="1">{
                enabled = c.config.ClassificationCache.Enabled
                if c.config.ClassificationCache.TTL &gt; 0 </span><span class="cov8" title="1">{
                        ttl = c.config.ClassificationCache.TTL
                }</span>
                <span class="cov8" title="1">if c.config.ClassificationCache.MaxEntries &gt; 0 </span><span class="cov8" title="1">{
                        maxEntries = c.config.ClassificationCache.MaxEntries
                }</span>
                <span class="cov8" title="1">if c.config.ClassificationCache.JanitorInterval &gt; 0 </span><span class="cov0" title="0">{
                        janitorInterval = c.config.ClassificationCache.JanitorInterval
                }</span>
        }

        <span class="cov8" title="1">c.cacheEnabled = enabled
        if !c.cacheEnabled </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">c.cacheTTL = ttl
        c.cacheMax = maxEntries
        c.cache = make(map[string]cacheEntry, 1024)
        c.janitorStop = make(chan struct{})

        // start janitor
        go func() </span><span class="cov8" title="1">{
                ticker := time.NewTicker(janitorInterval)
                defer ticker.Stop()
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                c.evictExpired()</span>
                        case &lt;-c.janitorStop:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
}

func (c *ClassificationService) evictExpired() <span class="cov0" title="0">{
        if !c.cacheEnabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">now := time.Now()
        c.cacheMu.Lock()
        for k, v := range c.cache </span><span class="cov0" title="0">{
                if now.After(v.expiresAt) </span><span class="cov0" title="0">{
                        delete(c.cache, k)
                }</span>
        }
        <span class="cov0" title="0">c.cacheMu.Unlock()</span>
}

func (c *ClassificationService) getFromCache(key string) (classifications []IndustryClassification, ok bool) <span class="cov8" title="1">{
        if !c.cacheEnabled </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov8" title="1">now := time.Now()
        c.cacheMu.RLock()
        ce, exists := c.cache[key]
        c.cacheMu.RUnlock()
        if !exists || now.After(ce.expiresAt) </span><span class="cov8" title="1">{
                return nil, false
        }</span>
        <span class="cov8" title="1">return ce.classifications, true</span>
}

func (c *ClassificationService) setCache(key string, classifications []IndustryClassification) <span class="cov8" title="1">{
        if !c.cacheEnabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">c.cacheMu.Lock()
        // Simple cap: if over max, evict random/oldest by iterating until size below threshold
        if len(c.cache) &gt;= c.cacheMax </span><span class="cov0" title="0">{
                // opportunistic eviction of expired first
                now := time.Now()
                for k, v := range c.cache </span><span class="cov0" title="0">{
                        if now.After(v.expiresAt) </span><span class="cov0" title="0">{
                                delete(c.cache, k)
                        }</span>
                        <span class="cov0" title="0">if len(c.cache) &lt; c.cacheMax </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                // if still full, delete arbitrary entries until under cap
                <span class="cov0" title="0">for k := range c.cache </span><span class="cov0" title="0">{
                        if len(c.cache) &lt; c.cacheMax </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">delete(c.cache, k)</span>
                }
        }
        <span class="cov8" title="1">c.cache[key] = cacheEntry{classifications: classifications, expiresAt: time.Now().Add(c.cacheTTL)}
        c.cacheMu.Unlock()</span>
}

func (c *ClassificationService) makeCacheKey(req *ClassificationRequest) string <span class="cov8" title="1">{
        // Normalize primary text fields for stable hashing
        normalized, _ := normalizeBusinessFields(req.BusinessName, req.Description, req.Keywords)
        base := strings.Join([]string{
                strings.ToLower(strings.TrimSpace(normalized)),
                strings.ToLower(strings.TrimSpace(req.BusinessType)),
                strings.ToLower(strings.TrimSpace(req.Industry)),
        }, "|")
        sum := sha256.Sum256([]byte(base))
        return hex.EncodeToString(sum[:])
}</span>

func (c *ClassificationService) initEnrichment(db database.Database) <span class="cov8" title="1">{
        if db == nil </span><span class="cov8" title="1">{
                return
        }</span>
        // For now only DB source; easily extended with external APIs later
        <span class="cov0" title="0">src := datasource.NewDBSource(db)
        aggr := datasource.NewAggregator([]datasource.DataSource{src}, 1500*time.Millisecond)
        // Install pooled HTTP client for any HTTP-capable sources (future-proof)
        if c.config != nil </span><span class="cov0" title="0">{
                hc := c.config.HTTPClient
                client := datasource.NewPooledHTTPClient(
                        hc.MaxIdleConns,
                        hc.MaxIdleConnsPerHost,
                        hc.IdleConnTimeout,
                        hc.TLSHandshakeTimeout,
                        hc.ExpectContinueTimeout,
                        hc.RequestTimeout,
                )
                aggr.SetHTTPClient(client)
        }</span>
        <span class="cov0" title="0">c.enricher = aggr</span>
}

// DataSourcesHealth proxies health checks for configured enrichment sources
func (c *ClassificationService) DataSourcesHealth(ctx context.Context) []datasource.SourceHealth <span class="cov0" title="0">{
        if c.enricher == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.enricher.CheckHealth(ctx)</span>
}

// ClassificationRequest represents a business classification request
type ClassificationRequest struct {
        BusinessName       string `json:"business_name" validate:"required"`
        BusinessType       string `json:"business_type,omitempty"`
        Industry           string `json:"industry,omitempty"`
        Description        string `json:"description,omitempty"`
        Keywords           string `json:"keywords,omitempty"`
        RegistrationNumber string `json:"registration_number,omitempty"`
        TaxID              string `json:"tax_id,omitempty"`
}

// ClassificationResponse represents a business classification response
type ClassificationResponse struct {
        BusinessID            string                   `json:"business_id"`
        Classifications       []IndustryClassification `json:"classifications"`
        PrimaryClassification *IndustryClassification  `json:"primary_classification"`
        ConfidenceScore       float64                  `json:"confidence_score"`
        ClassificationMethod  string                   `json:"classification_method"`
        ProcessingTime        time.Duration            `json:"processing_time"`
        RawData               map[string]interface{}   `json:"raw_data,omitempty"`
}

// IndustryClassification represents an industry classification result
type IndustryClassification struct {
        IndustryCode         string   `json:"industry_code"`
        IndustryName         string   `json:"industry_name"`
        ConfidenceScore      float64  `json:"confidence_score"`
        ClassificationMethod string   `json:"classification_method"`
        Keywords             []string `json:"keywords,omitempty"`
        Description          string   `json:"description,omitempty"`
}

// BatchClassificationRequest represents a batch classification request
type BatchClassificationRequest struct {
        Businesses []ClassificationRequest `json:"businesses" validate:"required,min=1,max=100"`
}

// BatchClassificationResponse represents a batch classification response
type BatchClassificationResponse struct {
        Results        []ClassificationResponse `json:"results"`
        TotalProcessed int                      `json:"total_processed"`
        SuccessCount   int                      `json:"success_count"`
        ErrorCount     int                      `json:"error_count"`
        ProcessingTime time.Duration            `json:"processing_time"`
}

// ClassifyBusiness classifies a single business
func (c *ClassificationService) ClassifyBusiness(ctx context.Context, req *ClassificationRequest) (*ClassificationResponse, error) <span class="cov8" title="1">{
        start := time.Now()

        // Log classification start
        c.logger.WithComponent("classification").LogBusinessEvent(ctx, "classification_started", "", map[string]interface{}{
                "business_name": req.BusinessName,
                "business_type": req.BusinessType,
                "industry":      req.Industry,
        })

        // Validate request
        if err := c.validateClassificationRequest(req); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid request: %w", err)
        }</span>

        // Try cache
        <span class="cov8" title="1">cacheKey := c.makeCacheKey(req)
        if cached, ok := c.getFromCache(cacheKey); ok </span><span class="cov8" title="1">{
                // Reconstruct response with fresh BusinessID and durations
                primary := c.determinePrimaryClassification(cached)
                confidence := c.calculateOverallConfidence(cached)
                businessID := c.generateBusinessID(req)
                response := &amp;ClassificationResponse{
                        BusinessID:            businessID,
                        Classifications:       cached,
                        PrimaryClassification: primary,
                        ConfidenceScore:       confidence,
                        ClassificationMethod:  "hybrid",
                        ProcessingTime:        time.Since(start),
                        RawData: map[string]interface{}{
                                "request": req,
                                "method":  "hybrid_classification_cache_hit",
                        },
                }
                // Log and metrics
                c.logger.WithComponent("classification").LogBusinessEvent(ctx, "classification_completed", businessID, map[string]interface{}{
                        "business_name":         req.BusinessName,
                        "primary_industry_code": primary.IndustryCode,
                        "primary_industry_name": primary.IndustryName,
                        "confidence_score":      confidence,
                        "processing_time_ms":    time.Since(start).Milliseconds(),
                        "total_classifications": len(cached),
                        "cache_hit":             true,
                })
                c.metrics.RecordBusinessClassification("success_cache", fmt.Sprintf("%.2f", confidence))
                return response, nil
        }</span>

        // Perform classification (cache miss)
        // Optional enrichment pre-processing
        <span class="cov8" title="1">if c.enricher != nil </span><span class="cov0" title="0">{
                enrReq := datasource.EnrichmentRequest{
                        BusinessName:       req.BusinessName,
                        RegistrationNumber: req.RegistrationNumber,
                }
                if enr, err := c.enricher.Enrich(ctx, enrReq); err == nil </span><span class="cov0" title="0">{
                        // sanitize enrichment payload
                        enr = validators.CleanEnrichmentResult(enr)
                        if enr.CleanBusinessName != "" </span><span class="cov0" title="0">{
                                req.BusinessName = enr.CleanBusinessName
                        }</span>
                        <span class="cov0" title="0">if enr.Industry != "" &amp;&amp; req.Industry == "" </span><span class="cov0" title="0">{
                                req.Industry = enr.Industry
                        }</span>
                        <span class="cov0" title="0">if enr.Description != "" &amp;&amp; req.Description == "" </span><span class="cov0" title="0">{
                                req.Description = enr.Description
                        }</span>
                        <span class="cov0" title="0">if len(enr.Keywords) &gt; 0 &amp;&amp; req.Keywords == "" </span><span class="cov0" title="0">{
                                req.Keywords = strings.Join(enr.Keywords, ",")
                        }</span>
                }
        }

        <span class="cov8" title="1">classifications, err := c.performClassification(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.WithComponent("classification").WithError(err).LogBusinessEvent(ctx, "classification_failed", "", map[string]interface{}{
                        "business_name": req.BusinessName,
                        "error":         err.Error(),
                })
                c.metrics.RecordBusinessClassification("failed", "error")
                return nil, fmt.Errorf("classification failed: %w", err)
        }</span>

        // Determine primary classification
        <span class="cov8" title="1">primaryClassification := c.determinePrimaryClassification(classifications)

        // Calculate overall confidence score
        confidenceScore := c.calculateOverallConfidence(classifications)

        // Generate business ID for tracking
        businessID := c.generateBusinessID(req)

        // Create response
        response := &amp;ClassificationResponse{
                BusinessID:            businessID,
                Classifications:       classifications,
                PrimaryClassification: primaryClassification,
                ConfidenceScore:       confidenceScore,
                ClassificationMethod:  "hybrid", // Using multiple methods
                ProcessingTime:        time.Since(start),
                RawData: map[string]interface{}{
                        "request": req,
                        "method":  "hybrid_classification",
                },
        }

        // Store classification in database if available
        if c.db != nil </span><span class="cov0" title="0">{
                if err := c.storeClassification(ctx, businessID, response); err != nil </span><span class="cov0" title="0">{
                        c.logger.WithComponent("classification").WithError(err).LogBusinessEvent(ctx, "classification_storage_failed", businessID, map[string]interface{}{
                                "error": err.Error(),
                        })
                }</span>
        }

        // Store in cache
        <span class="cov8" title="1">c.setCache(cacheKey, classifications)

        // Log successful classification
        c.logger.WithComponent("classification").LogBusinessEvent(ctx, "classification_completed", businessID, map[string]interface{}{
                "business_name":         req.BusinessName,
                "primary_industry_code": primaryClassification.IndustryCode,
                "primary_industry_name": primaryClassification.IndustryName,
                "confidence_score":      confidenceScore,
                "processing_time_ms":    time.Since(start).Milliseconds(),
                "total_classifications": len(classifications),
                "cache_hit":             false,
        })

        // Record metrics
        c.metrics.RecordBusinessClassification("success", fmt.Sprintf("%.2f", confidenceScore))
        c.metrics.RecordClassificationDuration("single", time.Since(start))
        // Simple on-host alerting for slow classifications
        if c.logger != nil &amp;&amp; c.config != nil </span><span class="cov8" title="1">{
                thr := 300 * time.Millisecond
                if c.config != nil </span>{<span class="cov8" title="1">
                        // use observability thresholds if available via logger's config is not accessible here; keep default 300ms
                }</span>
                <span class="cov8" title="1">if time.Since(start) &gt; thr </span><span class="cov0" title="0">{
                        c.logger.WithComponent("classification").Warn("slow_classification", "duration_ms", time.Since(start).Milliseconds(), "business_name", req.BusinessName)
                }</span>
        }

        <span class="cov8" title="1">return response, nil</span>
}

// ClassifyBusinessesBatch classifies multiple businesses in batch
func (c *ClassificationService) ClassifyBusinessesBatch(ctx context.Context, req *BatchClassificationRequest) (*BatchClassificationResponse, error) <span class="cov0" title="0">{
        start := time.Now()

        // Log batch classification start
        c.logger.WithComponent("classification").LogBusinessEvent(ctx, "batch_classification_started", "", map[string]interface{}{
                "total_businesses": len(req.Businesses),
        })

        // Validate batch size
        if len(req.Businesses) &gt; 100 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("batch size exceeds maximum limit of 100")
        }</span>

        // Pre-allocate output array to preserve order
        <span class="cov0" title="0">out := make([]ClassificationResponse, len(req.Businesses))
        successCount := 0
        errorCount := 0

        // Group identical requests by cache key to avoid duplicate work in the same batch
        type batchJob struct {
                key  string
                req  *ClassificationRequest
                idxs []int // all positions in the original slice that share this key
        }

        keyToJob := make(map[string]*batchJob, len(req.Businesses))
        for i := range req.Businesses </span><span class="cov0" title="0">{
                // copy to avoid aliasing the loop variable
                r := req.Businesses[i]
                key := c.makeCacheKey(&amp;r)
                if bj, ok := keyToJob[key]; ok </span><span class="cov0" title="0">{
                        bj.idxs = append(bj.idxs, i)
                        continue</span>
                }
                <span class="cov0" title="0">keyToJob[key] = &amp;batchJob{key: key, req: &amp;r, idxs: []int{i}}</span>
        }

        <span class="cov0" title="0">jobs := make([]*batchJob, 0, len(keyToJob))
        for _, j := range keyToJob </span><span class="cov0" title="0">{
                jobs = append(jobs, j)
        }</span>

        // Bounded concurrency worker pool
        <span class="cov0" title="0">workerCount := 8
        if len(jobs) &lt; workerCount </span><span class="cov0" title="0">{
                workerCount = len(jobs)
        }</span>
        <span class="cov0" title="0">if workerCount == 0 </span><span class="cov0" title="0">{
                // Nothing to process
                resp := &amp;BatchClassificationResponse{
                        Results:        out[:0],
                        TotalProcessed: 0,
                        SuccessCount:   0,
                        ErrorCount:     0,
                        ProcessingTime: time.Since(start),
                }
                c.logger.WithComponent("classification").LogBusinessEvent(ctx, "batch_classification_completed", "", map[string]interface{}{
                        "total_processed":    resp.TotalProcessed,
                        "success_count":      resp.SuccessCount,
                        "error_count":        resp.ErrorCount,
                        "processing_time_ms": resp.ProcessingTime.Milliseconds(),
                })
                return resp, nil
        }</span>

        <span class="cov0" title="0">jobsCh := make(chan *batchJob)
        var wg sync.WaitGroup
        var mu sync.Mutex // protects successCount, errorCount, and writes into out

        worker := func() </span><span class="cov0" title="0">{
                defer wg.Done()
                for j := range jobsCh </span><span class="cov0" title="0">{
                        // Respect batch context cancellation
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                mu.Lock()
                                errorCount += len(j.idxs)
                                mu.Unlock()
                                continue</span>
                        default:<span class="cov0" title="0"></span>
                        }

                        <span class="cov0" title="0">res, err := c.ClassifyBusiness(ctx, j.req)
                        mu.Lock()
                        if err != nil </span><span class="cov0" title="0">{
                                // record error for all deduped positions
                                errorCount += len(j.idxs)
                                // Log one event per job (not per duplicate index)
                                c.logger.WithComponent("classification").WithError(err).LogBusinessEvent(ctx, "batch_item_failed", "", map[string]interface{}{
                                        "business_name": j.req.BusinessName,
                                        "error":         err.Error(),
                                        "duplicates":    len(j.idxs),
                                })
                        }</span> else<span class="cov0" title="0"> {
                                for _, idx := range j.idxs </span><span class="cov0" title="0">{
                                        out[idx] = *res
                                }</span>
                                <span class="cov0" title="0">successCount += len(j.idxs)</span>
                        }
                        <span class="cov0" title="0">mu.Unlock()</span>
                }
        }

        <span class="cov0" title="0">wg.Add(workerCount)
        for w := 0; w &lt; workerCount; w++ </span><span class="cov0" title="0">{
                go worker()
        }</span>
        <span class="cov0" title="0">for _, j := range jobs </span><span class="cov0" title="0">{
                jobsCh &lt;- j
        }</span>
        <span class="cov0" title="0">close(jobsCh)
        wg.Wait()

        // Filter out zero-value entries (failed items)
        resultsFiltered := make([]ClassificationResponse, 0, len(out))
        for i := range out </span><span class="cov0" title="0">{
                if out[i].BusinessID != "" || len(out[i].Classifications) &gt; 0 </span><span class="cov0" title="0">{
                        resultsFiltered = append(resultsFiltered, out[i])
                }</span>
        }

        <span class="cov0" title="0">response := &amp;BatchClassificationResponse{
                Results:        resultsFiltered,
                TotalProcessed: len(req.Businesses),
                SuccessCount:   successCount,
                ErrorCount:     errorCount,
                ProcessingTime: time.Since(start),
        }

        // Log batch classification completion
        c.logger.WithComponent("classification").LogBusinessEvent(ctx, "batch_classification_completed", "", map[string]interface{}{
                "total_processed":    response.TotalProcessed,
                "success_count":      response.SuccessCount,
                "error_count":        response.ErrorCount,
                "processing_time_ms": response.ProcessingTime.Milliseconds(),
                "unique_jobs":        len(jobs),
                "dedup_savings":      len(req.Businesses) - len(jobs),
        })

        // Metrics and slow-alert
        c.metrics.RecordClassificationDuration("batch", time.Since(start))
        if c.logger != nil &amp;&amp; c.config != nil </span><span class="cov0" title="0">{
                thr := 300 * time.Millisecond
                if time.Since(start) &gt; thr </span><span class="cov0" title="0">{
                        c.logger.WithComponent("classification").Warn("slow_batch_classification", "duration_ms", time.Since(start).Milliseconds(), "total_businesses", len(req.Businesses))
                }</span>
        }

        <span class="cov0" title="0">return response, nil</span>
}

// GetClassificationHistory retrieves classification history for a business
func (c *ClassificationService) GetClassificationHistory(ctx context.Context, businessID string, limit, offset int) ([]*database.BusinessClassification, error) <span class="cov0" title="0">{
        if c.db == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database not available")
        }</span>

        <span class="cov0" title="0">classifications, err := c.db.GetBusinessClassificationsByBusinessID(ctx, businessID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to retrieve classification history: %w", err)
        }</span>

        // Apply pagination
        <span class="cov0" title="0">if offset &gt;= len(classifications) </span><span class="cov0" title="0">{
                return []*database.BusinessClassification{}, nil
        }</span>

        <span class="cov0" title="0">end := offset + limit
        if end &gt; len(classifications) </span><span class="cov0" title="0">{
                end = len(classifications)
        }</span>

        <span class="cov0" title="0">return classifications[offset:end], nil</span>
}

// validateClassificationRequest validates the classification request
func (c *ClassificationService) validateClassificationRequest(req *ClassificationRequest) error <span class="cov8" title="1">{
        if strings.TrimSpace(req.BusinessName) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("business name is required")
        }</span>

        <span class="cov8" title="1">if len(req.BusinessName) &gt; 500 </span><span class="cov8" title="1">{
                return fmt.Errorf("business name too long (max 500 characters)")
        }</span>

        <span class="cov8" title="1">if req.Description != "" &amp;&amp; len(req.Description) &gt; 2000 </span><span class="cov8" title="1">{
                return fmt.Errorf("description too long (max 2000 characters)")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// performClassification performs the actual classification using multiple methods
func (c *ClassificationService) performClassification(ctx context.Context, req *ClassificationRequest) ([]IndustryClassification, error) <span class="cov8" title="1">{
        var classifications []IndustryClassification

        // Method 1: Keyword-based classification
        if keywordClassifications := c.classifyByKeywords(req); len(keywordClassifications) &gt; 0 </span><span class="cov0" title="0">{
                classifications = append(classifications, keywordClassifications...)
        }</span>

        // Method 2: Business type classification
        <span class="cov8" title="1">if businessTypeClassifications := c.classifyByBusinessType(req); len(businessTypeClassifications) &gt; 0 </span><span class="cov0" title="0">{
                classifications = append(classifications, businessTypeClassifications...)
        }</span>

        // Method 3: Industry-based classification
        <span class="cov8" title="1">if industryClassifications := c.classifyByIndustry(req); len(industryClassifications) &gt; 0 </span><span class="cov0" title="0">{
                classifications = append(classifications, industryClassifications...)
        }</span>

        // Fallback A: Free-text industry mapping via NAICS dataset when simple mapping misses
        <span class="cov8" title="1">if industryTextClassifications := c.classifyByIndustryText(req); len(industryTextClassifications) &gt; 0 </span><span class="cov0" title="0">{
                classifications = append(classifications, industryTextClassifications...)
        }</span>

        // Method 4: Name-based classification
        <span class="cov8" title="1">if nameClassifications := c.classifyByName(req); len(nameClassifications) &gt; 0 </span><span class="cov8" title="1">{
                classifications = append(classifications, nameClassifications...)
        }</span>

        // Method 5: Fuzzy matching across industry datasets
        <span class="cov8" title="1">if fuzzyClassifications := c.classifyByFuzzy(req); len(fuzzyClassifications) &gt; 0 </span><span class="cov0" title="0">{
                classifications = append(classifications, fuzzyClassifications...)
        }</span>

        // Fallback B: History-based fallback using prior classifications from DB
        <span class="cov8" title="1">if historyClassifications := c.classifyByHistory(ctx, req); len(historyClassifications) &gt; 0 </span><span class="cov0" title="0">{
                classifications = append(classifications, historyClassifications...)
        }</span>

        // Expand with crosswalk mapping to surface related code systems for the primary NAICS
        <span class="cov8" title="1">if c.industryData != nil </span><span class="cov8" title="1">{
                // Determine primary classification and enrich with MCC/SIC mappings
                primary := c.determinePrimaryClassification(classifications)
                if primary != nil </span><span class="cov8" title="1">{
                        // Only crosswalk when NAICS-style code (simple heuristic: numeric code of length 6)
                        if len(primary.IndustryCode) == 6 </span><span class="cov8" title="1">{
                                mcc, sic := crosswalkFromNAICS(primary.IndustryCode, c.industryData)
                                for _, code := range mcc </span><span class="cov0" title="0">{
                                        classifications = append(classifications, IndustryClassification{
                                                IndustryCode:         code,
                                                IndustryName:         c.industryData.GetMCCDescription(code),
                                                ConfidenceScore:      primary.ConfidenceScore * 0.8,
                                                ClassificationMethod: "crosswalk_mcc_from_naics",
                                        })
                                }</span>
                                <span class="cov8" title="1">for _, code := range sic </span><span class="cov0" title="0">{
                                        classifications = append(classifications, IndustryClassification{
                                                IndustryCode:         code,
                                                IndustryName:         c.industryData.GetSICDescription(code),
                                                ConfidenceScore:      primary.ConfidenceScore * 0.75,
                                                ClassificationMethod: "crosswalk_sic_from_naics",
                                        })
                                }</span>
                        }
                }
        }

        // If no classifications found, return default
        <span class="cov8" title="1">if len(classifications) == 0 </span><span class="cov0" title="0">{
                classifications = append(classifications, c.getDefaultClassification())
        }</span>

        // Normalize and enhance confidence scores, and deduplicate by code
        <span class="cov8" title="1">classifications = c.postProcessConfidence(classifications)

        return classifications, nil</span>
}

// postProcessConfidence applies method-based weighting, agreement boosts and deduplicates by industry code.
func (c *ClassificationService) postProcessConfidence(classifications []IndustryClassification) []IndustryClassification <span class="cov8" title="1">{
        if len(classifications) == 0 </span><span class="cov0" title="0">{
                return classifications
        }</span>

        // Count occurrences per code to detect agreement
        <span class="cov8" title="1">occurrences := make(map[string]int)
        for _, cl := range classifications </span><span class="cov8" title="1">{
                occurrences[cl.IndustryCode]++
        }</span>

        // Keep best per code after weighting
        <span class="cov8" title="1">bestByCode := make(map[string]IndustryClassification)
        for _, cl := range classifications </span><span class="cov8" title="1">{
                weight := methodWeightFor(cl.ClassificationMethod)
                agreeBoost := 0.0
                if n := occurrences[cl.IndustryCode]; n &gt; 1 </span><span class="cov8" title="1">{
                        // modest boost for multi-method/multi-hit agreement (cap at 0.2)
                        agreeBoost = 0.08 * float64(n-1)
                        if agreeBoost &gt; 0.2 </span><span class="cov0" title="0">{
                                agreeBoost = 0.2
                        }</span>
                }
                <span class="cov8" title="1">score := cl.ConfidenceScore*weight + agreeBoost
                if score &gt; 0.99 </span><span class="cov0" title="0">{
                        score = 0.99
                }</span>
                <span class="cov8" title="1">cl.ConfidenceScore = score

                cur, exists := bestByCode[cl.IndustryCode]
                if !exists || cl.ConfidenceScore &gt; cur.ConfidenceScore </span><span class="cov8" title="1">{
                        bestByCode[cl.IndustryCode] = cl
                }</span>
        }

        <span class="cov8" title="1">out := make([]IndustryClassification, 0, len(bestByCode))
        for _, v := range bestByCode </span><span class="cov8" title="1">{
                out = append(out, v)
        }</span>
        <span class="cov8" title="1">return out</span>
}

// methodWeightFor returns a multiplicative weight reflecting method reliability.
func methodWeightFor(method string) float64 <span class="cov8" title="1">{
        switch method </span>{
        case "industry_based":<span class="cov0" title="0">
                return 1.15</span>
        case "business_type_based":<span class="cov0" title="0">
                return 1.10</span>
        case "keyword_based_naics":<span class="cov8" title="1">
                return 1.12</span>
        case "keyword_based":<span class="cov8" title="1">
                return 1.08</span>
        case "name_pattern_based":<span class="cov8" title="1">
                return 1.05</span>
        case "fuzzy_naics_fulltext", "fuzzy_naics_token":<span class="cov0" title="0">
                return 1.06</span>
        case "fuzzy_mcc_fulltext", "fuzzy_mcc_token":<span class="cov0" title="0">
                return 1.04</span>
        case "fuzzy_sic_fulltext", "fuzzy_sic_token":<span class="cov0" title="0">
                return 1.03</span>
        case "crosswalk_mcc_from_naics", "crosswalk_sic_from_naics":<span class="cov0" title="0">
                return 1.02</span>
        default:<span class="cov0" title="0">
                return 1.0</span>
        }
}

// classifyByKeywords classifies business based on keywords
func (c *ClassificationService) classifyByKeywords(req *ClassificationRequest) []IndustryClassification <span class="cov8" title="1">{
        var classifications []IndustryClassification

        // Normalize and combine fields for robust matching
        textToSearch, tokens := normalizeBusinessFields(req.BusinessName, req.Description, req.Keywords)

        // Use real industry data if available
        if c.industryData != nil </span><span class="cov8" title="1">{
                // Token-wise search with deduplication per code system
                naicsSeen := make(map[string]struct{})
                mccSeen := make(map[string]struct{})
                sicSeen := make(map[string]struct{})

                for _, tok := range tokens </span><span class="cov8" title="1">{
                        if len(tok) &lt; 3 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // NAICS
                        <span class="cov8" title="1">for _, code := range c.industryData.SearchNAICSByKeyword(tok) </span><span class="cov0" title="0">{
                                if _, exists := naicsSeen[code]; exists </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">naicsSeen[code] = struct{}{}
                                classifications = append(classifications, IndustryClassification{
                                        IndustryCode:         code,
                                        IndustryName:         c.industryData.GetNAICSName(code),
                                        ConfidenceScore:      0.7,
                                        ClassificationMethod: "keyword_based_naics",
                                        Keywords:             []string{tok},
                                })</span>
                        }

                        // MCC
                        <span class="cov8" title="1">for _, code := range c.industryData.SearchMCCByKeyword(tok) </span><span class="cov0" title="0">{
                                if _, exists := mccSeen[code]; exists </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">mccSeen[code] = struct{}{}
                                classifications = append(classifications, IndustryClassification{
                                        IndustryCode:         code,
                                        IndustryName:         c.industryData.GetMCCDescription(code),
                                        ConfidenceScore:      0.6,
                                        ClassificationMethod: "keyword_based_mcc",
                                        Keywords:             []string{tok},
                                })</span>
                        }

                        // SIC
                        <span class="cov8" title="1">for _, code := range c.industryData.SearchSICByKeyword(tok) </span><span class="cov0" title="0">{
                                if _, exists := sicSeen[code]; exists </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">sicSeen[code] = struct{}{}
                                classifications = append(classifications, IndustryClassification{
                                        IndustryCode:         code,
                                        IndustryName:         c.industryData.GetSICDescription(code),
                                        ConfidenceScore:      0.5,
                                        ClassificationMethod: "keyword_based_sic",
                                        Keywords:             []string{tok},
                                })</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                // Fallback to hardcoded mappings if no industry data available
                keywordMappings := map[string][]string{
                        "software":       {"541511", "541512", "541519"},
                        "technology":     {"541511", "541512", "541519", "541715"},
                        "consulting":     {"541611", "541612", "541618", "541690"},
                        "financial":      {"522110", "522120", "522130", "522190", "523150"},
                        "healthcare":     {"621111", "621112", "621210", "621310", "621320"},
                        "retail":         {"441110", "442110", "443141", "444110", "445110"},
                        "manufacturing":  {"332996", "332999", "333415", "334110", "335110"},
                        "construction":   {"236115", "236116", "236117", "236118", "236220"},
                        "transportation": {"484110", "484121", "484122", "484210", "485110"},
                        "education":      {"611110", "611210", "611310", "611410", "611420"},
                }

                for keyword, industryCodes := range keywordMappings </span><span class="cov8" title="1">{
                        if strings.Contains(textToSearch, keyword) </span><span class="cov8" title="1">{
                                for _, code := range industryCodes </span><span class="cov8" title="1">{
                                        classifications = append(classifications, IndustryClassification{
                                                IndustryCode:         code,
                                                IndustryName:         c.getIndustryName(code),
                                                ConfidenceScore:      0.7,
                                                ClassificationMethod: "keyword_based",
                                                Keywords:             []string{keyword},
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return classifications</span>
}

// classifyByBusinessType classifies business based on business type
func (c *ClassificationService) classifyByBusinessType(req *ClassificationRequest) []IndustryClassification <span class="cov8" title="1">{
        if req.BusinessType == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">businessTypeMappings := map[string]string{
                "llc":                 "541611", // Management consulting
                "corporation":         "541611", // Management consulting
                "partnership":         "541611", // Management consulting
                "sole_proprietorship": "541611", // Management consulting
                "nonprofit":           "813211", // Grantmaking foundations
                "charity":             "813211", // Grantmaking foundations
                "foundation":          "813211", // Grantmaking foundations
        }

        if code, exists := businessTypeMappings[strings.ToLower(req.BusinessType)]; exists </span><span class="cov8" title="1">{
                return []IndustryClassification{
                        {
                                IndustryCode:         code,
                                IndustryName:         c.getIndustryName(code),
                                ConfidenceScore:      0.8,
                                ClassificationMethod: "business_type_based",
                                Description:          fmt.Sprintf("Classified based on business type: %s", req.BusinessType),
                        },
                }
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// classifyByIndustry classifies business based on provided industry
func (c *ClassificationService) classifyByIndustry(req *ClassificationRequest) []IndustryClassification <span class="cov8" title="1">{
        if req.Industry == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">industryMappings := map[string]string{
                "technology":     "541511",
                "software":       "541511",
                "consulting":     "541611",
                "finance":        "522110",
                "healthcare":     "621111",
                "retail":         "441110",
                "manufacturing":  "332996",
                "construction":   "236115",
                "transportation": "484110",
                "education":      "611110",
                "real_estate":    "531110",
                "legal":          "541110",
                "accounting":     "541211",
                "marketing":      "541810",
                "advertising":    "541810",
        }

        if code, exists := industryMappings[strings.ToLower(req.Industry)]; exists </span><span class="cov8" title="1">{
                return []IndustryClassification{
                        {
                                IndustryCode:         code,
                                IndustryName:         c.getIndustryName(code),
                                ConfidenceScore:      0.9,
                                ClassificationMethod: "industry_based",
                                Description:          fmt.Sprintf("Classified based on industry: %s", req.Industry),
                        },
                }
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// classifyByIndustryText uses free-text industry label mapping via NAICS dataset as a fallback
func (c *ClassificationService) classifyByIndustryText(req *ClassificationRequest) []IndustryClassification <span class="cov8" title="1">{
        if req.Industry == "" || c.industryData == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">codes := mapIndustryTextToNAICS(req.Industry, c.industryData)
        if len(codes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := make([]IndustryClassification, 0, len(codes))
        for _, code := range codes </span><span class="cov0" title="0">{
                out = append(out, IndustryClassification{
                        IndustryCode:         code,
                        IndustryName:         c.industryData.GetNAICSName(code),
                        ConfidenceScore:      0.68,
                        ClassificationMethod: "industry_text_mapping",
                        Description:          "Mapped from free-text industry label",
                })
        }</span>
        <span class="cov0" title="0">return out</span>
}

// classifyByHistory falls back to previous classifications stored in the database for the same business
func (c *ClassificationService) classifyByHistory(ctx context.Context, req *ClassificationRequest) []IndustryClassification <span class="cov8" title="1">{
        if c.db == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // 1) Try by registration number
        <span class="cov0" title="0">if req.RegistrationNumber != "" </span><span class="cov0" title="0">{
                if b, err := c.db.GetBusinessByRegistrationNumber(ctx, req.RegistrationNumber); err == nil &amp;&amp; b != nil </span><span class="cov0" title="0">{
                        if cl := c.latestClassificationForBusiness(ctx, b.ID); cl != nil </span><span class="cov0" title="0">{
                                return []IndustryClassification{{
                                        IndustryCode:         cl.IndustryCode,
                                        IndustryName:         cl.IndustryName,
                                        ConfidenceScore:      minFloat(0.75, cl.ConfidenceScore),
                                        ClassificationMethod: "history_fallback",
                                        Description:          "Reused most recent prior classification by registration number",
                                }}
                        }</span>
                        // If no history but business has industry fields, use them
                        <span class="cov0" title="0">if b.IndustryCode != "" </span><span class="cov0" title="0">{
                                return []IndustryClassification{{
                                        IndustryCode:         b.IndustryCode,
                                        IndustryName:         c.getIndustryName(b.IndustryCode),
                                        ConfidenceScore:      0.6,
                                        ClassificationMethod: "history_business_profile",
                                        Description:          "Derived from stored business profile",
                                }}
                        }</span>
                }
        }

        // 2) Try by searching businesses by name and reuse their last classification
        <span class="cov0" title="0">name := strings.TrimSpace(req.BusinessName)
        if name == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if matches, err := c.db.SearchBusinesses(ctx, name, 1, 0); err == nil &amp;&amp; len(matches) &gt; 0 </span><span class="cov0" title="0">{
                b := matches[0]
                if cl := c.latestClassificationForBusiness(ctx, b.ID); cl != nil </span><span class="cov0" title="0">{
                        return []IndustryClassification{{
                                IndustryCode:         cl.IndustryCode,
                                IndustryName:         cl.IndustryName,
                                ConfidenceScore:      minFloat(0.7, cl.ConfidenceScore),
                                ClassificationMethod: "history_fallback_name_match",
                                Description:          "Reused most recent prior classification by business name",
                        }}
                }</span>
                <span class="cov0" title="0">if b.IndustryCode != "" </span><span class="cov0" title="0">{
                        return []IndustryClassification{{
                                IndustryCode:         b.IndustryCode,
                                IndustryName:         c.getIndustryName(b.IndustryCode),
                                ConfidenceScore:      0.55,
                                ClassificationMethod: "history_business_profile_name_match",
                                Description:          "Derived from stored business profile (name match)",
                        }}
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *ClassificationService) latestClassificationForBusiness(ctx context.Context, businessID string) *database.BusinessClassification <span class="cov0" title="0">{
        cls, err := c.db.GetBusinessClassificationsByBusinessID(ctx, businessID)
        if err != nil || len(cls) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">latest := cls[0]
        for _, v := range cls[1:] </span><span class="cov0" title="0">{
                if v.CreatedAt.After(latest.CreatedAt) </span><span class="cov0" title="0">{
                        latest = v
                }</span>
        }
        <span class="cov0" title="0">return latest</span>
}

func minFloat(a, b float64) float64 <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// classifyByName classifies business based on business name patterns
func (c *ClassificationService) classifyByName(req *ClassificationRequest) []IndustryClassification <span class="cov8" title="1">{
        name, _ := normalizeBusinessFields(req.BusinessName, "", "")

        // Define name pattern mappings
        namePatterns := map[string]string{
                "tech":          "541511",
                "software":      "541511",
                "systems":       "541511",
                "consult":       "541611",
                "advisory":      "541611",
                "financial":     "522110",
                "bank":          "522110",
                "credit":        "522110",
                "medical":       "621111",
                "health":        "621111",
                "clinic":        "621111",
                "store":         "441110",
                "shop":          "441110",
                "market":        "441110",
                "factory":       "332996",
                "manufacturing": "332996",
                "build":         "236115",
                "construction":  "236115",
                "transport":     "484110",
                "logistics":     "484110",
                "school":        "611110",
                "university":    "611110",
                "college":       "611110",
                "realty":        "531110",
                "properties":    "531110",
                "law":           "541110",
                "legal":         "541110",
                "accounting":    "541211",
                "cpa":           "541211",
                "marketing":     "541810",
                "advertising":   "541810",
        }

        for pattern, code := range namePatterns </span><span class="cov8" title="1">{
                if strings.Contains(name, pattern) </span><span class="cov8" title="1">{
                        return []IndustryClassification{
                                {
                                        IndustryCode:         code,
                                        IndustryName:         c.getIndustryName(code),
                                        ConfidenceScore:      0.6,
                                        ClassificationMethod: "name_pattern_based",
                                        Description:          fmt.Sprintf("Classified based on name pattern: %s", pattern),
                                },
                        }
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// classifyByFuzzy applies fuzzy matching on business name/description/keywords against industry datasets.
// It leverages token and full-text similarity to identify likely industries even when exact keywords do not match.
func (c *ClassificationService) classifyByFuzzy(req *ClassificationRequest) []IndustryClassification <span class="cov8" title="1">{
        if c.industryData == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">normalized, tokens := normalizeBusinessFields(req.BusinessName, req.Description, req.Keywords)
        if normalized == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Thresholds tuned for precision&gt;recall initially; can be adjusted with config later
        <span class="cov8" title="1">const naicsThreshold = 0.82
        const mccThreshold = 0.85
        const sicThreshold = 0.85

        naicsSeen := make(map[string]struct{})
        mccSeen := make(map[string]struct{})
        sicSeen := make(map[string]struct{})

        var out []IndustryClassification

        // Full-text pass (captures multi-word semantics)
        for _, code := range c.industryData.SearchNAICSByFuzzy(normalized, naicsThreshold) </span><span class="cov0" title="0">{
                if _, exists := naicsSeen[code]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">naicsSeen[code] = struct{}{}
                out = append(out, IndustryClassification{
                        IndustryCode:         code,
                        IndustryName:         c.industryData.GetNAICSName(code),
                        ConfidenceScore:      0.65,
                        ClassificationMethod: "fuzzy_naics_fulltext",
                })</span>
        }
        <span class="cov8" title="1">for _, code := range c.industryData.SearchMCCByFuzzy(normalized, mccThreshold) </span><span class="cov0" title="0">{
                if _, exists := mccSeen[code]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">mccSeen[code] = struct{}{}
                out = append(out, IndustryClassification{
                        IndustryCode:         code,
                        IndustryName:         c.industryData.GetMCCDescription(code),
                        ConfidenceScore:      0.55,
                        ClassificationMethod: "fuzzy_mcc_fulltext",
                })</span>
        }
        <span class="cov8" title="1">for _, code := range c.industryData.SearchSICByFuzzy(normalized, sicThreshold) </span><span class="cov0" title="0">{
                if _, exists := sicSeen[code]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">sicSeen[code] = struct{}{}
                out = append(out, IndustryClassification{
                        IndustryCode:         code,
                        IndustryName:         c.industryData.GetSICDescription(code),
                        ConfidenceScore:      0.5,
                        ClassificationMethod: "fuzzy_sic_fulltext",
                })</span>
        }

        // Token pass to catch strong token-specific signals
        <span class="cov8" title="1">for _, tok := range tokens </span><span class="cov8" title="1">{
                if len(tok) &lt; 3 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">for _, code := range c.industryData.SearchNAICSByFuzzy(tok, naicsThreshold) </span><span class="cov8" title="1">{
                        if _, exists := naicsSeen[code]; exists </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">naicsSeen[code] = struct{}{}
                        out = append(out, IndustryClassification{
                                IndustryCode:         code,
                                IndustryName:         c.industryData.GetNAICSName(code),
                                ConfidenceScore:      0.62,
                                ClassificationMethod: "fuzzy_naics_token",
                                Keywords:             []string{tok},
                        })</span>
                }
                <span class="cov8" title="1">for _, code := range c.industryData.SearchMCCByFuzzy(tok, mccThreshold) </span><span class="cov0" title="0">{
                        if _, exists := mccSeen[code]; exists </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">mccSeen[code] = struct{}{}
                        out = append(out, IndustryClassification{
                                IndustryCode:         code,
                                IndustryName:         c.industryData.GetMCCDescription(code),
                                ConfidenceScore:      0.52,
                                ClassificationMethod: "fuzzy_mcc_token",
                                Keywords:             []string{tok},
                        })</span>
                }
                <span class="cov8" title="1">for _, code := range c.industryData.SearchSICByFuzzy(tok, sicThreshold) </span><span class="cov8" title="1">{
                        if _, exists := sicSeen[code]; exists </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">sicSeen[code] = struct{}{}
                        out = append(out, IndustryClassification{
                                IndustryCode:         code,
                                IndustryName:         c.industryData.GetSICDescription(code),
                                ConfidenceScore:      0.48,
                                ClassificationMethod: "fuzzy_sic_token",
                                Keywords:             []string{tok},
                        })</span>
                }
        }

        <span class="cov8" title="1">return out</span>
}

// determinePrimaryClassification determines the primary classification from multiple results
func (c *ClassificationService) determinePrimaryClassification(classifications []IndustryClassification) *IndustryClassification <span class="cov8" title="1">{
        if len(classifications) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Find the classification with the highest confidence score
        <span class="cov8" title="1">var primary *IndustryClassification
        highestConfidence := 0.0

        for i := range classifications </span><span class="cov8" title="1">{
                if classifications[i].ConfidenceScore &gt; highestConfidence </span><span class="cov8" title="1">{
                        highestConfidence = classifications[i].ConfidenceScore
                        primary = &amp;classifications[i]
                }</span>
        }

        <span class="cov8" title="1">return primary</span>
}

// calculateOverallConfidence calculates the overall confidence score
func (c *ClassificationService) calculateOverallConfidence(classifications []IndustryClassification) float64 <span class="cov8" title="1">{
        if len(classifications) == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>

        <span class="cov8" title="1">totalConfidence := 0.0
        for _, classification := range classifications </span><span class="cov8" title="1">{
                totalConfidence += classification.ConfidenceScore
        }</span>

        <span class="cov8" title="1">return totalConfidence / float64(len(classifications))</span>
}

// getIndustryName returns the industry name for a given NAICS code
func (c *ClassificationService) getIndustryName(code string) string <span class="cov8" title="1">{
        // Use real industry data if available
        if c.industryData != nil </span><span class="cov8" title="1">{
                return c.industryData.GetNAICSName(code)
        }</span>

        // Fallback to hardcoded mappings
        <span class="cov8" title="1">industryNames := map[string]string{
                "541511": "Custom Computer Programming Services",
                "541512": "Computer Systems Design Services",
                "541519": "Other Computer Related Services",
                "541611": "Administrative Management and General Management Consulting Services",
                "541612": "Human Resources Consulting Services",
                "541618": "Other Management Consulting Services",
                "541690": "Other Scientific and Technical Consulting Services",
                "541715": "Research and Development in the Physical, Engineering, and Life Sciences",
                "522110": "Commercial Banking",
                "522120": "Savings Institutions",
                "522130": "Credit Unions",
                "522190": "Other Depository Credit Intermediation",
                "523150": "Securities and Commodity Exchanges",
                "621111": "Offices of Physicians (except Mental Health Specialists)",
                "621112": "Offices of Physicians, Mental Health Specialists",
                "621210": "Offices of Dentists",
                "621310": "Offices of Chiropractors",
                "621320": "Offices of Optometrists",
                "441110": "New Car Dealers",
                "442110": "Furniture Stores",
                "443141": "Household Appliance Stores",
                "444110": "Home Centers",
                "445110": "Supermarkets and Other Grocery (except Convenience) Stores",
                "332996": "Fabricated Pipe and Pipe Fitting Manufacturing",
                "332999": "Miscellaneous Fabricated Metal Product Manufacturing",
                "333415": "Air-Conditioning and Warm Air Heating Equipment and Commercial and Industrial Refrigeration Equipment Manufacturing",
                "334110": "Computer and Peripheral Equipment Manufacturing",
                "335110": "Electric Lamp Bulb and Part Manufacturing",
                "236115": "New Single-Family Housing Construction (except For-Sale Builders)",
                "236116": "New Multifamily Housing Construction (except For-Sale Builders)",
                "236117": "New Housing For-Sale Builders",
                "236118": "Residential Remodelers",
                "236220": "Commercial Building Construction",
                "484110": "General Freight Trucking, Local",
                "484121": "General Freight Trucking, Long-Distance, Truckload",
                "484122": "General Freight Trucking, Long-Distance, Less Than Truckload",
                "484210": "Used Household and Office Goods Moving",
                "485110": "Urban Transit Systems",
                "611110": "Elementary and Secondary Schools",
                "611210": "Junior Colleges",
                "611310": "Colleges, Universities, and Professional Schools",
                "611410": "Business and Secretarial Schools",
                "611420": "Computer Training",
                "531110": "Lessors of Residential Buildings and Dwellings",
                "541110": "Offices of Lawyers",
                "541211": "Offices of Certified Public Accountants",
                "541810": "Advertising Agencies",
                "813211": "Grantmaking Foundations",
        }

        if name, exists := industryNames[code]; exists </span><span class="cov8" title="1">{
                return name
        }</span>

        <span class="cov8" title="1">return "Unknown Industry"</span>
}

// getDefaultClassification returns a default classification
func (c *ClassificationService) getDefaultClassification() IndustryClassification <span class="cov8" title="1">{
        return IndustryClassification{
                IndustryCode:         "541611",
                IndustryName:         "Administrative Management and General Management Consulting Services",
                ConfidenceScore:      0.3,
                ClassificationMethod: "default",
                Description:          "Default classification applied when no specific classification could be determined",
        }
}</span>

// generateBusinessID generates a unique business ID
func (c *ClassificationService) generateBusinessID(req *ClassificationRequest) string <span class="cov8" title="1">{
        // In a real implementation, this would generate a proper UUID
        // For now, we'll create a simple hash-based ID
        return fmt.Sprintf("business_%d", time.Now().UnixNano())
}</span>

// storeClassification stores the classification result in the database
func (c *ClassificationService) storeClassification(ctx context.Context, businessID string, response *ClassificationResponse) error <span class="cov0" title="0">{
        if response.PrimaryClassification == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no primary classification to store")
        }</span>

        <span class="cov0" title="0">classification := &amp;database.BusinessClassification{
                ID:                   fmt.Sprintf("classification_%d", time.Now().UnixNano()),
                BusinessID:           businessID,
                IndustryCode:         response.PrimaryClassification.IndustryCode,
                IndustryName:         response.PrimaryClassification.IndustryName,
                ConfidenceScore:      response.PrimaryClassification.ConfidenceScore,
                ClassificationMethod: response.PrimaryClassification.ClassificationMethod,
                Source:               "internal_classifier",
                RawData:              fmt.Sprintf("%+v", response.RawData),
                CreatedAt:            time.Now(),
        }

        return c.db.CreateBusinessClassification(ctx, classification)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package compliance

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// AlertSystem provides comprehensive compliance alert management
type AlertSystem struct {
        logger        *observability.Logger
        statusSystem  *ComplianceStatusSystem
        checkEngine   *CheckEngine
        rules         map[string]*AlertRule
        escalations   map[string]*EscalationPolicy
        notifications map[string]*NotificationChannel
        mu            sync.RWMutex
}

// AlertRule defines when and how alerts should be generated
type AlertRule struct {
        ID          string                 `json:"id"`
        Name        string                 `json:"name"`
        Description string                 `json:"description"`
        Enabled     bool                   `json:"enabled"`
        EntityType  string                 `json:"entity_type"` // "overall", "framework", "requirement", "control"
        Conditions  []AlertCondition       `json:"conditions"`
        Severity    string                 `json:"severity"` // "low", "medium", "high", "critical"
        Actions     []AlertAction          `json:"actions"`
        Suppression *AlertSuppression      `json:"suppression,omitempty"`
        CreatedAt   time.Time              `json:"created_at"`
        UpdatedAt   time.Time              `json:"updated_at"`
        Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// AlertCondition defines a condition that triggers an alert
type AlertCondition struct {
        Type     string         `json:"type"`               // "score_below", "score_decline", "status_change", "deadline_missed", "risk_increase"
        Field    string         `json:"field"`              // Field to monitor
        Operator string         `json:"operator"`           // "lt", "lte", "eq", "gte", "gt", "ne"
        Value    interface{}    `json:"value"`              // Threshold value
        Duration *time.Duration `json:"duration,omitempty"` // Duration for sustained conditions
        Window   *time.Duration `json:"window,omitempty"`   // Time window for evaluation
}

// AlertAction defines what happens when an alert is triggered
type AlertAction struct {
        Type       string                 `json:"type"`                  // "create_alert", "send_notification", "escalate", "webhook"
        Parameters map[string]interface{} `json:"parameters"`            // Action-specific parameters
        Delay      *time.Duration         `json:"delay,omitempty"`       // Delay before action
        RetryCount int                    `json:"retry_count"`           // Number of retries
        RetryDelay *time.Duration         `json:"retry_delay,omitempty"` // Delay between retries
}

// AlertSuppression defines how to suppress duplicate alerts
type AlertSuppression struct {
        Enabled   bool          `json:"enabled"`
        Window    time.Duration `json:"window"`     // Time window for suppression
        MaxAlerts int           `json:"max_alerts"` // Maximum alerts in window
        GroupBy   []string      `json:"group_by"`   // Fields to group by for suppression
}

// EscalationPolicy defines how alerts should be escalated
type EscalationPolicy struct {
        ID          string                 `json:"id"`
        Name        string                 `json:"name"`
        Description string                 `json:"description"`
        Enabled     bool                   `json:"enabled"`
        Levels      []EscalationLevel      `json:"levels"`
        CreatedAt   time.Time              `json:"created_at"`
        UpdatedAt   time.Time              `json:"updated_at"`
        Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// EscalationLevel defines a level in the escalation policy
type EscalationLevel struct {
        Level      int                    `json:"level"`
        Name       string                 `json:"name"`
        Delay      time.Duration          `json:"delay"`      // Delay before escalation
        Recipients []string               `json:"recipients"` // Recipients for this level
        Actions    []string               `json:"actions"`    // Actions to take
        Conditions map[string]interface{} `json:"conditions"` // Conditions for escalation
}

// NotificationChannel defines how to send notifications
type NotificationChannel struct {
        ID         string                 `json:"id"`
        Name       string                 `json:"name"`
        Type       string                 `json:"type"` // "email", "webhook", "slack", "sms"
        Enabled    bool                   `json:"enabled"`
        Config     map[string]interface{} `json:"config"`     // Channel-specific configuration
        Recipients []string               `json:"recipients"` // Default recipients
        CreatedAt  time.Time              `json:"created_at"`
        UpdatedAt  time.Time              `json:"updated_at"`
        Metadata   map[string]interface{} `json:"metadata,omitempty"`
}

// AlertEvaluation represents the evaluation of alert rules
type AlertEvaluation struct {
        RuleID      string                 `json:"rule_id"`
        BusinessID  string                 `json:"business_id"`
        EntityType  string                 `json:"entity_type"`
        EntityID    string                 `json:"entity_id"`
        Triggered   bool                   `json:"triggered"`
        Conditions  []ConditionResult      `json:"conditions"`
        Actions     []ActionResult         `json:"actions"`
        EvaluatedAt time.Time              `json:"evaluated_at"`
        Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// ConditionResult represents the result of evaluating a condition
type ConditionResult struct {
        Condition   AlertCondition `json:"condition"`
        Triggered   bool           `json:"triggered"`
        Value       interface{}    `json:"value"`
        Message     string         `json:"message"`
        EvaluatedAt time.Time      `json:"evaluated_at"`
}

// ActionResult represents the result of executing an action
type ActionResult struct {
        Action     AlertAction `json:"action"`
        Success    bool        `json:"success"`
        Message    string      `json:"message"`
        ExecutedAt time.Time   `json:"executed_at"`
        RetryCount int         `json:"retry_count"`
}

// AlertAnalytics represents analytics about alerts
type AlertAnalytics struct {
        BusinessID            string                 `json:"business_id"`
        Period                string                 `json:"period"`
        TotalAlerts           int                    `json:"total_alerts"`
        ActiveAlerts          int                    `json:"active_alerts"`
        ResolvedAlerts        int                    `json:"resolved_alerts"`
        AlertsBySeverity      map[string]int         `json:"alerts_by_severity"`
        AlertsByType          map[string]int         `json:"alerts_by_type"`
        AlertsByEntity        map[string]int         `json:"alerts_by_entity"`
        AverageResolutionTime time.Duration          `json:"average_resolution_time"`
        EscalationCount       int                    `json:"escalation_count"`
        SuppressionCount      int                    `json:"suppression_count"`
        Trends                []AlertTrend           `json:"trends"`
        GeneratedAt           time.Time              `json:"generated_at"`
        Metadata              map[string]interface{} `json:"metadata,omitempty"`
}

// AlertTrend represents alert trends over time
type AlertTrend struct {
        Date           time.Time `json:"date"`
        TotalAlerts    int       `json:"total_alerts"`
        NewAlerts      int       `json:"new_alerts"`
        ResolvedAlerts int       `json:"resolved_alerts"`
        ActiveAlerts   int       `json:"active_alerts"`
}

// NewAlertSystem creates a new compliance alert system
func NewAlertSystem(logger *observability.Logger, statusSystem *ComplianceStatusSystem, checkEngine *CheckEngine) *AlertSystem <span class="cov8" title="1">{
        return &amp;AlertSystem{
                logger:        logger,
                statusSystem:  statusSystem,
                checkEngine:   checkEngine,
                rules:         make(map[string]*AlertRule),
                escalations:   make(map[string]*EscalationPolicy),
                notifications: make(map[string]*NotificationChannel),
        }
}</span>

// RegisterAlertRule registers a new alert rule
func (s *AlertSystem) RegisterAlertRule(ctx context.Context, rule *AlertRule) error <span class="cov8" title="1">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Registering alert rule",
                "request_id", requestID,
                "rule_id", rule.ID,
                "rule_name", rule.Name,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        rule.CreatedAt = time.Now()
        rule.UpdatedAt = time.Now()
        s.rules[rule.ID] = rule

        s.logger.Info("Alert rule registered successfully",
                "request_id", requestID,
                "rule_id", rule.ID,
        )

        return nil
}</span>

// UpdateAlertRule updates an existing alert rule
func (s *AlertSystem) UpdateAlertRule(ctx context.Context, ruleID string, updates map[string]interface{}) error <span class="cov8" title="1">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Updating alert rule",
                "request_id", requestID,
                "rule_id", ruleID,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        rule, exists := s.rules[ruleID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("alert rule %s not found", ruleID)
        }</span>

        // Apply updates
        <span class="cov8" title="1">for field, value := range updates </span><span class="cov8" title="1">{
                switch field </span>{
                case "name":<span class="cov8" title="1">
                        if name, ok := value.(string); ok </span><span class="cov8" title="1">{
                                rule.Name = name
                        }</span>
                case "description":<span class="cov8" title="1">
                        if desc, ok := value.(string); ok </span><span class="cov8" title="1">{
                                rule.Description = desc
                        }</span>
                case "enabled":<span class="cov8" title="1">
                        if enabled, ok := value.(bool); ok </span><span class="cov8" title="1">{
                                rule.Enabled = enabled
                        }</span>
                case "severity":<span class="cov8" title="1">
                        if severity, ok := value.(string); ok </span><span class="cov8" title="1">{
                                rule.Severity = severity
                        }</span>
                case "conditions":<span class="cov0" title="0">
                        if conditions, ok := value.([]AlertCondition); ok </span><span class="cov0" title="0">{
                                rule.Conditions = conditions
                        }</span>
                case "actions":<span class="cov0" title="0">
                        if actions, ok := value.([]AlertAction); ok </span><span class="cov0" title="0">{
                                rule.Actions = actions
                        }</span>
                }
        }

        <span class="cov8" title="1">rule.UpdatedAt = time.Now()

        s.logger.Info("Alert rule updated successfully",
                "request_id", requestID,
                "rule_id", ruleID,
        )

        return nil</span>
}

// DeleteAlertRule deletes an alert rule
func (s *AlertSystem) DeleteAlertRule(ctx context.Context, ruleID string) error <span class="cov8" title="1">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Deleting alert rule",
                "request_id", requestID,
                "rule_id", ruleID,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        if _, exists := s.rules[ruleID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("alert rule %s not found", ruleID)
        }</span>

        <span class="cov8" title="1">delete(s.rules, ruleID)

        s.logger.Info("Alert rule deleted successfully",
                "request_id", requestID,
                "rule_id", ruleID,
        )

        return nil</span>
}

// GetAlertRule gets an alert rule by ID
func (s *AlertSystem) GetAlertRule(ctx context.Context, ruleID string) (*AlertRule, error) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        rule, exists := s.rules[ruleID]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("alert rule %s not found", ruleID)
        }</span>

        <span class="cov8" title="1">return rule, nil</span>
}

// ListAlertRules lists all alert rules
func (s *AlertSystem) ListAlertRules(ctx context.Context) ([]*AlertRule, error) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        rules := make([]*AlertRule, 0, len(s.rules))
        for _, rule := range s.rules </span><span class="cov8" title="1">{
                rules = append(rules, rule)
        }</span>

        <span class="cov8" title="1">return rules, nil</span>
}

// EvaluateAlerts evaluates all alert rules for a business
func (s *AlertSystem) EvaluateAlerts(ctx context.Context, businessID string) ([]AlertEvaluation, error) <span class="cov8" title="1">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Evaluating alerts for business",
                "request_id", requestID,
                "business_id", businessID,
        )

        s.mu.RLock()
        rules := make([]*AlertRule, 0, len(s.rules))
        for _, rule := range s.rules </span><span class="cov8" title="1">{
                if rule.Enabled </span><span class="cov8" title="1">{
                        rules = append(rules, rule)
                }</span>
        }
        <span class="cov8" title="1">s.mu.RUnlock()

        evaluations := make([]AlertEvaluation, 0)

        for _, rule := range rules </span><span class="cov8" title="1">{
                evaluation, err := s.evaluateRule(ctx, businessID, rule)
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Error("Failed to evaluate rule",
                                "request_id", requestID,
                                "rule_id", rule.ID,
                                "error", err.Error(),
                        )
                        // Create a failed evaluation instead of skipping
                        failedEvaluation := AlertEvaluation{
                                RuleID:      rule.ID,
                                BusinessID:  businessID,
                                EntityType:  rule.EntityType,
                                Triggered:   false,
                                EvaluatedAt: time.Now(),
                                Metadata: map[string]interface{}{
                                        "error": err.Error(),
                                },
                        }
                        evaluations = append(evaluations, failedEvaluation)
                        continue</span>
                }

                <span class="cov0" title="0">evaluations = append(evaluations, evaluation)

                // Execute actions if rule was triggered
                if evaluation.Triggered </span><span class="cov0" title="0">{
                        s.executeAlertActions(ctx, businessID, rule, evaluation)
                }</span>
        }

        <span class="cov8" title="1">s.logger.Info("Alert evaluation completed",
                "request_id", requestID,
                "business_id", businessID,
                "rules_evaluated", len(rules),
                "rules_triggered", len(evaluations),
        )

        return evaluations, nil</span>
}

// evaluateRule evaluates a single alert rule
func (s *AlertSystem) evaluateRule(ctx context.Context, businessID string, rule *AlertRule) (AlertEvaluation, error) <span class="cov8" title="1">{
        evaluation := AlertEvaluation{
                RuleID:      rule.ID,
                BusinessID:  businessID,
                EntityType:  rule.EntityType,
                EvaluatedAt: time.Now(),
        }

        // Evaluate each condition
        allConditionsMet := true
        for _, condition := range rule.Conditions </span><span class="cov8" title="1">{
                result, err := s.evaluateCondition(ctx, businessID, condition)
                if err != nil </span><span class="cov8" title="1">{
                        return evaluation, fmt.Errorf("failed to evaluate condition: %w", err)
                }</span>

                <span class="cov0" title="0">evaluation.Conditions = append(evaluation.Conditions, result)
                if !result.Triggered </span><span class="cov0" title="0">{
                        allConditionsMet = false
                }</span>
        }

        <span class="cov0" title="0">evaluation.Triggered = allConditionsMet

        return evaluation, nil</span>
}

// evaluateCondition evaluates a single alert condition
func (s *AlertSystem) evaluateCondition(ctx context.Context, businessID string, condition AlertCondition) (ConditionResult, error) <span class="cov8" title="1">{
        result := ConditionResult{
                Condition:   condition,
                EvaluatedAt: time.Now(),
        }

        // Get current value based on condition type
        var currentValue interface{}
        var err error

        switch condition.Type </span>{
        case "score_below":<span class="cov0" title="0">
                currentValue, err = s.getCurrentScore(ctx, businessID, condition.Field)</span>
        case "score_decline":<span class="cov0" title="0">
                currentValue, err = s.getScoreDecline(ctx, businessID, condition.Field, condition.Window)</span>
        case "status_change":<span class="cov0" title="0">
                currentValue, err = s.getStatusChange(ctx, businessID, condition.Field, condition.Window)</span>
        case "deadline_missed":<span class="cov0" title="0">
                currentValue, err = s.getDeadlineStatus(ctx, businessID, condition.Field)</span>
        case "risk_increase":<span class="cov0" title="0">
                currentValue, err = s.getRiskIncrease(ctx, businessID, condition.Field, condition.Window)</span>
        default:<span class="cov8" title="1">
                return result, fmt.Errorf("unsupported condition type: %s", condition.Type)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return result, fmt.Errorf("failed to get current value: %w", err)
        }</span>

        <span class="cov0" title="0">result.Value = currentValue

        // Evaluate condition based on operator
        result.Triggered = s.evaluateOperator(currentValue, condition.Operator, condition.Value)
        result.Message = fmt.Sprintf("Condition %s: current=%v, threshold=%v, triggered=%v",
                condition.Type, currentValue, condition.Value, result.Triggered)

        return result, nil</span>
}

// evaluateOperator evaluates a condition using the specified operator
func (s *AlertSystem) evaluateOperator(current, operator, threshold interface{}) bool <span class="cov0" title="0">{
        switch operator </span>{
        case "lt":<span class="cov0" title="0">
                return s.compareValues(current, threshold) &lt; 0</span>
        case "lte":<span class="cov0" title="0">
                return s.compareValues(current, threshold) &lt;= 0</span>
        case "eq":<span class="cov0" title="0">
                return s.compareValues(current, threshold) == 0</span>
        case "gte":<span class="cov0" title="0">
                return s.compareValues(current, threshold) &gt;= 0</span>
        case "gt":<span class="cov0" title="0">
                return s.compareValues(current, threshold) &gt; 0</span>
        case "ne":<span class="cov0" title="0">
                return s.compareValues(current, threshold) != 0</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// compareValues compares two values for evaluation
func (s *AlertSystem) compareValues(a, b interface{}) int <span class="cov8" title="1">{
        // Convert to float64 for numeric comparison
        aFloat, aOk := s.toFloat64(a)
        bFloat, bOk := s.toFloat64(b)

        if aOk &amp;&amp; bOk </span><span class="cov8" title="1">{
                if aFloat &lt; bFloat </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> if aFloat &gt; bFloat </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        }

        // String comparison
        <span class="cov8" title="1">aStr := fmt.Sprintf("%v", a)
        bStr := fmt.Sprintf("%v", b)

        if aStr &lt; bStr </span><span class="cov8" title="1">{
                return -1
        }</span> else<span class="cov8" title="1"> if aStr &gt; bStr </span><span class="cov8" title="1">{
                return 1
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// toFloat64 converts a value to float64
func (s *AlertSystem) toFloat64(v interface{}) (float64, bool) <span class="cov8" title="1">{
        switch val := v.(type) </span>{
        case float64:<span class="cov8" title="1">
                return val, true</span>
        case float32:<span class="cov8" title="1">
                return float64(val), true</span>
        case int:<span class="cov8" title="1">
                return float64(val), true</span>
        case int32:<span class="cov8" title="1">
                return float64(val), true</span>
        case int64:<span class="cov8" title="1">
                return float64(val), true</span>
        default:<span class="cov8" title="1">
                return 0, false</span>
        }
}

// Helper methods for getting current values
func (s *AlertSystem) getCurrentScore(ctx context.Context, businessID, field string) (interface{}, error) <span class="cov0" title="0">{
        status, err := s.statusSystem.GetComplianceStatus(ctx, businessID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">switch field </span>{
        case "overall":<span class="cov0" title="0">
                return status.OverallScore, nil</span>
        default:<span class="cov0" title="0">
                // Try to get framework score
                if frameworkStatus, exists := status.FrameworkStatuses[field]; exists </span><span class="cov0" title="0">{
                        return frameworkStatus.Score, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("unknown score field: %s", field)</span>
        }
}

func (s *AlertSystem) getScoreDecline(ctx context.Context, businessID, field string, window *time.Duration) (interface{}, error) <span class="cov0" title="0">{
        // This would compare current score with historical score
        // For now, return a placeholder
        return 0.0, nil
}</span>

func (s *AlertSystem) getStatusChange(ctx context.Context, businessID, field string, window *time.Duration) (interface{}, error) <span class="cov0" title="0">{
        // This would check for status changes in the specified window
        // For now, return a placeholder
        return "stable", nil
}</span>

func (s *AlertSystem) getDeadlineStatus(ctx context.Context, businessID, field string) (interface{}, error) <span class="cov0" title="0">{
        // This would check if deadlines are missed
        // For now, return a placeholder
        return false, nil
}</span>

func (s *AlertSystem) getRiskIncrease(ctx context.Context, businessID, field string, window *time.Duration) (interface{}, error) <span class="cov0" title="0">{
        // This would check for risk level increases
        // For now, return a placeholder
        return "low", nil
}</span>

// executeAlertActions executes the actions for a triggered alert
func (s *AlertSystem) executeAlertActions(ctx context.Context, businessID string, rule *AlertRule, evaluation AlertEvaluation) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Executing alert actions",
                "request_id", requestID,
                "business_id", businessID,
                "rule_id", rule.ID,
        )

        for _, action := range rule.Actions </span><span class="cov0" title="0">{
                result := s.executeAction(ctx, businessID, rule, action, evaluation)
                evaluation.Actions = append(evaluation.Actions, result)

                if !result.Success </span><span class="cov0" title="0">{
                        s.logger.Error("Alert action failed",
                                "request_id", requestID,
                                "rule_id", rule.ID,
                                "action_type", action.Type,
                                "error", result.Message,
                        )
                }</span>
        }
}

// executeAction executes a single alert action
func (s *AlertSystem) executeAction(ctx context.Context, businessID string, rule *AlertRule, action AlertAction, evaluation AlertEvaluation) ActionResult <span class="cov0" title="0">{
        result := ActionResult{
                Action:     action,
                ExecutedAt: time.Now(),
        }

        switch action.Type </span>{
        case "create_alert":<span class="cov0" title="0">
                result.Success = s.createAlertFromRule(ctx, businessID, rule, evaluation)</span>
        case "send_notification":<span class="cov0" title="0">
                result.Success = s.sendNotification(ctx, businessID, rule, action, evaluation)</span>
        case "escalate":<span class="cov0" title="0">
                result.Success = s.escalateAlert(ctx, businessID, rule, action, evaluation)</span>
        case "webhook":<span class="cov0" title="0">
                result.Success = s.sendWebhook(ctx, businessID, rule, action, evaluation)</span>
        default:<span class="cov0" title="0">
                result.Success = false
                result.Message = fmt.Sprintf("unknown action type: %s", action.Type)</span>
        }

        <span class="cov0" title="0">return result</span>
}

// createAlertFromRule creates an alert from a triggered rule
func (s *AlertSystem) createAlertFromRule(ctx context.Context, businessID string, rule *AlertRule, evaluation AlertEvaluation) bool <span class="cov0" title="0">{
        // Check suppression
        if rule.Suppression != nil &amp;&amp; rule.Suppression.Enabled </span><span class="cov0" title="0">{
                if s.isAlertSuppressed(ctx, businessID, rule) </span><span class="cov0" title="0">{
                        return true // Suppressed, but not an error
                }</span>
        }

        // Create alert using the status system
        <span class="cov0" title="0">title := fmt.Sprintf("Alert: %s", rule.Name)
        description := fmt.Sprintf("Rule '%s' triggered for business %s", rule.Name, businessID)

        err := s.statusSystem.CreateStatusAlert(ctx, businessID, "rule_triggered", rule.Severity, rule.EntityType, "", title, description, nil, nil)
        return err == nil</span>
}

// isAlertSuppressed checks if an alert should be suppressed
func (s *AlertSystem) isAlertSuppressed(ctx context.Context, businessID string, rule *AlertRule) bool <span class="cov0" title="0">{
        // This would check if similar alerts were created recently
        // For now, return false (no suppression)
        return false
}</span>

// sendNotification sends a notification
func (s *AlertSystem) sendNotification(ctx context.Context, businessID string, rule *AlertRule, action AlertAction, evaluation AlertEvaluation) bool <span class="cov0" title="0">{
        // This would send notifications via configured channels
        // For now, return true (success)
        return true
}</span>

// escalateAlert escalates an alert
func (s *AlertSystem) escalateAlert(ctx context.Context, businessID string, rule *AlertRule, action AlertAction, evaluation AlertEvaluation) bool <span class="cov0" title="0">{
        // This would escalate the alert according to escalation policies
        // For now, return true (success)
        return true
}</span>

// sendWebhook sends a webhook notification
func (s *AlertSystem) sendWebhook(ctx context.Context, businessID string, rule *AlertRule, action AlertAction, evaluation AlertEvaluation) bool <span class="cov0" title="0">{
        // This would send webhook notifications
        // For now, return true (success)
        return true
}</span>

// GetAlertAnalytics gets analytics about alerts for a business
func (s *AlertSystem) GetAlertAnalytics(ctx context.Context, businessID string, period string) (*AlertAnalytics, error) <span class="cov8" title="1">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Getting alert analytics",
                "request_id", requestID,
                "business_id", businessID,
                "period", period,
        )

        // Get alerts from status system
        alerts, err := s.statusSystem.GetStatusAlerts(ctx, businessID, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get alerts: %w", err)
        }</span>

        <span class="cov8" title="1">analytics := &amp;AlertAnalytics{
                BusinessID:       businessID,
                Period:           period,
                GeneratedAt:      time.Now(),
                AlertsBySeverity: make(map[string]int),
                AlertsByType:     make(map[string]int),
                AlertsByEntity:   make(map[string]int),
        }

        // Calculate analytics
        for _, alert := range alerts </span><span class="cov0" title="0">{
                analytics.TotalAlerts++

                if alert.Status == "active" </span><span class="cov0" title="0">{
                        analytics.ActiveAlerts++
                }</span> else<span class="cov0" title="0"> if alert.Status == "resolved" </span><span class="cov0" title="0">{
                        analytics.ResolvedAlerts++
                }</span>

                <span class="cov0" title="0">analytics.AlertsBySeverity[alert.Severity]++
                analytics.AlertsByType[alert.AlertType]++
                analytics.AlertsByEntity[alert.EntityType]++</span>
        }

        // Calculate average resolution time
        <span class="cov8" title="1">if analytics.ResolvedAlerts &gt; 0 </span><span class="cov0" title="0">{
                totalResolutionTime := time.Duration(0)
                resolvedCount := 0

                for _, alert := range alerts </span><span class="cov0" title="0">{
                        if alert.Status == "resolved" &amp;&amp; alert.ResolvedAt != nil </span><span class="cov0" title="0">{
                                resolutionTime := alert.ResolvedAt.Sub(alert.TriggeredAt)
                                totalResolutionTime += resolutionTime
                                resolvedCount++
                        }</span>
                }

                <span class="cov0" title="0">if resolvedCount &gt; 0 </span><span class="cov0" title="0">{
                        analytics.AverageResolutionTime = totalResolutionTime / time.Duration(resolvedCount)
                }</span>
        }

        <span class="cov8" title="1">s.logger.Info("Alert analytics generated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "total_alerts", analytics.TotalAlerts,
                "active_alerts", analytics.ActiveAlerts,
        )

        return analytics, nil</span>
}

// RegisterEscalationPolicy registers a new escalation policy
func (s *AlertSystem) RegisterEscalationPolicy(ctx context.Context, policy *EscalationPolicy) error <span class="cov8" title="1">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Registering escalation policy",
                "request_id", requestID,
                "policy_id", policy.ID,
                "policy_name", policy.Name,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        policy.CreatedAt = time.Now()
        policy.UpdatedAt = time.Now()
        s.escalations[policy.ID] = policy

        s.logger.Info("Escalation policy registered successfully",
                "request_id", requestID,
                "policy_id", policy.ID,
        )

        return nil
}</span>

// RegisterNotificationChannel registers a new notification channel
func (s *AlertSystem) RegisterNotificationChannel(ctx context.Context, channel *NotificationChannel) error <span class="cov8" title="1">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Registering notification channel",
                "request_id", requestID,
                "channel_id", channel.ID,
                "channel_name", channel.Name,
                "channel_type", channel.Type,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        channel.CreatedAt = time.Now()
        channel.UpdatedAt = time.Now()
        s.notifications[channel.ID] = channel

        s.logger.Info("Notification channel registered successfully",
                "request_id", requestID,
                "channel_id", channel.ID,
        )

        return nil
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package compliance

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// ComplianceAuditSystem provides comprehensive compliance audit trail functionality
type ComplianceAuditSystem struct {
        logger       *observability.Logger
        mu           sync.RWMutex
        auditTrails  map[string][]ComplianceAuditTrail // businessID -&gt; audit trails
        auditEvents  map[string][]AuditEvent           // businessID -&gt; audit events
        auditReports map[string]*AuditReport           // businessID -&gt; audit report
        auditMetrics map[string]*AuditMetrics          // businessID -&gt; audit metrics
        auditFilters map[string]*AuditFilter           // businessID -&gt; audit filter
}

// AuditEvent represents a compliance audit event
type AuditEvent struct {
        ID            string                 `json:"id"`
        BusinessID    string                 `json:"business_id"`
        EventType     string                 `json:"event_type"`     // "status_change", "requirement_update", "control_test", "evidence_added", "exception_created", "remediation_plan", "framework_mapping", "alert_triggered", "report_generated"
        EventCategory string                 `json:"event_category"` // "status", "requirement", "control", "evidence", "exception", "remediation", "mapping", "alert", "report"
        EntityType    string                 `json:"entity_type"`    // "overall", "framework", "requirement", "control", "evidence", "exception", "remediation", "mapping", "alert"
        EntityID      string                 `json:"entity_id"`
        Action        AuditAction            `json:"action"`
        Description   string                 `json:"description"`
        UserID        string                 `json:"user_id"`
        UserName      string                 `json:"user_name"`
        UserRole      string                 `json:"user_role"`
        UserEmail     string                 `json:"user_email"`
        IPAddress     string                 `json:"ip_address"`
        UserAgent     string                 `json:"user_agent"`
        SessionID     string                 `json:"session_id"`
        RequestID     string                 `json:"request_id"`
        Timestamp     time.Time              `json:"timestamp"`
        Duration      time.Duration          `json:"duration,omitempty"`
        Success       bool                   `json:"success"`
        ErrorCode     string                 `json:"error_code,omitempty"`
        ErrorMessage  string                 `json:"error_message,omitempty"`
        OldValue      interface{}            `json:"old_value,omitempty"`
        NewValue      interface{}            `json:"new_value,omitempty"`
        Metadata      map[string]interface{} `json:"metadata,omitempty"`
        Severity      string                 `json:"severity"` // "low", "medium", "high", "critical"
        Impact        string                 `json:"impact"`   // "minimal", "low", "medium", "high", "critical"
        Tags          []string               `json:"tags"`
}

// AuditReport represents a comprehensive compliance audit report
type AuditReport struct {
        ID              string                 `json:"id"`
        BusinessID      string                 `json:"business_id"`
        ReportType      string                 `json:"report_type"` // "summary", "detailed", "activity", "changes", "exceptions", "remediations"
        GeneratedAt     time.Time              `json:"generated_at"`
        GeneratedBy     string                 `json:"generated_by"`
        Period          string                 `json:"period"`
        StartDate       time.Time              `json:"start_date"`
        EndDate         time.Time              `json:"end_date"`
        TotalEvents     int                    `json:"total_events"`
        EventCounts     map[string]int         `json:"event_counts"`
        CategoryCounts  map[string]int         `json:"category_counts"`
        EntityCounts    map[string]int         `json:"entity_counts"`
        ActionCounts    map[string]int         `json:"action_counts"`
        UserCounts      map[string]int         `json:"user_count"`
        SeverityCounts  map[string]int         `json:"severity_counts"`
        ImpactCounts    map[string]int         `json:"impact_counts"`
        SuccessRate     float64                `json:"success_rate"`
        ErrorRate       float64                `json:"error_rate"`
        AverageDuration time.Duration          `json:"average_duration"`
        TotalDuration   time.Duration          `json:"total_duration"`
        Events          []AuditEvent           `json:"events"`
        Summary         AuditSummary           `json:"summary"`
        Trends          AuditTrends            `json:"trends"`
        Anomalies       []AuditAnomaly         `json:"anomalies"`
        Recommendations []AuditRecommendation  `json:"recommendations"`
        Metadata        map[string]interface{} `json:"metadata,omitempty"`
}

// AuditSummary represents a summary of audit activities
type AuditSummary struct {
        TotalEvents          int           `json:"total_events"`
        SuccessfulEvents     int           `json:"successful_events"`
        FailedEvents         int           `json:"failed_events"`
        UniqueUsers          int           `json:"unique_users"`
        UniqueEntities       int           `json:"unique_entities"`
        MostActiveUser       string        `json:"most_active_user"`
        MostActiveEntity     string        `json:"most_active_entity"`
        MostCommonAction     string        `json:"most_common_action"`
        MostCommonEventType  string        `json:"most_common_event_type"`
        AverageEventsPerDay  float64       `json:"average_events_per_day"`
        PeakActivityTime     time.Time     `json:"peak_activity_time"`
        LowestActivityTime   time.Time     `json:"lowest_activity_time"`
        CriticalEvents       int           `json:"critical_events"`
        HighImpactEvents     int           `json:"high_impact_events"`
        AverageEventDuration time.Duration `json:"average_event_duration"`
        TotalEventDuration   time.Duration `json:"total_event_duration"`
}

// AuditTrends represents trends in audit activities
type AuditTrends struct {
        EventTrend          []AuditTrendPoint `json:"event_trend"`
        UserActivityTrend   []AuditTrendPoint `json:"user_activity_trend"`
        EntityActivityTrend []AuditTrendPoint `json:"entity_activity_trend"`
        ActionTrend         []AuditTrendPoint `json:"action_trend"`
        CategoryTrend       []AuditTrendPoint `json:"category_trend"`
        SeverityTrend       []AuditTrendPoint `json:"severity_trend"`
        ImpactTrend         []AuditTrendPoint `json:"impact_trend"`
        SuccessRateTrend    []AuditTrendPoint `json:"success_rate_trend"`
        DurationTrend       []AuditTrendPoint `json:"duration_trend"`
        PeakActivityPeriods []ActivityPeriod  `json:"peak_activity_periods"`
        LowActivityPeriods  []ActivityPeriod  `json:"low_activity_periods"`
}

// AuditTrendPoint represents a point in audit trend data
type AuditTrendPoint struct {
        Date          time.Time `json:"date"`
        Value         float64   `json:"value"`
        Count         int       `json:"count"`
        Percentage    float64   `json:"percentage"`
        Trend         string    `json:"trend"` // "increasing", "stable", "decreasing"
        TrendStrength float64   `json:"trend_strength"`
}

// ActivityPeriod represents a period of activity
type ActivityPeriod struct {
        StartTime            time.Time     `json:"start_time"`
        EndTime              time.Time     `json:"end_time"`
        Duration             time.Duration `json:"duration"`
        EventCount           int           `json:"event_count"`
        AverageEventsPerHour float64       `json:"average_events_per_hour"`
        PeakEventsPerHour    int           `json:"peak_events_per_hour"`
        UniqueUsers          int           `json:"unique_users"`
        MostActiveUser       string        `json:"most_active_user"`
        MostActiveEntity     string        `json:"most_active_entity"`
}

// AuditAnomaly represents an anomaly in audit activities
type AuditAnomaly struct {
        ID               string      `json:"id"`
        Type             string      `json:"type"`     // "unusual_activity", "failed_events", "critical_events", "user_anomaly", "entity_anomaly", "time_anomaly"
        Severity         string      `json:"severity"` // "low", "medium", "high", "critical"
        Description      string      `json:"description"`
        DetectedAt       time.Time   `json:"detected_at"`
        TimeRange        TimeRange   `json:"time_range"`
        EventCount       int         `json:"event_count"`
        AffectedUsers    []string    `json:"affected_users"`
        AffectedEntities []string    `json:"affected_entities"`
        Pattern          string      `json:"pattern"`
        ExpectedValue    interface{} `json:"expected_value"`
        ActualValue      interface{} `json:"actual_value"`
        Deviation        float64     `json:"deviation"`
        Confidence       float64     `json:"confidence"`
        Recommendation   string      `json:"recommendation"`
        Status           string      `json:"status"` // "open", "investigating", "resolved", "false_positive"
        InvestigatedBy   string      `json:"investigated_by,omitempty"`
        InvestigatedAt   *time.Time  `json:"investigated_at,omitempty"`
        Resolution       string      `json:"resolution,omitempty"`
        ResolvedAt       *time.Time  `json:"resolved_at,omitempty"`
        ResolvedBy       string      `json:"resolved_by,omitempty"`
}

// TimeRange represents a time range
type TimeRange struct {
        StartTime time.Time     `json:"start_time"`
        EndTime   time.Time     `json:"end_time"`
        Duration  time.Duration `json:"duration"`
}

// AuditRecommendation represents a recommendation based on audit analysis
type AuditRecommendation struct {
        ID               string    `json:"id"`
        Type             string    `json:"type"`     // "security", "compliance", "performance", "monitoring", "investigation"
        Priority         string    `json:"priority"` // "low", "medium", "high", "critical"
        Title            string    `json:"title"`
        Description      string    `json:"description"`
        Action           string    `json:"action"`
        Impact           string    `json:"impact"`
        Effort           string    `json:"effort"`
        Timeline         string    `json:"timeline"`
        Evidence         []string  `json:"evidence"`
        RelatedAnomalies []string  `json:"related_anomalies"`
        ExpectedOutcome  string    `json:"expected_outcome"`
        AssignedTo       string    `json:"assigned_to"`
        Status           string    `json:"status"` // "open", "in_progress", "completed", "rejected"
        CreatedAt        time.Time `json:"created_at"`
        UpdatedAt        time.Time `json:"updated_at"`
}

// AuditMetrics represents audit-related metrics
type AuditMetrics struct {
        BusinessID      string         `json:"business_id"`
        TotalEvents     int            `json:"total_events"`
        EventCounts     map[string]int `json:"event_counts"`
        CategoryCounts  map[string]int `json:"category_counts"`
        EntityCounts    map[string]int `json:"entity_counts"`
        ActionCounts    map[string]int `json:"action_counts"`
        UserCounts      map[string]int `json:"user_counts"`
        SeverityCounts  map[string]int `json:"severity_counts"`
        ImpactCounts    map[string]int `json:"impact_counts"`
        SuccessRate     float64        `json:"success_rate"`
        ErrorRate       float64        `json:"error_rate"`
        AverageDuration time.Duration  `json:"average_duration"`
        TotalDuration   time.Duration  `json:"total_duration"`
        TrendData       []TrendPoint   `json:"trend_data"`
        AnomalyCount    int            `json:"anomaly_count"`
        LastCalculated  time.Time      `json:"last_calculated"`
}

// AuditFilter represents audit filtering criteria
type AuditFilter struct {
        BusinessID      string        `json:"business_id"`
        EventTypes      []string      `json:"event_types"`
        EventCategories []string      `json:"event_categories"`
        EntityTypes     []string      `json:"entity_types"`
        EntityIDs       []string      `json:"entity_ids"`
        Actions         []AuditAction `json:"actions"`
        UserIDs         []string      `json:"user_ids"`
        UserRoles       []string      `json:"user_roles"`
        Severities      []string      `json:"severities"`
        Impacts         []string      `json:"impacts"`
        Success         *bool         `json:"success"`
        StartDate       *time.Time    `json:"start_date"`
        EndDate         *time.Time    `json:"end_date"`
        Tags            []string      `json:"tags"`
        Limit           int           `json:"limit"`
        Offset          int           `json:"offset"`
        SortBy          string        `json:"sort_by"`
        SortOrder       string        `json:"sort_order"`
}

// NewComplianceAuditSystem creates a new compliance audit system
func NewComplianceAuditSystem(logger *observability.Logger) *ComplianceAuditSystem <span class="cov0" title="0">{
        return &amp;ComplianceAuditSystem{
                logger:       logger,
                auditTrails:  make(map[string][]ComplianceAuditTrail),
                auditEvents:  make(map[string][]AuditEvent),
                auditReports: make(map[string]*AuditReport),
                auditMetrics: make(map[string]*AuditMetrics),
                auditFilters: make(map[string]*AuditFilter),
        }
}</span>

// RecordAuditEvent records a compliance audit event
func (s *ComplianceAuditSystem) RecordAuditEvent(ctx context.Context, event *AuditEvent) error <span class="cov0" title="0">{
        requestID := ""
        if ctx.Value("request_id") != nil </span><span class="cov0" title="0">{
                requestID = ctx.Value("request_id").(string)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Recording compliance audit event",
                "request_id", requestID,
                "business_id", event.BusinessID,
                "event_type", event.EventType,
                "event_category", event.EventCategory,
                "entity_type", event.EntityType,
                "entity_id", event.EntityID,
                "action", event.Action,
                "user_id", event.UserID,
                "severity", event.Severity,
                "impact", event.Impact,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        // Generate event ID if not provided
        if event.ID == "" </span><span class="cov0" title="0">{
                event.ID = fmt.Sprintf("audit_event_%s_%d", event.BusinessID, time.Now().UnixNano())
        }</span>

        // Set timestamp if not provided
        <span class="cov0" title="0">if event.Timestamp.IsZero() </span><span class="cov0" title="0">{
                event.Timestamp = time.Now()
        }</span>

        // Add to audit events
        <span class="cov0" title="0">s.auditEvents[event.BusinessID] = append(s.auditEvents[event.BusinessID], *event)

        // Create audit trail entry
        auditTrail := ComplianceAuditTrail{
                ID:            fmt.Sprintf("audit_trail_%s_%d", event.BusinessID, time.Now().UnixNano()),
                BusinessID:    event.BusinessID,
                Framework:     event.EntityType, // Use entity type as framework for now
                RequirementID: &amp;event.EntityID,
                Action:        event.Action,
                Description:   event.Description,
                UserID:        event.UserID,
                UserName:      event.UserName,
                UserRole:      event.UserRole,
                Timestamp:     event.Timestamp,
                IPAddress:     event.IPAddress,
                UserAgent:     event.UserAgent,
                SessionID:     event.SessionID,
                RequestID:     event.RequestID,
                OldValue:      fmt.Sprintf("%v", event.OldValue),
                NewValue:      fmt.Sprintf("%v", event.NewValue),
        }

        s.auditTrails[event.BusinessID] = append(s.auditTrails[event.BusinessID], auditTrail)

        s.logger.Info("Compliance audit event recorded successfully",
                "request_id", requestID,
                "business_id", event.BusinessID,
                "event_id", event.ID,
                "event_type", event.EventType,
                "severity", event.Severity,
                "impact", event.Impact,
        )

        return nil</span>
}

// GetAuditEvents gets audit events for a business with optional filtering
func (s *ComplianceAuditSystem) GetAuditEvents(ctx context.Context, businessID string, filter *AuditFilter) ([]AuditEvent, error) <span class="cov0" title="0">{
        requestID := ""
        if ctx.Value("request_id") != nil </span><span class="cov0" title="0">{
                requestID = ctx.Value("request_id").(string)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Getting audit events",
                "request_id", requestID,
                "business_id", businessID,
                "filter", filter,
        )

        s.mu.RLock()
        defer s.mu.RUnlock()

        events, exists := s.auditEvents[businessID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no audit events found for business %s", businessID)
        }</span>

        <span class="cov0" title="0">if filter == nil </span><span class="cov0" title="0">{
                return events, nil
        }</span>

        <span class="cov0" title="0">var filteredEvents []AuditEvent
        for _, event := range events </span><span class="cov0" title="0">{
                if s.matchesFilter(&amp;event, filter) </span><span class="cov0" title="0">{
                        filteredEvents = append(filteredEvents, event)
                }</span>
        }

        // Apply sorting
        <span class="cov0" title="0">if filter.SortBy != "" </span><span class="cov0" title="0">{
                s.sortEvents(filteredEvents, filter.SortBy, filter.SortOrder)
        }</span>

        // Apply pagination
        <span class="cov0" title="0">if filter.Limit &gt; 0 </span><span class="cov0" title="0">{
                start := filter.Offset
                end := start + filter.Limit
                if start &gt;= len(filteredEvents) </span><span class="cov0" title="0">{
                        return []AuditEvent{}, nil
                }</span>
                <span class="cov0" title="0">if end &gt; len(filteredEvents) </span><span class="cov0" title="0">{
                        end = len(filteredEvents)
                }</span>
                <span class="cov0" title="0">filteredEvents = filteredEvents[start:end]</span>
        }

        <span class="cov0" title="0">return filteredEvents, nil</span>
}

// GetAuditTrail gets the audit trail for a business
func (s *ComplianceAuditSystem) GetAuditTrail(ctx context.Context, businessID string, startDate, endDate time.Time) ([]ComplianceAuditTrail, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Getting audit trail",
                "request_id", requestID,
                "business_id", businessID,
                "start_date", startDate,
                "end_date", endDate,
        )

        s.mu.RLock()
        defer s.mu.RUnlock()

        trails, exists := s.auditTrails[businessID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no audit trail found for business %s", businessID)
        }</span>

        <span class="cov0" title="0">var filteredTrails []ComplianceAuditTrail
        for _, trail := range trails </span><span class="cov0" title="0">{
                if trail.Timestamp.After(startDate) &amp;&amp; trail.Timestamp.Before(endDate) </span><span class="cov0" title="0">{
                        filteredTrails = append(filteredTrails, trail)
                }</span>
        }

        <span class="cov0" title="0">return filteredTrails, nil</span>
}

// GenerateAuditReport generates a comprehensive audit report
func (s *ComplianceAuditSystem) GenerateAuditReport(ctx context.Context, businessID string, reportType string, startDate, endDate time.Time) (*AuditReport, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Generating audit report",
                "request_id", requestID,
                "business_id", businessID,
                "report_type", reportType,
                "start_date", startDate,
                "end_date", endDate,
        )

        s.mu.RLock()
        defer s.mu.RUnlock()

        events, exists := s.auditEvents[businessID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no audit events found for business %s", businessID)
        }</span>

        // Filter events by date range
        <span class="cov0" title="0">var filteredEvents []AuditEvent
        for _, event := range events </span><span class="cov0" title="0">{
                if event.Timestamp.After(startDate) &amp;&amp; event.Timestamp.Before(endDate) </span><span class="cov0" title="0">{
                        filteredEvents = append(filteredEvents, event)
                }</span>
        }

        <span class="cov0" title="0">report := &amp;AuditReport{
                ID:          fmt.Sprintf("audit_report_%s_%d", businessID, time.Now().Unix()),
                BusinessID:  businessID,
                ReportType:  reportType,
                GeneratedAt: time.Now(),
                GeneratedBy: "system",
                Period:      fmt.Sprintf("%s_to_%s", startDate.Format("2006-01-02"), endDate.Format("2006-01-02")),
                StartDate:   startDate,
                EndDate:     endDate,
                TotalEvents: len(filteredEvents),
                Events:      filteredEvents,
        }

        // Calculate metrics
        s.calculateAuditMetrics(report, filteredEvents)

        // Generate summary
        report.Summary = s.generateAuditSummary(filteredEvents)

        // Generate trends
        report.Trends = s.generateAuditTrends(filteredEvents, startDate, endDate)

        // Detect anomalies
        report.Anomalies = s.detectAuditAnomalies(filteredEvents)

        // Generate recommendations
        report.Recommendations = s.generateAuditRecommendations(report)

        s.auditReports[businessID] = report

        s.logger.Info("Audit report generated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "report_type", reportType,
                "total_events", report.TotalEvents,
                "anomaly_count", len(report.Anomalies),
                "recommendation_count", len(report.Recommendations),
        )

        return report, nil</span>
}

// GetAuditMetrics gets audit metrics for a business
func (s *ComplianceAuditSystem) GetAuditMetrics(ctx context.Context, businessID string) (*AuditMetrics, error) <span class="cov0" title="0">{
        requestID := ""
        if ctx.Value("request_id") != nil </span><span class="cov0" title="0">{
                requestID = ctx.Value("request_id").(string)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Getting audit metrics",
                "request_id", requestID,
                "business_id", businessID,
        )

        s.mu.RLock()
        defer s.mu.RUnlock()

        metrics, exists := s.auditMetrics[businessID]
        if !exists </span><span class="cov0" title="0">{
                // Return empty metrics instead of error
                return &amp;AuditMetrics{
                        BusinessID:      businessID,
                        TotalEvents:     0,
                        EventCounts:     make(map[string]int),
                        CategoryCounts:  make(map[string]int),
                        EntityCounts:    make(map[string]int),
                        ActionCounts:    make(map[string]int),
                        UserCounts:      make(map[string]int),
                        SeverityCounts:  make(map[string]int),
                        ImpactCounts:    make(map[string]int),
                        SuccessRate:     0.0,
                        ErrorRate:       0.0,
                        AverageDuration: 0,
                        TotalDuration:   0,
                        TrendData:       make([]TrendPoint, 0),
                        AnomalyCount:    0,
                        LastCalculated:  time.Now(),
                }, nil
        }</span>

        <span class="cov0" title="0">return metrics, nil</span>
}

// UpdateAuditMetrics updates audit metrics for a business
func (s *ComplianceAuditSystem) UpdateAuditMetrics(ctx context.Context, businessID string) error <span class="cov0" title="0">{
        requestID := ""
        if ctx.Value("request_id") != nil </span><span class="cov0" title="0">{
                requestID = ctx.Value("request_id").(string)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Updating audit metrics",
                "request_id", requestID,
                "business_id", businessID,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        events, exists := s.auditEvents[businessID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("no audit events found for business %s", businessID)
        }</span>

        <span class="cov0" title="0">metrics := &amp;AuditMetrics{
                BusinessID:     businessID,
                TotalEvents:    len(events),
                EventCounts:    make(map[string]int),
                CategoryCounts: make(map[string]int),
                EntityCounts:   make(map[string]int),
                ActionCounts:   make(map[string]int),
                UserCounts:     make(map[string]int),
                SeverityCounts: make(map[string]int),
                ImpactCounts:   make(map[string]int),
                LastCalculated: time.Now(),
        }

        successCount := 0
        totalDuration := time.Duration(0)

        for _, event := range events </span><span class="cov0" title="0">{
                // Count by event type
                metrics.EventCounts[event.EventType]++

                // Count by category
                metrics.CategoryCounts[event.EventCategory]++

                // Count by entity type
                metrics.EntityCounts[event.EntityType]++

                // Count by action
                metrics.ActionCounts[string(event.Action)]++

                // Count by user
                metrics.UserCounts[event.UserID]++

                // Count by severity
                metrics.SeverityCounts[event.Severity]++

                // Count by impact
                metrics.ImpactCounts[event.Impact]++

                // Calculate success rate
                if event.Success </span><span class="cov0" title="0">{
                        successCount++
                }</span>

                // Calculate total duration
                <span class="cov0" title="0">totalDuration += event.Duration</span>
        }

        // Calculate rates
        <span class="cov0" title="0">if metrics.TotalEvents &gt; 0 </span><span class="cov0" title="0">{
                metrics.SuccessRate = float64(successCount) / float64(metrics.TotalEvents) * 100.0
                metrics.ErrorRate = 100.0 - metrics.SuccessRate
                metrics.AverageDuration = totalDuration / time.Duration(metrics.TotalEvents)
                metrics.TotalDuration = totalDuration
        }</span>

        <span class="cov0" title="0">s.auditMetrics[businessID] = metrics

        s.logger.Info("Audit metrics updated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "total_events", metrics.TotalEvents,
                "success_rate", metrics.SuccessRate,
                "error_rate", metrics.ErrorRate,
        )

        return nil</span>
}

// Helper methods
func (s *ComplianceAuditSystem) matchesFilter(event *AuditEvent, filter *AuditFilter) bool <span class="cov0" title="0">{
        // Event type filter
        if len(filter.EventTypes) &gt; 0 </span><span class="cov0" title="0">{
                found := false
                for _, eventType := range filter.EventTypes </span><span class="cov0" title="0">{
                        if event.EventType == eventType </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Event category filter
        <span class="cov0" title="0">if len(filter.EventCategories) &gt; 0 </span><span class="cov0" title="0">{
                found := false
                for _, category := range filter.EventCategories </span><span class="cov0" title="0">{
                        if event.EventCategory == category </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Entity type filter
        <span class="cov0" title="0">if len(filter.EntityTypes) &gt; 0 </span><span class="cov0" title="0">{
                found := false
                for _, entityType := range filter.EntityTypes </span><span class="cov0" title="0">{
                        if event.EntityType == entityType </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Entity ID filter
        <span class="cov0" title="0">if len(filter.EntityIDs) &gt; 0 </span><span class="cov0" title="0">{
                found := false
                for _, entityID := range filter.EntityIDs </span><span class="cov0" title="0">{
                        if event.EntityID == entityID </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Action filter
        <span class="cov0" title="0">if len(filter.Actions) &gt; 0 </span><span class="cov0" title="0">{
                found := false
                for _, action := range filter.Actions </span><span class="cov0" title="0">{
                        if event.Action == action </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // User ID filter
        <span class="cov0" title="0">if len(filter.UserIDs) &gt; 0 </span><span class="cov0" title="0">{
                found := false
                for _, userID := range filter.UserIDs </span><span class="cov0" title="0">{
                        if event.UserID == userID </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // User role filter
        <span class="cov0" title="0">if len(filter.UserRoles) &gt; 0 </span><span class="cov0" title="0">{
                found := false
                for _, role := range filter.UserRoles </span><span class="cov0" title="0">{
                        if event.UserRole == role </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Severity filter
        <span class="cov0" title="0">if len(filter.Severities) &gt; 0 </span><span class="cov0" title="0">{
                found := false
                for _, severity := range filter.Severities </span><span class="cov0" title="0">{
                        if event.Severity == severity </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Impact filter
        <span class="cov0" title="0">if len(filter.Impacts) &gt; 0 </span><span class="cov0" title="0">{
                found := false
                for _, impact := range filter.Impacts </span><span class="cov0" title="0">{
                        if event.Impact == impact </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Success filter
        <span class="cov0" title="0">if filter.Success != nil </span><span class="cov0" title="0">{
                if event.Success != *filter.Success </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Date range filter
        <span class="cov0" title="0">if filter.StartDate != nil &amp;&amp; event.Timestamp.Before(*filter.StartDate) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if filter.EndDate != nil &amp;&amp; event.Timestamp.After(*filter.EndDate) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Tags filter
        <span class="cov0" title="0">if len(filter.Tags) &gt; 0 </span><span class="cov0" title="0">{
                found := false
                for _, tag := range filter.Tags </span><span class="cov0" title="0">{
                        for _, eventTag := range event.Tags </span><span class="cov0" title="0">{
                                if eventTag == tag </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func (s *ComplianceAuditSystem) sortEvents(events []AuditEvent, sortBy, sortOrder string) <span class="cov0" title="0">{
        // Simple sorting implementation
        // In a real implementation, this would use a more sophisticated sorting algorithm
        switch sortBy </span>{
        case "timestamp":<span class="cov0" title="0">
                if sortOrder == "desc" </span><span class="cov0" title="0">{
                        // Sort by timestamp descending
                        for i := 0; i &lt; len(events)-1; i++ </span><span class="cov0" title="0">{
                                for j := i + 1; j &lt; len(events); j++ </span><span class="cov0" title="0">{
                                        if events[i].Timestamp.Before(events[j].Timestamp) </span><span class="cov0" title="0">{
                                                events[i], events[j] = events[j], events[i]
                                        }</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        // Sort by timestamp ascending
                        for i := 0; i &lt; len(events)-1; i++ </span><span class="cov0" title="0">{
                                for j := i + 1; j &lt; len(events); j++ </span><span class="cov0" title="0">{
                                        if events[i].Timestamp.After(events[j].Timestamp) </span><span class="cov0" title="0">{
                                                events[i], events[j] = events[j], events[i]
                                        }</span>
                                }
                        }
                }
        }
}

func (s *ComplianceAuditSystem) calculateAuditMetrics(report *AuditReport, events []AuditEvent) <span class="cov0" title="0">{
        report.EventCounts = make(map[string]int)
        report.CategoryCounts = make(map[string]int)
        report.EntityCounts = make(map[string]int)
        report.ActionCounts = make(map[string]int)
        report.UserCounts = make(map[string]int)
        report.SeverityCounts = make(map[string]int)
        report.ImpactCounts = make(map[string]int)

        successCount := 0
        totalDuration := time.Duration(0)

        for _, event := range events </span><span class="cov0" title="0">{
                report.EventCounts[event.EventType]++
                report.CategoryCounts[event.EventCategory]++
                report.EntityCounts[event.EntityType]++
                report.ActionCounts[string(event.Action)]++
                report.UserCounts[event.UserID]++
                report.SeverityCounts[event.Severity]++
                report.ImpactCounts[event.Impact]++

                if event.Success </span><span class="cov0" title="0">{
                        successCount++
                }</span>

                <span class="cov0" title="0">totalDuration += event.Duration</span>
        }

        <span class="cov0" title="0">if len(events) &gt; 0 </span><span class="cov0" title="0">{
                report.SuccessRate = float64(successCount) / float64(len(events)) * 100.0
                report.ErrorRate = 100.0 - report.SuccessRate
                report.AverageDuration = totalDuration / time.Duration(len(events))
                report.TotalDuration = totalDuration
        }</span>
}

func (s *ComplianceAuditSystem) generateAuditSummary(events []AuditEvent) AuditSummary <span class="cov0" title="0">{
        summary := AuditSummary{
                TotalEvents: len(events),
        }

        userCounts := make(map[string]int)
        entityCounts := make(map[string]int)
        actionCounts := make(map[string]int)
        eventTypeCounts := make(map[string]int)
        successCount := 0
        totalDuration := time.Duration(0)
        criticalEvents := 0
        highImpactEvents := 0

        for _, event := range events </span><span class="cov0" title="0">{
                userCounts[event.UserID]++
                entityCounts[event.EntityID]++
                actionCounts[string(event.Action)]++
                eventTypeCounts[event.EventType]++

                if event.Success </span><span class="cov0" title="0">{
                        successCount++
                }</span>

                <span class="cov0" title="0">totalDuration += event.Duration

                if event.Severity == "critical" </span><span class="cov0" title="0">{
                        criticalEvents++
                }</span>

                <span class="cov0" title="0">if event.Impact == "high" || event.Impact == "critical" </span><span class="cov0" title="0">{
                        highImpactEvents++
                }</span>
        }

        <span class="cov0" title="0">summary.SuccessfulEvents = successCount
        summary.FailedEvents = len(events) - successCount
        summary.UniqueUsers = len(userCounts)
        summary.UniqueEntities = len(entityCounts)
        summary.CriticalEvents = criticalEvents
        summary.HighImpactEvents = highImpactEvents
        summary.TotalEventDuration = totalDuration

        if len(events) &gt; 0 </span><span class="cov0" title="0">{
                summary.AverageEventDuration = totalDuration / time.Duration(len(events))
                summary.AverageEventsPerDay = float64(len(events)) / 30.0 // Assuming 30 days
        }</span>

        // Find most active user
        <span class="cov0" title="0">maxUserCount := 0
        for userID, count := range userCounts </span><span class="cov0" title="0">{
                if count &gt; maxUserCount </span><span class="cov0" title="0">{
                        maxUserCount = count
                        summary.MostActiveUser = userID
                }</span>
        }

        // Find most active entity
        <span class="cov0" title="0">maxEntityCount := 0
        for entityID, count := range entityCounts </span><span class="cov0" title="0">{
                if count &gt; maxEntityCount </span><span class="cov0" title="0">{
                        maxEntityCount = count
                        summary.MostActiveEntity = entityID
                }</span>
        }

        // Find most common action
        <span class="cov0" title="0">maxActionCount := 0
        for action, count := range actionCounts </span><span class="cov0" title="0">{
                if count &gt; maxActionCount </span><span class="cov0" title="0">{
                        maxActionCount = count
                        summary.MostCommonAction = action
                }</span>
        }

        // Find most common event type
        <span class="cov0" title="0">maxEventTypeCount := 0
        for eventType, count := range eventTypeCounts </span><span class="cov0" title="0">{
                if count &gt; maxEventTypeCount </span><span class="cov0" title="0">{
                        maxEventTypeCount = count
                        summary.MostCommonEventType = eventType
                }</span>
        }

        <span class="cov0" title="0">return summary</span>
}

func (s *ComplianceAuditSystem) generateAuditTrends(events []AuditEvent, startDate, endDate time.Time) AuditTrends <span class="cov0" title="0">{
        trends := AuditTrends{}

        // Generate trend data for different metrics
        trends.EventTrend = s.generateTrendData(events, "event_count", startDate, endDate)
        trends.UserActivityTrend = s.generateTrendData(events, "user_activity", startDate, endDate)
        trends.EntityActivityTrend = s.generateTrendData(events, "entity_activity", startDate, endDate)
        trends.ActionTrend = s.generateTrendData(events, "action_count", startDate, endDate)
        trends.CategoryTrend = s.generateTrendData(events, "category_count", startDate, endDate)
        trends.SeverityTrend = s.generateTrendData(events, "severity_count", startDate, endDate)
        trends.ImpactTrend = s.generateTrendData(events, "impact_count", startDate, endDate)
        trends.SuccessRateTrend = s.generateTrendData(events, "success_rate", startDate, endDate)
        trends.DurationTrend = s.generateTrendData(events, "duration", startDate, endDate)

        // Generate activity periods
        trends.PeakActivityPeriods = s.generateActivityPeriods(events, "peak")
        trends.LowActivityPeriods = s.generateActivityPeriods(events, "low")

        return trends
}</span>

func (s *ComplianceAuditSystem) generateTrendData(events []AuditEvent, metric string, startDate, endDate time.Time) []AuditTrendPoint <span class="cov0" title="0">{
        var trendPoints []AuditTrendPoint

        // Simple trend generation - in a real implementation, this would be more sophisticated
        duration := endDate.Sub(startDate)
        days := int(duration.Hours() / 24)

        for i := 0; i &lt; days; i++ </span><span class="cov0" title="0">{
                date := startDate.AddDate(0, 0, i)
                count := 0
                value := 0.0

                for _, event := range events </span><span class="cov0" title="0">{
                        if event.Timestamp.Year() == date.Year() &amp;&amp;
                                event.Timestamp.YearDay() == date.YearDay() </span><span class="cov0" title="0">{
                                count++
                                switch metric </span>{
                                case "event_count":<span class="cov0" title="0">
                                        value = float64(count)</span>
                                case "user_activity":<span class="cov0" title="0">
                                        value = float64(count)</span> // Simplified
                                case "entity_activity":<span class="cov0" title="0">
                                        value = float64(count)</span> // Simplified
                                case "action_count":<span class="cov0" title="0">
                                        value = float64(count)</span> // Simplified
                                case "category_count":<span class="cov0" title="0">
                                        value = float64(count)</span> // Simplified
                                case "severity_count":<span class="cov0" title="0">
                                        value = float64(count)</span> // Simplified
                                case "impact_count":<span class="cov0" title="0">
                                        value = float64(count)</span> // Simplified
                                case "success_rate":<span class="cov0" title="0">
                                        value = 85.0</span> // Simplified
                                case "duration":<span class="cov0" title="0">
                                        value = 100.0</span> // Simplified
                                }
                        }
                }

                <span class="cov0" title="0">trendPoint := AuditTrendPoint{
                        Date:          date,
                        Value:         value,
                        Count:         count,
                        Percentage:    float64(count) / float64(len(events)) * 100.0,
                        Trend:         "stable",
                        TrendStrength: 0.5,
                }

                trendPoints = append(trendPoints, trendPoint)</span>
        }

        <span class="cov0" title="0">return trendPoints</span>
}

func (s *ComplianceAuditSystem) generateActivityPeriods(events []AuditEvent, periodType string) []ActivityPeriod <span class="cov0" title="0">{
        var periods []ActivityPeriod

        // Simple activity period generation - in a real implementation, this would be more sophisticated
        if len(events) &gt; 0 </span><span class="cov0" title="0">{
                period := ActivityPeriod{
                        StartTime:            events[0].Timestamp,
                        EndTime:              events[len(events)-1].Timestamp,
                        Duration:             events[len(events)-1].Timestamp.Sub(events[0].Timestamp),
                        EventCount:           len(events),
                        AverageEventsPerHour: float64(len(events)) / 24.0, // Simplified
                        PeakEventsPerHour:    len(events),                 // Simplified
                        UniqueUsers:          1,                           // Simplified
                        MostActiveUser:       events[0].UserID,
                        MostActiveEntity:     events[0].EntityID,
                }

                periods = append(periods, period)
        }</span>

        <span class="cov0" title="0">return periods</span>
}

func (s *ComplianceAuditSystem) detectAuditAnomalies(events []AuditEvent) []AuditAnomaly <span class="cov0" title="0">{
        var anomalies []AuditAnomaly

        // Simple anomaly detection - in a real implementation, this would use more sophisticated algorithms
        if len(events) &gt; 10 </span><span class="cov0" title="0">{
                // Detect unusual activity patterns
                anomaly := AuditAnomaly{
                        ID:             fmt.Sprintf("anomaly_%d", time.Now().UnixNano()),
                        Type:           "unusual_activity",
                        Severity:       "medium",
                        Description:    "Detected unusual activity pattern in audit events",
                        DetectedAt:     time.Now(),
                        EventCount:     len(events),
                        Pattern:        "high_event_count",
                        ExpectedValue:  5,
                        ActualValue:    len(events),
                        Deviation:      float64(len(events)) - 5.0,
                        Confidence:     0.75,
                        Recommendation: "Review recent audit events for unusual patterns",
                        Status:         "open",
                }

                anomalies = append(anomalies, anomaly)
        }</span>

        <span class="cov0" title="0">return anomalies</span>
}

func (s *ComplianceAuditSystem) generateAuditRecommendations(report *AuditReport) []AuditRecommendation <span class="cov0" title="0">{
        var recommendations []AuditRecommendation

        // Generate recommendations based on audit analysis
        if report.SuccessRate &lt; 90.0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, AuditRecommendation{
                        ID:              fmt.Sprintf("rec_%s_low_success_rate", report.BusinessID),
                        Type:            "performance",
                        Priority:        "high",
                        Title:           "Low Audit Success Rate",
                        Description:     fmt.Sprintf("Audit success rate is %.1f%%, below the target of 90%%", report.SuccessRate),
                        Action:          "Investigate failed audit events and improve error handling",
                        Impact:          "High - Improves audit reliability",
                        Effort:          "Medium - Requires investigation and fixes",
                        Timeline:        "1-2 weeks",
                        Evidence:        []string{"Low success rate in audit events"},
                        ExpectedOutcome: "Improved audit success rate",
                        Status:          "open",
                        CreatedAt:       time.Now(),
                        UpdatedAt:       time.Now(),
                })
        }</span>

        <span class="cov0" title="0">if len(report.Anomalies) &gt; 0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, AuditRecommendation{
                        ID:              fmt.Sprintf("rec_%s_anomalies_detected", report.BusinessID),
                        Type:            "security",
                        Priority:        "high",
                        Title:           "Audit Anomalies Detected",
                        Description:     fmt.Sprintf("Detected %d anomalies in audit events", len(report.Anomalies)),
                        Action:          "Investigate detected anomalies and take appropriate action",
                        Impact:          "High - Improves security posture",
                        Effort:          "High - Requires investigation and remediation",
                        Timeline:        "1-3 weeks",
                        Evidence:        []string{"Multiple anomalies detected"},
                        ExpectedOutcome: "Resolved anomalies and improved security",
                        Status:          "open",
                        CreatedAt:       time.Now(),
                        UpdatedAt:       time.Now(),
                })
        }</span>

        <span class="cov0" title="0">return recommendations</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package compliance

import (
        "context"
        "fmt"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// CheckRequest specifies what to check for a business
type CheckRequest struct {
        BusinessID string            `json:"business_id"`
        Frameworks []string          `json:"frameworks"` // if empty, check all known in tracking
        Options    EvaluationOptions `json:"options"`
}

// FrameworkCheckResult bundles a framework-level rule evaluation
type FrameworkCheckResult struct {
        FrameworkID string                `json:"framework_id"`
        Summary     ComplianceCheckResult `json:"summary"`
}

// CheckResponse is the aggregate response for a compliance check
type CheckResponse struct {
        BusinessID string                 `json:"business_id"`
        CheckedAt  time.Time              `json:"checked_at"`
        Results    []FrameworkCheckResult `json:"results"`
        Passed     int                    `json:"passed"`
        Failed     int                    `json:"failed"`
}

// CheckEngine orchestrates compliance requirement checking using the rule engine
// It depends on TrackingSystem for current state and FrameworkMappingSystem for framework definitions.
type CheckEngine struct {
        logger     *observability.Logger
        ruleEngine *RuleEngine
        tracking   *TrackingSystem
        mappings   *FrameworkMappingSystem
}

func NewCheckEngine(logger *observability.Logger, ruleEngine *RuleEngine, tracking *TrackingSystem, mappings *FrameworkMappingSystem) *CheckEngine <span class="cov0" title="0">{
        return &amp;CheckEngine{logger: logger, ruleEngine: ruleEngine, tracking: tracking, mappings: mappings}
}</span>

// Check runs compliance checks over the requested frameworks for a business
func (e *CheckEngine) Check(ctx context.Context, req CheckRequest) (*CheckResponse, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        e.logger.Info("Running compliance check",
                "request_id", requestID,
                "business_id", req.BusinessID,
                "frameworks", req.Frameworks,
        )

        if e.ruleEngine == nil || e.tracking == nil || e.mappings == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("check engine dependencies not initialized")
        }</span>

        // Determine frameworks to check based on tracking snapshot
        <span class="cov0" title="0">frameworksToCheck := req.Frameworks
        if len(frameworksToCheck) == 0 </span><span class="cov0" title="0">{
                // collect from tracking map
                summary, err := e.tracking.GetBusinessComplianceSummary(ctx, req.BusinessID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get business tracking: %w", err)
                }</span>
                <span class="cov0" title="0">for fw := range summary </span><span class="cov0" title="0">{
                        frameworksToCheck = append(frameworksToCheck, fw)
                }</span>
        }

        <span class="cov0" title="0">resp := &amp;CheckResponse{BusinessID: req.BusinessID, CheckedAt: time.Now()}

        for _, fw := range frameworksToCheck </span><span class="cov0" title="0">{
                tracking, err := e.tracking.GetComplianceTracking(ctx, req.BusinessID, fw)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("tracking missing for framework %s: %w", fw, err)
                }</span>
                <span class="cov0" title="0">frameworkDef, err := e.mappings.GetFramework(ctx, fw)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("framework definition missing for %s: %w", fw, err)
                }</span>
                <span class="cov0" title="0">summary, err := e.ruleEngine.EvaluateFramework(ctx, tracking, frameworkDef, req.Options)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed evaluating framework %s: %w", fw, err)
                }</span>
                <span class="cov0" title="0">resp.Results = append(resp.Results, FrameworkCheckResult{FrameworkID: fw, Summary: *summary})
                resp.Passed += summary.Passed
                resp.Failed += summary.Failed</span>
        }

        <span class="cov0" title="0">e.logger.Info("Compliance check completed",
                "request_id", requestID,
                "business_id", req.BusinessID,
                "framework_count", len(resp.Results),
                "passed", resp.Passed,
                "failed", resp.Failed,
        )

        return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package compliance

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// DataRetentionSystem manages the lifecycle of compliance data
type DataRetentionSystem struct {
        logger        *observability.Logger
        statusSystem  *ComplianceStatusSystem
        auditSystem   *ComplianceAuditSystem
        alertSystem   *AlertSystem
        reportService *ReportGenerationService
        policies      map[string]*RetentionPolicy
        mu            sync.RWMutex
}

// RetentionPolicy defines how long different types of compliance data should be retained
type RetentionPolicy struct {
        ID                     string                 `json:"id"`
        Name                   string                 `json:"name"`
        Description            string                 `json:"description"`
        Enabled                bool                   `json:"enabled"`
        DataTypes              []string               `json:"data_types"`                  // Types of data this policy applies to
        RetentionPeriod        time.Duration          `json:"retention_period"`            // How long to retain data
        ArchivePeriod          *time.Duration         `json:"archive_period,omitempty"`    // Optional archive period
        LegalHoldPeriod        *time.Duration         `json:"legal_hold_period,omitempty"` // Optional legal hold period
        DisposalMethod         string                 `json:"disposal_method"`             // "delete", "archive", "anonymize"
        NotificationRecipients []string               `json:"notification_recipients"`     // Who to notify before disposal
        CreatedAt              time.Time              `json:"created_at"`
        UpdatedAt              time.Time              `json:"updated_at"`
        Metadata               map[string]interface{} `json:"metadata,omitempty"`
}

// RetentionJob represents a data retention job
type RetentionJob struct {
        ID               string                 `json:"id"`
        PolicyID         string                 `json:"policy_id"`
        BusinessID       string                 `json:"business_id,omitempty"` // Optional, if applies to specific business
        DataType         string                 `json:"data_type"`
        Status           RetentionJobStatus     `json:"status"`
        RecordsProcessed int                    `json:"records_processed"`
        RecordsRetained  int                    `json:"records_retained"`
        RecordsDisposed  int                    `json:"records_disposed"`
        StartedAt        time.Time              `json:"started_at"`
        CompletedAt      *time.Time             `json:"completed_at,omitempty"`
        Error            string                 `json:"error,omitempty"`
        Metadata         map[string]interface{} `json:"metadata,omitempty"`
}

// RetentionJobStatus represents the status of a retention job
type RetentionJobStatus string

const (
        RetentionJobStatusPending   RetentionJobStatus = "pending"
        RetentionJobStatusRunning   RetentionJobStatus = "running"
        RetentionJobStatusCompleted RetentionJobStatus = "completed"
        RetentionJobStatusFailed    RetentionJobStatus = "failed"
        RetentionJobStatusCancelled RetentionJobStatus = "cancelled"
)

// DataType represents different types of compliance data
type DataType string

const (
        DataTypeAuditTrails       DataType = "audit_trails"
        DataTypeComplianceReports DataType = "compliance_reports"
        DataTypeStatusHistory     DataType = "status_history"
        DataTypeAlerts            DataType = "alerts"
        DataTypeAssessments       DataType = "assessments"
        DataTypeExceptions        DataType = "exceptions"
        DataTypeGapAnalysis       DataType = "gap_analysis"
        DataTypeRemediationPlans  DataType = "remediation_plans"
)

// RetentionAnalytics provides analytics about data retention
type RetentionAnalytics struct {
        TotalPolicies         int                    `json:"total_policies"`
        ActivePolicies        int                    `json:"active_policies"`
        TotalJobs             int                    `json:"total_jobs"`
        CompletedJobs         int                    `json:"completed_jobs"`
        FailedJobs            int                    `json:"failed_jobs"`
        TotalRecordsProcessed int                    `json:"total_records_processed"`
        TotalRecordsRetained  int                    `json:"total_records_retained"`
        TotalRecordsDisposed  int                    `json:"total_records_disposed"`
        DataByType            map[string]DataStats   `json:"data_by_type"`
        JobsByStatus          map[string]int         `json:"jobs_by_status"`
        RetentionTrends       []RetentionTrend       `json:"retention_trends"`
        GeneratedAt           time.Time              `json:"generated_at"`
        Metadata              map[string]interface{} `json:"metadata,omitempty"`
}

// DataStats provides statistics for a specific data type
type DataStats struct {
        DataType         string        `json:"data_type"`
        TotalRecords     int           `json:"total_records"`
        RetainedRecords  int           `json:"retained_records"`
        DisposedRecords  int           `json:"disposed_records"`
        OldestRecord     time.Time     `json:"oldest_record"`
        NewestRecord     time.Time     `json:"newest_record"`
        RetentionPeriod  time.Duration `json:"retention_period"`
        NextDisposalDate *time.Time    `json:"next_disposal_date,omitempty"`
}

// RetentionTrend represents retention trends over time
type RetentionTrend struct {
        Date             time.Time `json:"date"`
        RecordsProcessed int       `json:"records_processed"`
        RecordsRetained  int       `json:"records_retained"`
        RecordsDisposed  int       `json:"records_disposed"`
        JobsCompleted    int       `json:"jobs_completed"`
        JobsFailed       int       `json:"jobs_failed"`
}

// NewDataRetentionSystem creates a new compliance data retention system
func NewDataRetentionSystem(logger *observability.Logger, statusSystem *ComplianceStatusSystem, auditSystem *ComplianceAuditSystem, alertSystem *AlertSystem, reportService *ReportGenerationService) *DataRetentionSystem <span class="cov0" title="0">{
        return &amp;DataRetentionSystem{
                logger:        logger,
                statusSystem:  statusSystem,
                auditSystem:   auditSystem,
                alertSystem:   alertSystem,
                reportService: reportService,
                policies:      make(map[string]*RetentionPolicy),
        }
}</span>

// RegisterRetentionPolicy registers a new retention policy
func (s *DataRetentionSystem) RegisterRetentionPolicy(ctx context.Context, policy *RetentionPolicy) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        requestID := ""
        if ctx.Value("request_id") != nil </span><span class="cov0" title="0">{
                requestID = ctx.Value("request_id").(string)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Registering retention policy",
                "request_id", requestID,
                "policy_id", policy.ID,
                "policy_name", policy.Name,
                "data_types", policy.DataTypes,
                "retention_period", policy.RetentionPeriod,
        )

        if policy.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("policy ID is required")
        }</span>

        <span class="cov0" title="0">if policy.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("policy name is required")
        }</span>

        <span class="cov0" title="0">if len(policy.DataTypes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one data type is required")
        }</span>

        <span class="cov0" title="0">if policy.RetentionPeriod &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("retention period must be positive")
        }</span>

        <span class="cov0" title="0">policy.CreatedAt = time.Now()
        policy.UpdatedAt = time.Now()
        s.policies[policy.ID] = policy

        s.logger.Info("Retention policy registered successfully",
                "request_id", requestID,
                "policy_id", policy.ID,
        )

        return nil</span>
}

// UpdateRetentionPolicy updates an existing retention policy
func (s *DataRetentionSystem) UpdateRetentionPolicy(ctx context.Context, policyID string, updates map[string]interface{}) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        requestID := ""
        if ctx.Value("request_id") != nil </span><span class="cov0" title="0">{
                requestID = ctx.Value("request_id").(string)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Updating retention policy",
                "request_id", requestID,
                "policy_id", policyID,
        )

        policy, exists := s.policies[policyID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("retention policy not found: %s", policyID)
        }</span>

        // Update fields based on the updates map
        <span class="cov0" title="0">if name, ok := updates["name"].(string); ok &amp;&amp; name != "" </span><span class="cov0" title="0">{
                policy.Name = name
        }</span>

        <span class="cov0" title="0">if description, ok := updates["description"].(string); ok </span><span class="cov0" title="0">{
                policy.Description = description
        }</span>

        <span class="cov0" title="0">if enabled, ok := updates["enabled"].(bool); ok </span><span class="cov0" title="0">{
                policy.Enabled = enabled
        }</span>

        <span class="cov0" title="0">if dataTypes, ok := updates["data_types"].([]string); ok &amp;&amp; len(dataTypes) &gt; 0 </span><span class="cov0" title="0">{
                policy.DataTypes = dataTypes
        }</span>

        <span class="cov0" title="0">if retentionPeriod, ok := updates["retention_period"].(time.Duration); ok &amp;&amp; retentionPeriod &gt; 0 </span><span class="cov0" title="0">{
                policy.RetentionPeriod = retentionPeriod
        }</span>

        <span class="cov0" title="0">if archivePeriod, ok := updates["archive_period"].(*time.Duration); ok </span><span class="cov0" title="0">{
                policy.ArchivePeriod = archivePeriod
        }</span>

        <span class="cov0" title="0">if legalHoldPeriod, ok := updates["legal_hold_period"].(*time.Duration); ok </span><span class="cov0" title="0">{
                policy.LegalHoldPeriod = legalHoldPeriod
        }</span>

        <span class="cov0" title="0">if disposalMethod, ok := updates["disposal_method"].(string); ok &amp;&amp; disposalMethod != "" </span><span class="cov0" title="0">{
                policy.DisposalMethod = disposalMethod
        }</span>

        <span class="cov0" title="0">if recipients, ok := updates["notification_recipients"].([]string); ok </span><span class="cov0" title="0">{
                policy.NotificationRecipients = recipients
        }</span>

        <span class="cov0" title="0">policy.UpdatedAt = time.Now()

        s.logger.Info("Retention policy updated successfully",
                "request_id", requestID,
                "policy_id", policyID,
        )

        return nil</span>
}

// DeleteRetentionPolicy deletes a retention policy
func (s *DataRetentionSystem) DeleteRetentionPolicy(ctx context.Context, policyID string) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        requestID := ""
        if ctx.Value("request_id") != nil </span><span class="cov0" title="0">{
                requestID = ctx.Value("request_id").(string)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Deleting retention policy",
                "request_id", requestID,
                "policy_id", policyID,
        )

        if _, exists := s.policies[policyID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("retention policy not found: %s", policyID)
        }</span>

        <span class="cov0" title="0">delete(s.policies, policyID)

        s.logger.Info("Retention policy deleted successfully",
                "request_id", requestID,
                "policy_id", policyID,
        )

        return nil</span>
}

// GetRetentionPolicy retrieves a retention policy by ID
func (s *DataRetentionSystem) GetRetentionPolicy(ctx context.Context, policyID string) (*RetentionPolicy, error) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        policy, exists := s.policies[policyID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("retention policy not found: %s", policyID)
        }</span>

        <span class="cov0" title="0">return policy, nil</span>
}

// ListRetentionPolicies lists all retention policies
func (s *DataRetentionSystem) ListRetentionPolicies(ctx context.Context) ([]*RetentionPolicy, error) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        policies := make([]*RetentionPolicy, 0, len(s.policies))
        for _, policy := range s.policies </span><span class="cov0" title="0">{
                policies = append(policies, policy)
        }</span>

        <span class="cov0" title="0">return policies, nil</span>
}

// ExecuteRetentionJob executes a data retention job for a specific policy and data type
func (s *DataRetentionSystem) ExecuteRetentionJob(ctx context.Context, policyID string, dataType string, businessID string) (*RetentionJob, error) <span class="cov0" title="0">{
        requestID := ""
        if ctx.Value("request_id") != nil </span><span class="cov0" title="0">{
                requestID = ctx.Value("request_id").(string)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Executing retention job",
                "request_id", requestID,
                "policy_id", policyID,
                "data_type", dataType,
                "business_id", businessID,
        )

        policy, err := s.GetRetentionPolicy(ctx, policyID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get retention policy: %w", err)
        }</span>

        <span class="cov0" title="0">if !policy.Enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("retention policy is disabled: %s", policyID)
        }</span>

        // Check if data type is covered by this policy
        <span class="cov0" title="0">dataTypeCovered := false
        for _, dt := range policy.DataTypes </span><span class="cov0" title="0">{
                if dt == dataType </span><span class="cov0" title="0">{
                        dataTypeCovered = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !dataTypeCovered </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("data type %s is not covered by policy %s", dataType, policyID)
        }</span>

        <span class="cov0" title="0">job := &amp;RetentionJob{
                ID:         fmt.Sprintf("retention_%s_%s_%d", policyID, dataType, time.Now().Unix()),
                PolicyID:   policyID,
                BusinessID: businessID,
                DataType:   dataType,
                Status:     RetentionJobStatusRunning,
                StartedAt:  time.Now(),
        }

        // Execute the retention job based on data type
        switch DataType(dataType) </span>{
        case DataTypeAuditTrails:<span class="cov0" title="0">
                err = s.executeAuditTrailRetention(ctx, job, policy)</span>
        case DataTypeComplianceReports:<span class="cov0" title="0">
                err = s.executeComplianceReportRetention(ctx, job, policy)</span>
        case DataTypeStatusHistory:<span class="cov0" title="0">
                err = s.executeStatusHistoryRetention(ctx, job, policy)</span>
        case DataTypeAlerts:<span class="cov0" title="0">
                err = s.executeAlertRetention(ctx, job, policy)</span>
        case DataTypeAssessments:<span class="cov0" title="0">
                err = s.executeAssessmentRetention(ctx, job, policy)</span>
        case DataTypeExceptions:<span class="cov0" title="0">
                err = s.executeExceptionRetention(ctx, job, policy)</span>
        case DataTypeGapAnalysis:<span class="cov0" title="0">
                err = s.executeGapAnalysisRetention(ctx, job, policy)</span>
        case DataTypeRemediationPlans:<span class="cov0" title="0">
                err = s.executeRemediationPlanRetention(ctx, job, policy)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unsupported data type: %s", dataType)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                job.Status = RetentionJobStatusFailed
                job.Error = err.Error()
                s.logger.Error("Retention job failed",
                        "request_id", requestID,
                        "job_id", job.ID,
                        "error", err.Error(),
                )
        }</span> else<span class="cov0" title="0"> {
                job.Status = RetentionJobStatusCompleted
                completedAt := time.Now()
                job.CompletedAt = &amp;completedAt
                s.logger.Info("Retention job completed successfully",
                        "request_id", requestID,
                        "job_id", job.ID,
                        "records_processed", job.RecordsProcessed,
                        "records_retained", job.RecordsRetained,
                        "records_disposed", job.RecordsDisposed,
                )
        }</span>

        <span class="cov0" title="0">return job, err</span>
}

// executeAuditTrailRetention handles retention for audit trail data
func (s *DataRetentionSystem) executeAuditTrailRetention(ctx context.Context, job *RetentionJob, policy *RetentionPolicy) error <span class="cov0" title="0">{
        cutoffDate := time.Now().Add(-policy.RetentionPeriod)

        // Get audit events that are older than the retention period
        filter := &amp;AuditFilter{
                BusinessID: job.BusinessID,
                StartDate:  &amp;cutoffDate,
                EndDate:    &amp;time.Time{},
        }
        events, err := s.auditSystem.GetAuditEvents(ctx, job.BusinessID, filter)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get audit events: %w", err)
        }</span>

        <span class="cov0" title="0">job.RecordsProcessed = len(events)
        job.RecordsRetained = 0
        job.RecordsDisposed = 0

        // In a real implementation, you would:
        // 1. Archive old events if archive period is specified
        // 2. Delete events that exceed the retention period
        // 3. Update the job statistics accordingly

        // For now, we'll simulate the retention process
        for _, event := range events </span><span class="cov0" title="0">{
                if event.Timestamp.Before(cutoffDate) </span><span class="cov0" title="0">{
                        job.RecordsDisposed++
                }</span> else<span class="cov0" title="0"> {
                        job.RecordsRetained++
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// executeComplianceReportRetention handles retention for compliance report data
func (s *DataRetentionSystem) executeComplianceReportRetention(ctx context.Context, job *RetentionJob, policy *RetentionPolicy) error <span class="cov0" title="0">{
        // In a real implementation, you would:
        // 1. Query the database for old compliance reports
        // 2. Archive reports if archive period is specified
        // 3. Delete reports that exceed the retention period
        // 4. Update the job statistics accordingly

        // For now, we'll simulate the retention process
        job.RecordsProcessed = 50
        job.RecordsRetained = 30
        job.RecordsDisposed = 20

        return nil
}</span>

// executeStatusHistoryRetention handles retention for status history data
func (s *DataRetentionSystem) executeStatusHistoryRetention(ctx context.Context, job *RetentionJob, policy *RetentionPolicy) error <span class="cov0" title="0">{
        // In a real implementation, you would:
        // 1. Query the database for old status history records
        // 2. Archive records if archive period is specified
        // 3. Delete records that exceed the retention period
        // 4. Update the job statistics accordingly

        // For now, we'll simulate the retention process
        job.RecordsProcessed = 100
        job.RecordsRetained = 80
        job.RecordsDisposed = 20

        return nil
}</span>

// executeAlertRetention handles retention for alert data
func (s *DataRetentionSystem) executeAlertRetention(ctx context.Context, job *RetentionJob, policy *RetentionPolicy) error <span class="cov0" title="0">{
        // In a real implementation, you would:
        // 1. Query the database for old alert records
        // 2. Archive alerts if archive period is specified
        // 3. Delete alerts that exceed the retention period
        // 4. Update the job statistics accordingly

        // For now, we'll simulate the retention process
        job.RecordsProcessed = 75
        job.RecordsRetained = 60
        job.RecordsDisposed = 15

        return nil
}</span>

// executeAssessmentRetention handles retention for assessment data
func (s *DataRetentionSystem) executeAssessmentRetention(ctx context.Context, job *RetentionJob, policy *RetentionPolicy) error <span class="cov0" title="0">{
        // In a real implementation, you would:
        // 1. Query the database for old assessment records
        // 2. Archive assessments if archive period is specified
        // 3. Delete assessments that exceed the retention period
        // 4. Update the job statistics accordingly

        // For now, we'll simulate the retention process
        job.RecordsProcessed = 25
        job.RecordsRetained = 20
        job.RecordsDisposed = 5

        return nil
}</span>

// executeExceptionRetention handles retention for exception data
func (s *DataRetentionSystem) executeExceptionRetention(ctx context.Context, job *RetentionJob, policy *RetentionPolicy) error <span class="cov0" title="0">{
        // In a real implementation, you would:
        // 1. Query the database for old exception records
        // 2. Archive exceptions if archive period is specified
        // 3. Delete exceptions that exceed the retention period
        // 4. Update the job statistics accordingly

        // For now, we'll simulate the retention process
        job.RecordsProcessed = 40
        job.RecordsRetained = 35
        job.RecordsDisposed = 5

        return nil
}</span>

// executeGapAnalysisRetention handles retention for gap analysis data
func (s *DataRetentionSystem) executeGapAnalysisRetention(ctx context.Context, job *RetentionJob, policy *RetentionPolicy) error <span class="cov0" title="0">{
        // In a real implementation, you would:
        // 1. Query the database for old gap analysis records
        // 2. Archive gap analysis if archive period is specified
        // 3. Delete gap analysis that exceed the retention period
        // 4. Update the job statistics accordingly

        // For now, we'll simulate the retention process
        job.RecordsProcessed = 30
        job.RecordsRetained = 25
        job.RecordsDisposed = 5

        return nil
}</span>

// executeRemediationPlanRetention handles retention for remediation plan data
func (s *DataRetentionSystem) executeRemediationPlanRetention(ctx context.Context, job *RetentionJob, policy *RetentionPolicy) error <span class="cov0" title="0">{
        // In a real implementation, you would:
        // 1. Query the database for old remediation plan records
        // 2. Archive remediation plans if archive period is specified
        // 3. Delete remediation plans that exceed the retention period
        // 4. Update the job statistics accordingly

        // For now, we'll simulate the retention process
        job.RecordsProcessed = 20
        job.RecordsRetained = 18
        job.RecordsDisposed = 2

        return nil
}</span>

// GetRetentionAnalytics provides analytics about data retention
func (s *DataRetentionSystem) GetRetentionAnalytics(ctx context.Context, period string) (*RetentionAnalytics, error) <span class="cov0" title="0">{
        requestID := ""
        if ctx.Value("request_id") != nil </span><span class="cov0" title="0">{
                requestID = ctx.Value("request_id").(string)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Getting retention analytics",
                "request_id", requestID,
                "period", period,
        )

        analytics := &amp;RetentionAnalytics{
                TotalPolicies:         len(s.policies),
                ActivePolicies:        0,
                TotalJobs:             0,
                CompletedJobs:         0,
                FailedJobs:            0,
                TotalRecordsProcessed: 0,
                TotalRecordsRetained:  0,
                TotalRecordsDisposed:  0,
                DataByType:            make(map[string]DataStats),
                JobsByStatus:          make(map[string]int),
                RetentionTrends:       []RetentionTrend{},
                GeneratedAt:           time.Now(),
        }

        // Count active policies
        for _, policy := range s.policies </span><span class="cov0" title="0">{
                if policy.Enabled </span><span class="cov0" title="0">{
                        analytics.ActivePolicies++
                }</span>
        }

        // In a real implementation, you would:
        // 1. Query the database for retention job statistics
        // 2. Calculate data statistics by type
        // 3. Generate retention trends over time
        // 4. Populate the analytics structure with real data

        // For now, we'll provide mock data
        <span class="cov0" title="0">analytics.DataByType["audit_trails"] = DataStats{
                DataType:        "audit_trails",
                TotalRecords:    1000,
                RetainedRecords: 800,
                DisposedRecords: 200,
                OldestRecord:    time.Now().Add(-365 * 24 * time.Hour),
                NewestRecord:    time.Now(),
                RetentionPeriod: 90 * 24 * time.Hour,
        }

        analytics.DataByType["compliance_reports"] = DataStats{
                DataType:        "compliance_reports",
                TotalRecords:    500,
                RetainedRecords: 450,
                DisposedRecords: 50,
                OldestRecord:    time.Now().Add(-180 * 24 * time.Hour),
                NewestRecord:    time.Now(),
                RetentionPeriod: 180 * 24 * time.Hour,
        }

        analytics.JobsByStatus["completed"] = 25
        analytics.JobsByStatus["failed"] = 2
        analytics.JobsByStatus["running"] = 1

        s.logger.Info("Retention analytics generated successfully",
                "request_id", requestID,
                "total_policies", analytics.TotalPolicies,
                "active_policies", analytics.ActivePolicies,
        )

        return analytics, nil</span>
}

// ScheduleRetentionJobs schedules retention jobs based on policies
func (s *DataRetentionSystem) ScheduleRetentionJobs(ctx context.Context) error <span class="cov0" title="0">{
        requestID := ""
        if ctx.Value("request_id") != nil </span><span class="cov0" title="0">{
                requestID = ctx.Value("request_id").(string)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Scheduling retention jobs",
                "request_id", requestID,
        )

        // In a real implementation, you would:
        // 1. Check all active retention policies
        // 2. Determine which data types need retention processing
        // 3. Schedule jobs for each policy and data type combination
        // 4. Use a job scheduler or cron-like system

        s.logger.Info("Retention jobs scheduled successfully",
                "request_id", requestID,
        )

        return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package compliance

import (
        "context"
        "encoding/csv"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// ExportSystem provides comprehensive compliance data export functionality
type ExportSystem struct {
        logger        *observability.Logger
        statusSystem  *ComplianceStatusSystem
        reportService *ReportGenerationService
        alertSystem   *AlertSystem
}

// ExportRequest represents a request to export compliance data
type ExportRequest struct {
        BusinessID     string                 `json:"business_id"`
        ExportType     ExportType             `json:"export_type"`
        Format         ExportFormat           `json:"format"`
        DateRange      *DateRange             `json:"date_range,omitempty"`
        Frameworks     []string               `json:"frameworks,omitempty"`
        IncludeDetails bool                   `json:"include_details,omitempty"`
        Filters        map[string]interface{} `json:"filters,omitempty"`
        GeneratedBy    string                 `json:"generated_by"`
        Metadata       map[string]interface{} `json:"metadata,omitempty"`
}

// ExportType represents the type of data to export
type ExportType string

const (
        ExportTypeStatus        ExportType = "status"
        ExportTypeReports       ExportType = "reports"
        ExportTypeAlerts        ExportType = "alerts"
        ExportTypeAuditTrail    ExportType = "audit_trail"
        ExportTypeRequirements  ExportType = "requirements"
        ExportTypeControls      ExportType = "controls"
        ExportTypeExceptions    ExportType = "exceptions"
        ExportTypeRemediation   ExportType = "remediation"
        ExportTypeComprehensive ExportType = "comprehensive"
)

// ExportFormat represents the export format
type ExportFormat string

const (
        ExportFormatJSON  ExportFormat = "json"
        ExportFormatCSV   ExportFormat = "csv"
        ExportFormatExcel ExportFormat = "excel"
        ExportFormatPDF   ExportFormat = "pdf"
)

// ExportResult represents the result of an export operation
type ExportResult struct {
        ID          string                 `json:"id"`
        BusinessID  string                 `json:"business_id"`
        ExportType  ExportType             `json:"export_type"`
        Format      ExportFormat           `json:"format"`
        Data        interface{}            `json:"data"`
        RecordCount int                    `json:"record_count"`
        FileSize    int64                  `json:"file_size,omitempty"`
        DownloadURL string                 `json:"download_url,omitempty"`
        GeneratedAt time.Time              `json:"generated_at"`
        GeneratedBy string                 `json:"generated_by"`
        ExpiresAt   *time.Time             `json:"expires_at,omitempty"`
        Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// NewExportSystem creates a new compliance export system
func NewExportSystem(logger *observability.Logger, statusSystem *ComplianceStatusSystem, reportService *ReportGenerationService, alertSystem *AlertSystem) *ExportSystem <span class="cov0" title="0">{
        return &amp;ExportSystem{
                logger:        logger,
                statusSystem:  statusSystem,
                reportService: reportService,
                alertSystem:   alertSystem,
        }
}</span>

// ExportData exports compliance data based on the request
func (s *ExportSystem) ExportData(ctx context.Context, request ExportRequest) (*ExportResult, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Starting compliance data export",
                "request_id", requestID,
                "business_id", request.BusinessID,
                "export_type", request.ExportType,
                "format", request.Format,
        )

        // Validate request
        if request.BusinessID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("business_id is required")
        }</span>

        <span class="cov0" title="0">if request.ExportType == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("export_type is required")
        }</span>

        <span class="cov0" title="0">if request.Format == "" </span><span class="cov0" title="0">{
                request.Format = ExportFormatJSON // Default to JSON
        }</span>

        <span class="cov0" title="0">if request.GeneratedBy == "" </span><span class="cov0" title="0">{
                request.GeneratedBy = "system"
        }</span>

        // Generate export ID
        <span class="cov0" title="0">exportID := fmt.Sprintf("export_%s_%s_%d", request.BusinessID, request.ExportType, time.Now().UnixNano())

        // Export data based on type
        var data interface{}
        var recordCount int
        var err error

        switch request.ExportType </span>{
        case ExportTypeStatus:<span class="cov0" title="0">
                data, recordCount, err = s.exportStatusData(ctx, request)</span>
        case ExportTypeReports:<span class="cov0" title="0">
                data, recordCount, err = s.exportReportData(ctx, request)</span>
        case ExportTypeAlerts:<span class="cov0" title="0">
                data, recordCount, err = s.exportAlertData(ctx, request)</span>
        case ExportTypeAuditTrail:<span class="cov0" title="0">
                data, recordCount, err = s.exportAuditTrailData(ctx, request)</span>
        case ExportTypeRequirements:<span class="cov0" title="0">
                data, recordCount, err = s.exportRequirementsData(ctx, request)</span>
        case ExportTypeControls:<span class="cov0" title="0">
                data, recordCount, err = s.exportControlsData(ctx, request)</span>
        case ExportTypeExceptions:<span class="cov0" title="0">
                data, recordCount, err = s.exportExceptionsData(ctx, request)</span>
        case ExportTypeRemediation:<span class="cov0" title="0">
                data, recordCount, err = s.exportRemediationData(ctx, request)</span>
        case ExportTypeComprehensive:<span class="cov0" title="0">
                data, recordCount, err = s.exportComprehensiveData(ctx, request)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported export type: %s", request.ExportType)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to export %s data: %w", request.ExportType, err)
        }</span>

        // Format data based on requested format
        <span class="cov0" title="0">formattedData, fileSize, err := s.formatData(data, request.Format)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to format data: %w", err)
        }</span>

        // Set expiration (24 hours from now)
        <span class="cov0" title="0">expiresAt := time.Now().Add(24 * time.Hour)

        result := &amp;ExportResult{
                ID:          exportID,
                BusinessID:  request.BusinessID,
                ExportType:  request.ExportType,
                Format:      request.Format,
                Data:        formattedData,
                RecordCount: recordCount,
                FileSize:    fileSize,
                GeneratedAt: time.Now(),
                GeneratedBy: request.GeneratedBy,
                ExpiresAt:   &amp;expiresAt,
                Metadata:    request.Metadata,
        }

        s.logger.Info("Compliance data export completed successfully",
                "request_id", requestID,
                "business_id", request.BusinessID,
                "export_type", request.ExportType,
                "format", request.Format,
                "record_count", recordCount,
                "file_size", fileSize,
        )

        return result, nil</span>
}

// exportStatusData exports compliance status data
func (s *ExportSystem) exportStatusData(ctx context.Context, request ExportRequest) (interface{}, int, error) <span class="cov0" title="0">{
        // Get compliance status
        status, err := s.statusSystem.GetComplianceStatus(ctx, request.BusinessID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get compliance status: %w", err)
        }</span>

        // Get status history if date range is specified
        <span class="cov0" title="0">var history []StatusChange
        if request.DateRange != nil </span><span class="cov0" title="0">{
                history, err = s.statusSystem.GetStatusHistory(ctx, request.BusinessID, request.DateRange.StartDate, request.DateRange.EndDate)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("failed to get status history: %w", err)
                }</span>
        }

        // Get status alerts
        <span class="cov0" title="0">alerts, err := s.statusSystem.GetStatusAlerts(ctx, request.BusinessID, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get status alerts: %w", err)
        }</span>

        <span class="cov0" title="0">exportData := map[string]interface{}{
                "business_id":    request.BusinessID,
                "export_type":    "status",
                "exported_at":    time.Now(),
                "current_status": status,
                "history":        history,
                "alerts":         alerts,
                "summary": map[string]interface{}{
                        "overall_score":     status.OverallScore,
                        "overall_status":    status.OverallStatus,
                        "risk_level":        status.RiskLevel,
                        "trend":             status.Trend,
                        "framework_count":   len(status.FrameworkStatuses),
                        "requirement_count": len(status.RequirementStatuses),
                        "control_count":     len(status.ControlStatuses),
                        "history_count":     len(history),
                        "alert_count":       len(alerts),
                },
        }

        recordCount := 1 + len(history) + len(alerts) // status + history + alerts
        return exportData, recordCount, nil</span>
}

// exportReportData exports compliance report data
func (s *ExportSystem) exportReportData(ctx context.Context, request ExportRequest) (interface{}, int, error) <span class="cov0" title="0">{
        // Generate comprehensive report
        reportRequest := ReportRequest{
                BusinessID:     request.BusinessID,
                Framework:      "", // All frameworks
                ReportType:     ReportTypeExecutive,
                Format:         ReportFormatJSON,
                DateRange:      request.DateRange,
                IncludeDetails: request.IncludeDetails,
                GeneratedBy:    request.GeneratedBy,
                Metadata:       request.Metadata,
        }

        report, err := s.reportService.GenerateComplianceReport(ctx, reportRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to generate compliance report: %w", err)
        }</span>

        <span class="cov0" title="0">exportData := map[string]interface{}{
                "business_id": request.BusinessID,
                "export_type": "reports",
                "exported_at": time.Now(),
                "report":      report,
                "summary": map[string]interface{}{
                        "report_id":         report.ID,
                        "report_type":       report.ReportType,
                        "overall_status":    report.OverallStatus,
                        "compliance_score":  report.ComplianceScore,
                        "requirement_count": len(report.Requirements),
                        "control_count":     len(report.Controls),
                        "exception_count":   len(report.Exceptions),
                        "remediation_count": len(report.RemediationPlans),
                },
        }

        recordCount := 1 + len(report.Requirements) + len(report.Controls) + len(report.Exceptions) + len(report.RemediationPlans)
        return exportData, recordCount, nil</span>
}

// exportAlertData exports alert data
func (s *ExportSystem) exportAlertData(ctx context.Context, request ExportRequest) (interface{}, int, error) <span class="cov0" title="0">{
        // Get alert analytics
        analytics, err := s.alertSystem.GetAlertAnalytics(ctx, request.BusinessID, "30d")
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get alert analytics: %w", err)
        }</span>

        // Get all alerts
        <span class="cov0" title="0">alerts, err := s.statusSystem.GetStatusAlerts(ctx, request.BusinessID, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get alerts: %w", err)
        }</span>

        // Filter alerts by date range if specified
        <span class="cov0" title="0">var filteredAlerts []StatusAlert
        if request.DateRange != nil </span><span class="cov0" title="0">{
                for _, alert := range alerts </span><span class="cov0" title="0">{
                        if alert.TriggeredAt.After(request.DateRange.StartDate) &amp;&amp; alert.TriggeredAt.Before(request.DateRange.EndDate) </span><span class="cov0" title="0">{
                                filteredAlerts = append(filteredAlerts, alert)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                filteredAlerts = alerts
        }</span>

        <span class="cov0" title="0">exportData := map[string]interface{}{
                "business_id": request.BusinessID,
                "export_type": "alerts",
                "exported_at": time.Now(),
                "analytics":   analytics,
                "alerts":      filteredAlerts,
                "summary": map[string]interface{}{
                        "total_alerts":        analytics.TotalAlerts,
                        "active_alerts":       analytics.ActiveAlerts,
                        "resolved_alerts":     analytics.ResolvedAlerts,
                        "critical_alerts":     analytics.AlertsBySeverity["critical"],
                        "high_alerts":         analytics.AlertsBySeverity["high"],
                        "medium_alerts":       analytics.AlertsBySeverity["medium"],
                        "low_alerts":          analytics.AlertsBySeverity["low"],
                        "avg_resolution_time": analytics.AverageResolutionTime.String(),
                },
        }

        recordCount := len(filteredAlerts)
        return exportData, recordCount, nil</span>
}

// exportAuditTrailData exports audit trail data
func (s *ExportSystem) exportAuditTrailData(ctx context.Context, request ExportRequest) (interface{}, int, error) <span class="cov0" title="0">{
        // This would typically query a database for audit trail data
        // For now, we'll create a placeholder structure
        auditTrail := []ComplianceAuditTrail{
                {
                        ID:          "audit_1",
                        BusinessID:  request.BusinessID,
                        Framework:   "SOC2",
                        Action:      AuditActionUpdate,
                        Description: "Compliance status updated",
                        UserID:      request.GeneratedBy,
                        UserName:    request.GeneratedBy,
                        UserRole:    "compliance_officer",
                        Timestamp:   time.Now().Add(-1 * time.Hour),
                        IPAddress:   "192.168.1.100",
                        UserAgent:   "Mozilla/5.0...",
                        SessionID:   "session_123",
                        RequestID:   ctx.Value("request_id").(string),
                        OldValue:    "not_started",
                        NewValue:    "in_progress",
                },
        }

        exportData := map[string]interface{}{
                "business_id": request.BusinessID,
                "export_type": "audit_trail",
                "exported_at": time.Now(),
                "audit_trail": auditTrail,
                "summary": map[string]interface{}{
                        "total_entries": len(auditTrail),
                        "date_range":    request.DateRange,
                },
        }

        recordCount := len(auditTrail)
        return exportData, recordCount, nil
}</span>

// exportRequirementsData exports requirements data
func (s *ExportSystem) exportRequirementsData(ctx context.Context, request ExportRequest) (interface{}, int, error) <span class="cov0" title="0">{
        // Get compliance status to extract requirements
        status, err := s.statusSystem.GetComplianceStatus(ctx, request.BusinessID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get compliance status: %w", err)
        }</span>

        // Convert requirement statuses to a more exportable format
        <span class="cov0" title="0">var requirements []map[string]interface{}
        for reqID, reqStatus := range status.RequirementStatuses </span><span class="cov0" title="0">{
                requirement := map[string]interface{}{
                        "requirement_id":         reqID,
                        "title":                  reqStatus.Title,
                        "status":                 reqStatus.Status,
                        "implementation_status":  reqStatus.ImplementationStatus,
                        "compliance_score":       reqStatus.Score,
                        "risk_level":             reqStatus.RiskLevel,
                        "priority":               reqStatus.Priority,
                        "last_reviewed":          reqStatus.LastReviewed,
                        "next_review":            reqStatus.NextReview,
                        "reviewer":               reqStatus.Reviewer,
                        "evidence_count":         reqStatus.EvidenceCount,
                        "exception_count":        reqStatus.ExceptionCount,
                        "remediation_plan_count": reqStatus.RemediationPlanCount,
                        "trend":                  reqStatus.Trend,
                        "trend_strength":         reqStatus.TrendStrength,
                }
                requirements = append(requirements, requirement)
        }</span>

        <span class="cov0" title="0">exportData := map[string]interface{}{
                "business_id":  request.BusinessID,
                "export_type":  "requirements",
                "exported_at":  time.Now(),
                "requirements": requirements,
                "summary": map[string]interface{}{
                        "total_requirements":  len(requirements),
                        "implemented_count":   countByStatus(requirements, "status", "implemented"),
                        "in_progress_count":   countByStatus(requirements, "status", "in_progress"),
                        "not_started_count":   countByStatus(requirements, "status", "not_started"),
                        "non_compliant_count": countByStatus(requirements, "status", "non_compliant"),
                },
        }

        recordCount := len(requirements)
        return exportData, recordCount, nil</span>
}

// exportControlsData exports controls data
func (s *ExportSystem) exportControlsData(ctx context.Context, request ExportRequest) (interface{}, int, error) <span class="cov0" title="0">{
        // Get compliance status to extract controls
        status, err := s.statusSystem.GetComplianceStatus(ctx, request.BusinessID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get compliance status: %w", err)
        }</span>

        // Convert control statuses to a more exportable format
        <span class="cov0" title="0">var controls []map[string]interface{}
        for controlID, controlStatus := range status.ControlStatuses </span><span class="cov0" title="0">{
                control := map[string]interface{}{
                        "control_id":            controlID,
                        "title":                 controlStatus.Title,
                        "status":                controlStatus.Status,
                        "implementation_status": controlStatus.ImplementationStatus,
                        "effectiveness":         controlStatus.Effectiveness,
                        "compliance_score":      controlStatus.Score,
                        "last_tested":           controlStatus.LastTested,
                        "next_test_date":        controlStatus.NextTestDate,
                        "test_result_count":     controlStatus.TestResultCount,
                        "pass_count":            controlStatus.PassCount,
                        "fail_count":            controlStatus.FailCount,
                        "evidence_count":        controlStatus.EvidenceCount,
                        "trend":                 controlStatus.Trend,
                        "trend_strength":        controlStatus.TrendStrength,
                }
                controls = append(controls, control)
        }</span>

        <span class="cov0" title="0">exportData := map[string]interface{}{
                "business_id": request.BusinessID,
                "export_type": "controls",
                "exported_at": time.Now(),
                "controls":    controls,
                "summary": map[string]interface{}{
                        "total_controls":    len(controls),
                        "implemented_count": countByStatus(controls, "status", "implemented"),
                        "in_progress_count": countByStatus(controls, "status", "in_progress"),
                        "not_started_count": countByStatus(controls, "status", "not_started"),
                        "effective_count":   countByStatus(controls, "effectiveness", "effective"),
                },
        }

        recordCount := len(controls)
        return exportData, recordCount, nil</span>
}

// exportExceptionsData exports exceptions data
func (s *ExportSystem) exportExceptionsData(ctx context.Context, request ExportRequest) (interface{}, int, error) <span class="cov0" title="0">{
        // This would typically query a database for exceptions data
        // For now, we'll create a placeholder structure
        exceptions := []ComplianceException{
                {
                        ID:             "exception_1",
                        RequirementID:  "req_001",
                        Type:           ExceptionTypeTemporary,
                        Reason:         "System maintenance",
                        Justification:  "Planned maintenance window",
                        RiskAssessment: "Low risk - temporary exception",
                        MitigationPlan: "Resume compliance after maintenance",
                        ApprovedBy:     "compliance_officer",
                        ApprovedAt:     time.Now().Add(-24 * time.Hour),
                        ExpiresAt:      &amp;[]time.Time{time.Now().Add(7 * 24 * time.Hour)}[0],
                        Status:         ExceptionStatusApproved,
                        Notes:          "Standard maintenance exception",
                },
        }

        exportData := map[string]interface{}{
                "business_id": request.BusinessID,
                "export_type": "exceptions",
                "exported_at": time.Now(),
                "exceptions":  exceptions,
                "summary": map[string]interface{}{
                        "total_exceptions": len(exceptions),
                        "active_count":     countByStatus(exceptions, "status", "active"),
                        "expired_count":    countByStatus(exceptions, "status", "expired"),
                },
        }

        recordCount := len(exceptions)
        return exportData, recordCount, nil
}</span>

// exportRemediationData exports remediation data
func (s *ExportSystem) exportRemediationData(ctx context.Context, request ExportRequest) (interface{}, int, error) <span class="cov0" title="0">{
        // This would typically query a database for remediation data
        // For now, we'll create a placeholder structure
        remediationPlans := []RemediationPlan{
                {
                        ID:            "remediation_1",
                        RequirementID: "req_002",
                        Title:         "Implement Access Controls",
                        Description:   "Implement proper access controls for sensitive data",
                        Priority:      CompliancePriorityHigh,
                        Status:        RemediationStatusInProgress,
                        TargetDate:    time.Now().Add(30 * 24 * time.Hour),
                        AssignedTo:    "security_team",
                        Budget:        50000.0,
                        Progress:      75.0,
                        Notes:         "On track for completion",
                },
        }

        exportData := map[string]interface{}{
                "business_id":       request.BusinessID,
                "export_type":       "remediation",
                "exported_at":       time.Now(),
                "remediation_plans": remediationPlans,
                "summary": map[string]interface{}{
                        "total_plans":       len(remediationPlans),
                        "completed_count":   countByStatus(remediationPlans, "status", "completed"),
                        "in_progress_count": countByStatus(remediationPlans, "status", "in_progress"),
                        "planned_count":     countByStatus(remediationPlans, "status", "planned"),
                },
        }

        recordCount := len(remediationPlans)
        return exportData, recordCount, nil
}</span>

// exportComprehensiveData exports all compliance data in a comprehensive format
func (s *ExportSystem) exportComprehensiveData(ctx context.Context, request ExportRequest) (interface{}, int, error) <span class="cov0" title="0">{
        // Export all data types
        statusData, _, err := s.exportStatusData(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to export status data: %w", err)
        }</span>

        <span class="cov0" title="0">reportData, _, err := s.exportReportData(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to export report data: %w", err)
        }</span>

        <span class="cov0" title="0">alertData, _, err := s.exportAlertData(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to export alert data: %w", err)
        }</span>

        <span class="cov0" title="0">requirementsData, _, err := s.exportRequirementsData(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to export requirements data: %w", err)
        }</span>

        <span class="cov0" title="0">controlsData, _, err := s.exportControlsData(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to export controls data: %w", err)
        }</span>

        <span class="cov0" title="0">comprehensiveData := map[string]interface{}{
                "business_id":  request.BusinessID,
                "export_type":  "comprehensive",
                "exported_at":  time.Now(),
                "status":       statusData,
                "reports":      reportData,
                "alerts":       alertData,
                "requirements": requirementsData,
                "controls":     controlsData,
                "export_metadata": map[string]interface{}{
                        "generated_by": request.GeneratedBy,
                        "date_range":   request.DateRange,
                        "frameworks":   request.Frameworks,
                        "filters":      request.Filters,
                },
        }

        // Calculate total record count
        totalRecords := 0
        if statusMap, ok := statusData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if summary, ok := statusMap["summary"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if count, ok := summary["history_count"].(int); ok </span><span class="cov0" title="0">{
                                totalRecords += count
                        }</span>
                        <span class="cov0" title="0">if count, ok := summary["alert_count"].(int); ok </span><span class="cov0" title="0">{
                                totalRecords += count
                        }</span>
                }
        }

        <span class="cov0" title="0">if requirementsMap, ok := requirementsData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if requirements, ok := requirementsMap["requirements"].([]map[string]interface{}); ok </span><span class="cov0" title="0">{
                        totalRecords += len(requirements)
                }</span>
        }

        <span class="cov0" title="0">if controlsMap, ok := controlsData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if controls, ok := controlsMap["controls"].([]map[string]interface{}); ok </span><span class="cov0" title="0">{
                        totalRecords += len(controls)
                }</span>
        }

        <span class="cov0" title="0">return comprehensiveData, totalRecords, nil</span>
}

// formatData formats the data according to the requested format
func (s *ExportSystem) formatData(data interface{}, format ExportFormat) (interface{}, int64, error) <span class="cov0" title="0">{
        switch format </span>{
        case ExportFormatJSON:<span class="cov0" title="0">
                return s.formatAsJSON(data)</span>
        case ExportFormatCSV:<span class="cov0" title="0">
                return s.formatAsCSV(data)</span>
        case ExportFormatExcel:<span class="cov0" title="0">
                return s.formatAsExcel(data)</span>
        case ExportFormatPDF:<span class="cov0" title="0">
                return s.formatAsPDF(data)</span>
        default:<span class="cov0" title="0">
                return nil, 0, fmt.Errorf("unsupported format: %s", format)</span>
        }
}

// formatAsJSON formats data as JSON
func (s *ExportSystem) formatAsJSON(data interface{}) (interface{}, int64, error) <span class="cov0" title="0">{
        jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to marshal JSON: %w", err)
        }</span>

        <span class="cov0" title="0">return string(jsonData), int64(len(jsonData)), nil</span>
}

// formatAsCSV formats data as CSV
func (s *ExportSystem) formatAsCSV(data interface{}) (interface{}, int64, error) <span class="cov0" title="0">{
        // Convert data to CSV format
        // This is a simplified implementation - in practice, you'd want more sophisticated CSV generation
        var csvData strings.Builder
        writer := csv.NewWriter(&amp;csvData)

        // For now, we'll create a simple CSV with key-value pairs
        if dataMap, ok := data.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                // Write header
                writer.Write([]string{"Key", "Value"})

                // Write data
                for key, value := range dataMap </span><span class="cov0" title="0">{
                        writer.Write([]string{key, fmt.Sprintf("%v", value)})
                }</span>
        }

        <span class="cov0" title="0">writer.Flush()
        if err := writer.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to write CSV: %w", err)
        }</span>

        <span class="cov0" title="0">csvString := csvData.String()
        return csvString, int64(len(csvString)), nil</span>
}

// formatAsExcel formats data as Excel
func (s *ExportSystem) formatAsExcel(data interface{}) (interface{}, int64, error) <span class="cov0" title="0">{
        // This would use a library like excelize to create Excel files
        // For now, we'll return a placeholder
        _ = "Excel format not yet implemented - returning JSON instead"
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to marshal data for Excel: %w", err)
        }</span>

        <span class="cov0" title="0">return string(jsonData), int64(len(jsonData)), nil</span>
}

// formatAsPDF formats data as PDF
func (s *ExportSystem) formatAsPDF(data interface{}) (interface{}, int64, error) <span class="cov0" title="0">{
        // This would use a library like wkhtmltopdf or similar to create PDF files
        // For now, we'll return a placeholder
        _ = "PDF format not yet implemented - returning JSON instead"
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to marshal data for PDF: %w", err)
        }</span>

        <span class="cov0" title="0">return string(jsonData), int64(len(jsonData)), nil</span>
}

// countByStatus counts items by a specific status field
func countByStatus(items interface{}, fieldName, statusValue string) int <span class="cov0" title="0">{
        count := 0

        switch v := items.(type) </span>{
        case []map[string]interface{}:<span class="cov0" title="0">
                for _, item := range v </span><span class="cov0" title="0">{
                        if status, ok := item[fieldName].(string); ok &amp;&amp; status == statusValue </span><span class="cov0" title="0">{
                                count++
                        }</span>
                }
        case []ComplianceException:<span class="cov0" title="0">
                for _, item := range v </span><span class="cov0" title="0">{
                        if fieldName == "status" &amp;&amp; string(item.Status) == statusValue </span><span class="cov0" title="0">{
                                count++
                        }</span>
                }
        case []RemediationPlan:<span class="cov0" title="0">
                for _, item := range v </span><span class="cov0" title="0">{
                        if fieldName == "status" &amp;&amp; string(item.Status) == statusValue </span><span class="cov0" title="0">{
                                count++
                        }</span>
                }
        }

        <span class="cov0" title="0">return count</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package compliance

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// FrameworkMappingSystem provides regulatory framework mapping functionality
type FrameworkMappingSystem struct {
        logger       *observability.Logger
        mu           sync.RWMutex
        frameworks   map[string]*RegulatoryFramework // frameworkID -&gt; framework
        mappings     map[string]*FrameworkMapping    // mappingID -&gt; mapping
        mappingRules map[string][]MappingRule        // frameworkID -&gt; rules
        crosswalks   map[string]*CrosswalkMapping    // crosswalkID -&gt; crosswalk
        confidence   map[string]float64              // mappingID -&gt; confidence score
}

// MappingRule represents a rule for framework mapping
type MappingRule struct {
        ID              string                 `json:"id"`
        SourceFramework string                 `json:"source_framework"`
        TargetFramework string                 `json:"target_framework"`
        RuleType        string                 `json:"rule_type"` // "exact", "partial", "related", "superseded"
        Confidence      float64                `json:"confidence"`
        Conditions      map[string]interface{} `json:"conditions"`
        Transformations map[string]interface{} `json:"transformations"`
        Notes           string                 `json:"notes"`
        CreatedAt       time.Time              `json:"created_at"`
        UpdatedAt       time.Time              `json:"updated_at"`
}

// CrosswalkMapping represents a crosswalk between frameworks
type CrosswalkMapping struct {
        ID              string                 `json:"id"`
        Name            string                 `json:"name"`
        Description     string                 `json:"description"`
        SourceFramework string                 `json:"source_framework"`
        TargetFramework string                 `json:"target_framework"`
        MappingType     MappingType            `json:"mapping_type"`
        Confidence      float64                `json:"confidence"`
        Mappings        []FrameworkMapping     `json:"mappings"`
        Metadata        map[string]interface{} `json:"metadata,omitempty"`
        CreatedAt       time.Time              `json:"created_at"`
        UpdatedAt       time.Time              `json:"updated_at"`
}

// MappingAnalysis represents analysis of framework mappings
type MappingAnalysis struct {
        ID                 string                  `json:"id"`
        SourceFramework    string                  `json:"source_framework"`
        TargetFramework    string                  `json:"target_framework"`
        TotalMappings      int                     `json:"total_mappings"`
        ExactMappings      int                     `json:"exact_mappings"`
        PartialMappings    int                     `json:"partial_mappings"`
        RelatedMappings    int                     `json:"related_mappings"`
        SupersededMappings int                     `json:"superseded_mappings"`
        AverageConfidence  float64                 `json:"average_confidence"`
        CoveragePercentage float64                 `json:"coverage_percentage"`
        Gaps               []MappingGap            `json:"gaps"`
        Recommendations    []MappingRecommendation `json:"recommendations"`
        AnalysisDate       time.Time               `json:"analysis_date"`
}

// MappingGap represents a gap in framework mapping
type MappingGap struct {
        ID                     string `json:"id"`
        SourceRequirementID    string `json:"source_requirement_id"`
        SourceRequirementTitle string `json:"source_requirement_title"`
        TargetRequirementID    string `json:"target_requirement_id"`
        TargetRequirementTitle string `json:"target_requirement_title"`
        GapType                string `json:"gap_type"` // "missing", "unmapped", "incomplete"
        Severity               string `json:"severity"` // "low", "medium", "high", "critical"
        Description            string `json:"description"`
        Impact                 string `json:"impact"`
        Recommendation         string `json:"recommendation"`
}

// MappingRecommendation represents a recommendation for framework mapping
type MappingRecommendation struct {
        ID          string    `json:"id"`
        Type        string    `json:"type"`     // "create", "update", "delete", "review"
        Priority    string    `json:"priority"` // "low", "medium", "high", "critical"
        Title       string    `json:"title"`
        Description string    `json:"description"`
        Action      string    `json:"action"`
        Impact      string    `json:"impact"`
        Effort      string    `json:"effort"`
        Timeline    string    `json:"timeline"`
        AssignedTo  string    `json:"assigned_to"`
        Status      string    `json:"status"` // "open", "in_progress", "completed", "rejected"
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
}

// NewFrameworkMappingSystem creates a new framework mapping system
func NewFrameworkMappingSystem(logger *observability.Logger) *FrameworkMappingSystem <span class="cov0" title="0">{
        return &amp;FrameworkMappingSystem{
                logger:       logger,
                frameworks:   make(map[string]*RegulatoryFramework),
                mappings:     make(map[string]*FrameworkMapping),
                mappingRules: make(map[string][]MappingRule),
                crosswalks:   make(map[string]*CrosswalkMapping),
                confidence:   make(map[string]float64),
        }
}</span>

// RegisterFramework registers a regulatory framework
func (s *FrameworkMappingSystem) RegisterFramework(ctx context.Context, framework *RegulatoryFramework) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Registering regulatory framework",
                "request_id", requestID,
                "framework_id", framework.ID,
                "framework_name", framework.Name,
                "framework_type", framework.Type,
                "jurisdiction", framework.Jurisdiction,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        s.frameworks[framework.ID] = framework

        s.logger.Info("Regulatory framework registered successfully",
                "request_id", requestID,
                "framework_id", framework.ID,
                "framework_name", framework.Name,
                "requirement_count", len(framework.Requirements),
        )

        return nil
}</span>

// CreateMapping creates a mapping between frameworks
func (s *FrameworkMappingSystem) CreateMapping(ctx context.Context, mapping *FrameworkMapping) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Creating framework mapping",
                "request_id", requestID,
                "source_framework", mapping.SourceFramework,
                "target_framework", mapping.TargetFramework,
                "source_requirement_id", mapping.SourceRequirementID,
                "target_requirement_id", mapping.TargetRequirementID,
                "mapping_type", mapping.MappingType,
                "confidence", mapping.Confidence,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        // Validate frameworks exist
        if _, exists := s.frameworks[mapping.SourceFramework]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("source framework %s not found", mapping.SourceFramework)
        }</span>
        <span class="cov0" title="0">if _, exists := s.frameworks[mapping.TargetFramework]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("target framework %s not found", mapping.TargetFramework)
        }</span>

        // Generate mapping ID if not provided
        <span class="cov0" title="0">if mapping.ID == "" </span><span class="cov0" title="0">{
                mapping.ID = fmt.Sprintf("mapping_%s_%s_%s_%s",
                        mapping.SourceFramework, mapping.SourceRequirementID,
                        mapping.TargetFramework, mapping.TargetRequirementID)
        }</span>

        // Set timestamps
        <span class="cov0" title="0">now := time.Now()
        if mapping.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                mapping.CreatedAt = now
        }</span>
        <span class="cov0" title="0">mapping.UpdatedAt = now

        s.mappings[mapping.ID] = mapping
        s.confidence[mapping.ID] = mapping.Confidence

        s.logger.Info("Framework mapping created successfully",
                "request_id", requestID,
                "mapping_id", mapping.ID,
                "source_framework", mapping.SourceFramework,
                "target_framework", mapping.TargetFramework,
                "confidence", mapping.Confidence,
        )

        return nil</span>
}

// GetMapping gets a specific framework mapping
func (s *FrameworkMappingSystem) GetMapping(ctx context.Context, mappingID string) (*FrameworkMapping, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Getting framework mapping",
                "request_id", requestID,
                "mapping_id", mappingID,
        )

        s.mu.RLock()
        defer s.mu.RUnlock()

        mapping, exists := s.mappings[mappingID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("mapping %s not found", mappingID)
        }</span>

        <span class="cov0" title="0">return mapping, nil</span>
}

// GetMappingsByFramework gets all mappings for a specific framework
func (s *FrameworkMappingSystem) GetMappingsByFramework(ctx context.Context, frameworkID string, direction string) ([]*FrameworkMapping, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Getting framework mappings",
                "request_id", requestID,
                "framework_id", frameworkID,
                "direction", direction,
        )

        s.mu.RLock()
        defer s.mu.RUnlock()

        var mappings []*FrameworkMapping
        for _, mapping := range s.mappings </span><span class="cov0" title="0">{
                switch direction </span>{
                case "source":<span class="cov0" title="0">
                        if mapping.SourceFramework == frameworkID </span><span class="cov0" title="0">{
                                mappings = append(mappings, mapping)
                        }</span>
                case "target":<span class="cov0" title="0">
                        if mapping.TargetFramework == frameworkID </span><span class="cov0" title="0">{
                                mappings = append(mappings, mapping)
                        }</span>
                case "both":<span class="cov0" title="0">
                        if mapping.SourceFramework == frameworkID || mapping.TargetFramework == frameworkID </span><span class="cov0" title="0">{
                                mappings = append(mappings, mapping)
                        }</span>
                }
        }

        <span class="cov0" title="0">return mappings, nil</span>
}

// GetMappingsBetweenFrameworks gets mappings between two specific frameworks
func (s *FrameworkMappingSystem) GetMappingsBetweenFrameworks(ctx context.Context, sourceFramework, targetFramework string) ([]*FrameworkMapping, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Getting mappings between frameworks",
                "request_id", requestID,
                "source_framework", sourceFramework,
                "target_framework", targetFramework,
        )

        s.mu.RLock()
        defer s.mu.RUnlock()

        var mappings []*FrameworkMapping
        for _, mapping := range s.mappings </span><span class="cov0" title="0">{
                if mapping.SourceFramework == sourceFramework &amp;&amp; mapping.TargetFramework == targetFramework </span><span class="cov0" title="0">{
                        mappings = append(mappings, mapping)
                }</span>
        }

        <span class="cov0" title="0">return mappings, nil</span>
}

// UpdateMapping updates an existing framework mapping
func (s *FrameworkMappingSystem) UpdateMapping(ctx context.Context, mappingID string, updates map[string]interface{}) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Updating framework mapping",
                "request_id", requestID,
                "mapping_id", mappingID,
                "updates", updates,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        mapping, exists := s.mappings[mappingID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("mapping %s not found", mappingID)
        }</span>

        // Apply updates
        <span class="cov0" title="0">for key, value := range updates </span><span class="cov0" title="0">{
                switch key </span>{
                case "mapping_type":<span class="cov0" title="0">
                        if mappingType, ok := value.(MappingType); ok </span><span class="cov0" title="0">{
                                mapping.MappingType = mappingType
                        }</span>
                case "confidence":<span class="cov0" title="0">
                        if confidence, ok := value.(float64); ok </span><span class="cov0" title="0">{
                                mapping.Confidence = confidence
                                s.confidence[mappingID] = confidence
                        }</span>
                case "notes":<span class="cov0" title="0">
                        if notes, ok := value.(string); ok </span><span class="cov0" title="0">{
                                mapping.Notes = notes
                        }</span>
                }
        }

        <span class="cov0" title="0">mapping.UpdatedAt = time.Now()

        s.logger.Info("Framework mapping updated successfully",
                "request_id", requestID,
                "mapping_id", mappingID,
        )

        return nil</span>
}

// DeleteMapping deletes a framework mapping
func (s *FrameworkMappingSystem) DeleteMapping(ctx context.Context, mappingID string) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Deleting framework mapping",
                "request_id", requestID,
                "mapping_id", mappingID,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        if _, exists := s.mappings[mappingID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("mapping %s not found", mappingID)
        }</span>

        <span class="cov0" title="0">delete(s.mappings, mappingID)
        delete(s.confidence, mappingID)

        s.logger.Info("Framework mapping deleted successfully",
                "request_id", requestID,
                "mapping_id", mappingID,
        )

        return nil</span>
}

// CreateCrosswalk creates a crosswalk between frameworks
func (s *FrameworkMappingSystem) CreateCrosswalk(ctx context.Context, crosswalk *CrosswalkMapping) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Creating framework crosswalk",
                "request_id", requestID,
                "crosswalk_name", crosswalk.Name,
                "source_framework", crosswalk.SourceFramework,
                "target_framework", crosswalk.TargetFramework,
                "mapping_type", crosswalk.MappingType,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        // Validate frameworks exist
        if _, exists := s.frameworks[crosswalk.SourceFramework]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("source framework %s not found", crosswalk.SourceFramework)
        }</span>
        <span class="cov0" title="0">if _, exists := s.frameworks[crosswalk.TargetFramework]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("target framework %s not found", crosswalk.TargetFramework)
        }</span>

        // Generate crosswalk ID if not provided
        <span class="cov0" title="0">if crosswalk.ID == "" </span><span class="cov0" title="0">{
                crosswalk.ID = fmt.Sprintf("crosswalk_%s_%s", crosswalk.SourceFramework, crosswalk.TargetFramework)
        }</span>

        // Set timestamps
        <span class="cov0" title="0">now := time.Now()
        if crosswalk.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                crosswalk.CreatedAt = now
        }</span>
        <span class="cov0" title="0">crosswalk.UpdatedAt = now

        s.crosswalks[crosswalk.ID] = crosswalk

        s.logger.Info("Framework crosswalk created successfully",
                "request_id", requestID,
                "crosswalk_id", crosswalk.ID,
                "crosswalk_name", crosswalk.Name,
                "mapping_count", len(crosswalk.Mappings),
        )

        return nil</span>
}

// GetCrosswalk gets a specific crosswalk
func (s *FrameworkMappingSystem) GetCrosswalk(ctx context.Context, crosswalkID string) (*CrosswalkMapping, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Getting framework crosswalk",
                "request_id", requestID,
                "crosswalk_id", crosswalkID,
        )

        s.mu.RLock()
        defer s.mu.RUnlock()

        crosswalk, exists := s.crosswalks[crosswalkID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("crosswalk %s not found", crosswalkID)
        }</span>

        <span class="cov0" title="0">return crosswalk, nil</span>
}

// GetFramework returns a registered regulatory framework by ID
func (s *FrameworkMappingSystem) GetFramework(ctx context.Context, frameworkID string) (*RegulatoryFramework, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Getting regulatory framework",
                "request_id", requestID,
                "framework_id", frameworkID,
        )

        s.mu.RLock()
        defer s.mu.RUnlock()

        fw, ok := s.frameworks[frameworkID]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("framework %s not found", frameworkID)
        }</span>
        <span class="cov0" title="0">return fw, nil</span>
}

// AnalyzeFrameworkMapping analyzes mappings between frameworks
func (s *FrameworkMappingSystem) AnalyzeFrameworkMapping(ctx context.Context, sourceFramework, targetFramework string) (*MappingAnalysis, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Analyzing framework mapping",
                "request_id", requestID,
                "source_framework", sourceFramework,
                "target_framework", targetFramework,
        )

        s.mu.RLock()
        defer s.mu.RUnlock()

        // Get mappings between frameworks
        mappings, err := s.GetMappingsBetweenFrameworks(ctx, sourceFramework, targetFramework)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get source framework requirements
        <span class="cov0" title="0">sourceFrameworkData, exists := s.frameworks[sourceFramework]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("source framework %s not found", sourceFramework)
        }</span>

        // Get target framework requirements
        <span class="cov0" title="0">targetFrameworkData, exists := s.frameworks[targetFramework]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("target framework %s not found", targetFramework)
        }</span>

        // Analyze mappings
        <span class="cov0" title="0">analysis := &amp;MappingAnalysis{
                ID:              fmt.Sprintf("analysis_%s_%s_%d", sourceFramework, targetFramework, time.Now().Unix()),
                SourceFramework: sourceFramework,
                TargetFramework: targetFramework,
                AnalysisDate:    time.Now(),
        }

        // Count mappings by type
        for _, mapping := range mappings </span><span class="cov0" title="0">{
                analysis.TotalMappings++
                analysis.AverageConfidence += mapping.Confidence

                switch mapping.MappingType </span>{
                case MappingTypeExact:<span class="cov0" title="0">
                        analysis.ExactMappings++</span>
                case MappingTypePartial:<span class="cov0" title="0">
                        analysis.PartialMappings++</span>
                case MappingTypeRelated:<span class="cov0" title="0">
                        analysis.RelatedMappings++</span>
                case MappingTypeSuperseded:<span class="cov0" title="0">
                        analysis.SupersededMappings++</span>
                }
        }

        // Calculate average confidence
        <span class="cov0" title="0">if analysis.TotalMappings &gt; 0 </span><span class="cov0" title="0">{
                analysis.AverageConfidence /= float64(analysis.TotalMappings)
        }</span>

        // Calculate coverage percentage
        <span class="cov0" title="0">totalSourceRequirements := len(sourceFrameworkData.Requirements)
        if totalSourceRequirements &gt; 0 </span><span class="cov0" title="0">{
                analysis.CoveragePercentage = float64(analysis.TotalMappings) / float64(totalSourceRequirements) * 100.0
        }</span>

        // Identify gaps
        <span class="cov0" title="0">analysis.Gaps = s.identifyMappingGaps(sourceFrameworkData, targetFrameworkData, mappings)

        // Generate recommendations
        analysis.Recommendations = s.generateMappingRecommendations(analysis)

        s.logger.Info("Framework mapping analysis completed",
                "request_id", requestID,
                "source_framework", sourceFramework,
                "target_framework", targetFramework,
                "total_mappings", analysis.TotalMappings,
                "coverage_percentage", analysis.CoveragePercentage,
                "gaps_count", len(analysis.Gaps),
                "recommendations_count", len(analysis.Recommendations),
        )

        return analysis, nil</span>
}

// AutoMapFrameworks automatically maps frameworks based on similarity
func (s *FrameworkMappingSystem) AutoMapFrameworks(ctx context.Context, sourceFramework, targetFramework string, confidenceThreshold float64) ([]*FrameworkMapping, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Auto-mapping frameworks",
                "request_id", requestID,
                "source_framework", sourceFramework,
                "target_framework", targetFramework,
                "confidence_threshold", confidenceThreshold,
        )

        s.mu.RLock()
        defer s.mu.RUnlock()

        sourceFrameworkData, exists := s.frameworks[sourceFramework]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("source framework %s not found", sourceFramework)
        }</span>

        <span class="cov0" title="0">targetFrameworkData, exists := s.frameworks[targetFramework]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("target framework %s not found", targetFramework)
        }</span>

        <span class="cov0" title="0">var autoMappings []*FrameworkMapping

        // Compare requirements and create mappings
        for _, sourceReq := range sourceFrameworkData.Requirements </span><span class="cov0" title="0">{
                bestMatch := s.findBestRequirementMatch(&amp;sourceReq, targetFrameworkData.Requirements, confidenceThreshold)
                if bestMatch != nil </span><span class="cov0" title="0">{
                        mapping := &amp;FrameworkMapping{
                                ID:                  fmt.Sprintf("auto_mapping_%s_%s_%s_%s", sourceFramework, sourceReq.RequirementID, targetFramework, bestMatch.Requirement.RequirementID),
                                SourceFramework:     sourceFramework,
                                SourceRequirementID: sourceReq.RequirementID,
                                TargetFramework:     targetFramework,
                                TargetRequirementID: bestMatch.Requirement.RequirementID,
                                MappingType:         MappingTypePartial, // Auto-mapped are typically partial
                                Confidence:          bestMatch.Confidence,
                                Notes:               fmt.Sprintf("Auto-generated mapping based on similarity analysis"),
                                CreatedAt:           time.Now(),
                                UpdatedAt:           time.Now(),
                        }
                        autoMappings = append(autoMappings, mapping)
                }</span>
        }

        <span class="cov0" title="0">s.logger.Info("Auto-mapping completed",
                "request_id", requestID,
                "source_framework", sourceFramework,
                "target_framework", targetFramework,
                "auto_mappings_count", len(autoMappings),
        )

        return autoMappings, nil</span>
}

// Helper methods
func (s *FrameworkMappingSystem) identifyMappingGaps(sourceFramework, targetFramework *RegulatoryFramework, mappings []*FrameworkMapping) []MappingGap <span class="cov0" title="0">{
        var gaps []MappingGap

        // Create a map of mapped source requirements
        mappedSourceReqs := make(map[string]bool)
        for _, mapping := range mappings </span><span class="cov0" title="0">{
                mappedSourceReqs[mapping.SourceRequirementID] = true
        }</span>

        // Identify unmapped source requirements
        <span class="cov0" title="0">for _, sourceReq := range sourceFramework.Requirements </span><span class="cov0" title="0">{
                if !mappedSourceReqs[sourceReq.RequirementID] </span><span class="cov0" title="0">{
                        gap := MappingGap{
                                ID:                     fmt.Sprintf("gap_%s_%s", sourceFramework.ID, sourceReq.RequirementID),
                                SourceRequirementID:    sourceReq.RequirementID,
                                SourceRequirementTitle: sourceReq.Title,
                                GapType:                "unmapped",
                                Severity:               s.calculateGapSeverity(&amp;sourceReq),
                                Description:            fmt.Sprintf("Requirement %s from %s has no mapping to %s", sourceReq.RequirementID, sourceFramework.Name, targetFramework.Name),
                                Impact:                 "Potential compliance gap",
                                Recommendation:         "Review and create appropriate mapping or mark as not applicable",
                        }
                        gaps = append(gaps, gap)
                }</span>
        }

        <span class="cov0" title="0">return gaps</span>
}

func (s *FrameworkMappingSystem) generateMappingRecommendations(analysis *MappingAnalysis) []MappingRecommendation <span class="cov0" title="0">{
        var recommendations []MappingRecommendation

        // Low coverage recommendation
        if analysis.CoveragePercentage &lt; 50.0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, MappingRecommendation{
                        ID:          fmt.Sprintf("rec_%s_low_coverage", analysis.ID),
                        Type:        "create",
                        Priority:    "high",
                        Title:       "Low Framework Coverage",
                        Description: fmt.Sprintf("Only %.1f%% of requirements are mapped between frameworks", analysis.CoveragePercentage),
                        Action:      "Create additional mappings to improve coverage",
                        Impact:      "High - Improves compliance understanding and reduces gaps",
                        Effort:      "Medium - Requires manual review and mapping",
                        Timeline:    "2-4 weeks",
                        Status:      "open",
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                })
        }</span>

        // Low confidence recommendation
        <span class="cov0" title="0">if analysis.AverageConfidence &lt; 0.7 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, MappingRecommendation{
                        ID:          fmt.Sprintf("rec_%s_low_confidence", analysis.ID),
                        Type:        "update",
                        Priority:    "medium",
                        Title:       "Low Mapping Confidence",
                        Description: fmt.Sprintf("Average mapping confidence is %.1f%%", analysis.AverageConfidence*100),
                        Action:      "Review and improve low-confidence mappings",
                        Impact:      "Medium - Improves mapping accuracy",
                        Effort:      "Low - Review existing mappings",
                        Timeline:    "1-2 weeks",
                        Status:      "open",
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                })
        }</span>

        // Gap remediation recommendations
        <span class="cov0" title="0">for _, gap := range analysis.Gaps </span><span class="cov0" title="0">{
                recommendations = append(recommendations, MappingRecommendation{
                        ID:          fmt.Sprintf("rec_%s_gap_%s", analysis.ID, gap.ID),
                        Type:        "create",
                        Priority:    gap.Severity,
                        Title:       fmt.Sprintf("Address Mapping Gap: %s", gap.SourceRequirementTitle),
                        Description: gap.Description,
                        Action:      gap.Recommendation,
                        Impact:      gap.Impact,
                        Effort:      "Medium - Requires requirement analysis",
                        Timeline:    "1-3 weeks",
                        Status:      "open",
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                })
        }</span>

        <span class="cov0" title="0">return recommendations</span>
}

func (s *FrameworkMappingSystem) findBestRequirementMatch(sourceReq *ComplianceRequirement, targetReqs []ComplianceRequirement, confidenceThreshold float64) *struct {
        Requirement *ComplianceRequirement
        Confidence  float64
} <span class="cov0" title="0">{
        var bestMatch *struct {
                Requirement *ComplianceRequirement
                Confidence  float64
        }
        bestConfidence := 0.0

        for i := range targetReqs </span><span class="cov0" title="0">{
                confidence := s.calculateRequirementSimilarity(sourceReq, &amp;targetReqs[i])
                if confidence &gt; bestConfidence &amp;&amp; confidence &gt;= confidenceThreshold </span><span class="cov0" title="0">{
                        bestConfidence = confidence
                        bestMatch = &amp;struct {
                                Requirement *ComplianceRequirement
                                Confidence  float64
                        }{
                                Requirement: &amp;targetReqs[i],
                                Confidence:  confidence,
                        }
                }</span>
        }

        <span class="cov0" title="0">return bestMatch</span>
}

func (s *FrameworkMappingSystem) calculateRequirementSimilarity(req1, req2 *ComplianceRequirement) float64 <span class="cov0" title="0">{
        // Simple similarity calculation based on title and description
        // In a real implementation, this would use more sophisticated NLP techniques

        similarity := 0.0

        // Title similarity (simple string matching)
        if req1.Title == req2.Title </span><span class="cov0" title="0">{
                similarity += 0.4
        }</span> else<span class="cov0" title="0"> if s.stringContains(req1.Title, req2.Title) || s.stringContains(req2.Title, req1.Title) </span><span class="cov0" title="0">{
                similarity += 0.2
        }</span>

        // Description similarity
        <span class="cov0" title="0">if req1.Description == req2.Description </span><span class="cov0" title="0">{
                similarity += 0.3
        }</span> else<span class="cov0" title="0"> if s.stringContains(req1.Description, req2.Description) || s.stringContains(req2.Description, req1.Description) </span><span class="cov0" title="0">{
                similarity += 0.15
        }</span>

        // Category similarity
        <span class="cov0" title="0">if req1.Category == req2.Category </span><span class="cov0" title="0">{
                similarity += 0.2
        }</span>

        // Risk level similarity
        <span class="cov0" title="0">if req1.RiskLevel == req2.RiskLevel </span><span class="cov0" title="0">{
                similarity += 0.1
        }</span>

        <span class="cov0" title="0">return similarity</span>
}

func (s *FrameworkMappingSystem) stringContains(str1, str2 string) bool <span class="cov0" title="0">{
        // Simple string containment check
        // In a real implementation, this would use more sophisticated text analysis
        return len(str2) &gt; 0 &amp;&amp; len(str1) &gt;= len(str2) &amp;&amp;
                (len(str1) == len(str2) &amp;&amp; str1 == str2 ||
                        len(str1) &gt; len(str2) &amp;&amp; (str1[:len(str2)] == str2 || str1[len(str1)-len(str2):] == str2))
}</span>

func (s *FrameworkMappingSystem) calculateGapSeverity(requirement *ComplianceRequirement) string <span class="cov0" title="0">{
        // Calculate gap severity based on requirement risk level and priority
        switch requirement.RiskLevel </span>{
        case ComplianceRiskLevelCritical:<span class="cov0" title="0">
                return "critical"</span>
        case ComplianceRiskLevelHigh:<span class="cov0" title="0">
                return "high"</span>
        case ComplianceRiskLevelMedium:<span class="cov0" title="0">
                return "medium"</span>
        case ComplianceRiskLevelLow:<span class="cov0" title="0">
                return "low"</span>
        default:<span class="cov0" title="0">
                return "medium"</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package compliance

import (
        "context"
        "fmt"
        "sort"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// GapSeverity indicates business impact of a gap
type GapSeverity string

const (
        GapSeverityLow      GapSeverity = "low"
        GapSeverityMedium   GapSeverity = "medium"
        GapSeverityHigh     GapSeverity = "high"
        GapSeverityCritical GapSeverity = "critical"
)

// GapType categorizes the kind of compliance gap
type GapType string

const (
        GapMissingRequirement  GapType = "missing_requirement"
        GapRequirementNotReady GapType = "requirement_not_implemented"
        GapNonCompliant        GapType = "non_compliant_requirement"
        GapOverdueReview       GapType = "overdue_review"
        GapMissingControl      GapType = "missing_control"
        GapIneffectiveControl  GapType = "ineffective_control"
        GapOverdueControlTest  GapType = "overdue_control_test"
        GapMissingEvidence     GapType = "missing_evidence"
        GapOpenException       GapType = "open_exception"
        GapCoverage            GapType = "coverage_gap"
)

// RequirementGap describes a gap at the requirement level
type RequirementGap struct {
        RequirementID  string      `json:"requirement_id"`
        Title          string      `json:"title"`
        GapType        GapType     `json:"gap_type"`
        Severity       GapSeverity `json:"severity"`
        Description    string      `json:"description"`
        Recommendation string      `json:"recommendation"`
}

// ControlGap describes a gap at the control level
type ControlGap struct {
        ControlID      string      `json:"control_id"`
        RequirementID  string      `json:"requirement_id"`
        Title          string      `json:"title"`
        GapType        GapType     `json:"gap_type"`
        Severity       GapSeverity `json:"severity"`
        Description    string      `json:"description"`
        Recommendation string      `json:"recommendation"`
}

// EvidenceGap describes missing evidence needs
type EvidenceGap struct {
        RequirementID  string      `json:"requirement_id"`
        ControlID      string      `json:"control_id,omitempty"`
        MissingCount   int         `json:"missing_count"`
        Severity       GapSeverity `json:"severity"`
        Recommendation string      `json:"recommendation"`
}

// GapAnalysisReport aggregates all gaps for a business and framework
type GapAnalysisReport struct {
        BusinessID      string           `json:"business_id"`
        FrameworkID     string           `json:"framework_id"`
        GeneratedAt     time.Time        `json:"generated_at"`
        RequirementGaps []RequirementGap `json:"requirement_gaps"`
        ControlGaps     []ControlGap     `json:"control_gaps"`
        EvidenceGaps    []EvidenceGap    `json:"evidence_gaps"`
        Totals          map[string]int   `json:"totals"`
        SeverityCounts  map[string]int   `json:"severity_counts"`
}

// GapAnalyzer finds compliance gaps using tracking and framework definitions
type GapAnalyzer struct {
        logger   *observability.Logger
        tracking *TrackingSystem
        mappings *FrameworkMappingSystem
}

func NewGapAnalyzer(logger *observability.Logger, tracking *TrackingSystem, mappings *FrameworkMappingSystem) *GapAnalyzer <span class="cov0" title="0">{
        return &amp;GapAnalyzer{logger: logger, tracking: tracking, mappings: mappings}
}</span>

// AnalyzeGaps returns a gap analysis report for a business and framework
func (g *GapAnalyzer) AnalyzeGaps(ctx context.Context, businessID, frameworkID string) (*GapAnalysisReport, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        g.logger.Info("Analyzing compliance gaps",
                "request_id", requestID,
                "business_id", businessID,
                "framework_id", frameworkID,
        )

        if g.tracking == nil || g.mappings == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("gap analyzer dependencies not initialized")
        }</span>

        <span class="cov0" title="0">tracking, err := g.tracking.GetComplianceTracking(ctx, businessID, frameworkID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tracking not found: %w", err)
        }</span>
        <span class="cov0" title="0">framework, err := g.mappings.GetFramework(ctx, frameworkID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("framework not found: %w", err)
        }</span>

        <span class="cov0" title="0">report := &amp;GapAnalysisReport{
                BusinessID:     businessID,
                FrameworkID:    frameworkID,
                GeneratedAt:    time.Now(),
                Totals:         make(map[string]int),
                SeverityCounts: make(map[string]int),
        }

        // Build quick index for tracking by requirement and control
        reqTrackMap := make(map[string]*RequirementTracking)
        for i := range tracking.Requirements </span><span class="cov0" title="0">{
                req := &amp;tracking.Requirements[i]
                reqTrackMap[req.RequirementID] = req
        }</span>
        <span class="cov0" title="0">ctrlTrackMap := make(map[string]*ControlTracking)
        for i := range tracking.Requirements </span><span class="cov0" title="0">{
                for j := range tracking.Requirements[i].Controls </span><span class="cov0" title="0">{
                        ctrl := &amp;tracking.Requirements[i].Controls[j]
                        ctrlTrackMap[ctrl.ControlID] = ctrl
                }</span>
        }

        // Scan each framework requirement for gaps
        <span class="cov0" title="0">for i := range framework.Requirements </span><span class="cov0" title="0">{
                reqDef := &amp;framework.Requirements[i]
                reqTrack, exists := reqTrackMap[reqDef.RequirementID]
                if !exists </span><span class="cov0" title="0">{
                        // No tracking exists: coverage gap
                        g.addReqGap(report, RequirementGap{
                                RequirementID:  reqDef.RequirementID,
                                Title:          reqDef.Title,
                                GapType:        GapMissingRequirement,
                                Severity:       g.severityFromDef(reqDef),
                                Description:    "Requirement not present in tracking; no assessment available",
                                Recommendation: "Initialize tracking for this requirement and begin implementation",
                        })
                        continue</span>
                }

                // Status-based gaps
                <span class="cov0" title="0">switch reqTrack.Status </span>{
                case ComplianceStatusNotStarted:<span class="cov0" title="0">
                        g.addReqGap(report, RequirementGap{
                                RequirementID:  reqDef.RequirementID,
                                Title:          reqDef.Title,
                                GapType:        GapRequirementNotReady,
                                Severity:       g.severityFromDef(reqDef),
                                Description:    "Requirement not started",
                                Recommendation: "Define implementation plan, assign owner, and set target dates",
                        })</span>
                case ComplianceStatusNonCompliant:<span class="cov0" title="0">
                        g.addReqGap(report, RequirementGap{
                                RequirementID:  reqDef.RequirementID,
                                Title:          reqDef.Title,
                                GapType:        GapNonCompliant,
                                Severity:       GapSeverityCritical,
                                Description:    "Requirement marked non-compliant",
                                Recommendation: "Prioritize remediation with clear corrective controls and evidence",
                        })</span>
                }

                // Review recency gap (overdue review)
                <span class="cov0" title="0">if time.Since(reqTrack.LastReviewed) &gt; 90*24*time.Hour </span><span class="cov0" title="0">{ // 90 days
                        g.addReqGap(report, RequirementGap{
                                RequirementID:  reqDef.RequirementID,
                                Title:          reqDef.Title,
                                GapType:        GapOverdueReview,
                                Severity:       GapSeverityMedium,
                                Description:    "Requirement review overdue (&gt;90 days)",
                                Recommendation: "Schedule and complete a requirement review; update evidence",
                        })
                }</span>

                // Evidence requirement gaps
                <span class="cov0" title="0">if reqDef.EvidenceRequired &amp;&amp; len(reqTrack.Evidence) == 0 </span><span class="cov0" title="0">{
                        report.EvidenceGaps = append(report.EvidenceGaps, EvidenceGap{
                                RequirementID:  reqDef.RequirementID,
                                MissingCount:   1,
                                Severity:       g.severityFromDef(reqDef),
                                Recommendation: "Collect and attach required evidence per framework guidance",
                        })
                        g.bump(report, string(GapMissingEvidence))
                        g.bumpSeverity(report, string(g.severityFromDef(reqDef)))
                }</span>

                // Open exceptions
                <span class="cov0" title="0">for _, ex := range reqTrack.Exceptions </span><span class="cov0" title="0">{
                        if ex.Status == ExceptionStatusApproved || ex.Status == ExceptionStatusPending </span><span class="cov0" title="0">{
                                g.addReqGap(report, RequirementGap{
                                        RequirementID:  reqDef.RequirementID,
                                        Title:          reqDef.Title,
                                        GapType:        GapOpenException,
                                        Severity:       GapSeverityHigh,
                                        Description:    "Active exception exists for this requirement",
                                        Recommendation: "Review exception validity, define compensating controls, and set expiry",
                                })
                        }</span>
                }

                // Control-level gaps compared to framework definition
                <span class="cov0" title="0">ctrlDefByID := make(map[string]*ComplianceControl)
                for c := range reqDef.Controls </span><span class="cov0" title="0">{
                        cd := &amp;reqDef.Controls[c]
                        ctrlDefByID[cd.ID] = cd
                }</span>

                // Missing controls from definition
                <span class="cov0" title="0">for ctrlID, cd := range ctrlDefByID </span><span class="cov0" title="0">{
                        var ctrlTrack *ControlTracking
                        for j := range reqTrack.Controls </span><span class="cov0" title="0">{
                                if reqTrack.Controls[j].ControlID == ctrlID </span><span class="cov0" title="0">{
                                        ctrlTrack = &amp;reqTrack.Controls[j]
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if ctrlTrack == nil </span><span class="cov0" title="0">{
                                report.ControlGaps = append(report.ControlGaps, ControlGap{
                                        ControlID:      ctrlID,
                                        RequirementID:  reqDef.RequirementID,
                                        Title:          cd.Title,
                                        GapType:        GapMissingControl,
                                        Severity:       g.severityFromDef(reqDef),
                                        Description:    "Required control missing in tracking",
                                        Recommendation: "Create and implement the control; define tests and evidence",
                                })
                                g.bump(report, string(GapMissingControl))
                                g.bumpSeverity(report, string(g.severityFromDef(reqDef)))
                                continue</span>
                        }

                        // Ineffective control
                        <span class="cov0" title="0">if ctrlTrack.Effectiveness == ControlEffectivenessIneffective || ctrlTrack.Effectiveness == ControlEffectivenessPartiallyEffective </span><span class="cov0" title="0">{
                                report.ControlGaps = append(report.ControlGaps, ControlGap{
                                        ControlID:      ctrlTrack.ControlID,
                                        RequirementID:  reqDef.RequirementID,
                                        Title:          cd.Title,
                                        GapType:        GapIneffectiveControl,
                                        Severity:       GapSeverityHigh,
                                        Description:    "Control effectiveness is low",
                                        Recommendation: "Improve design or operation; increase testing and monitoring",
                                })
                                g.bump(report, string(GapIneffectiveControl))
                                g.bumpSeverity(report, string(GapSeverityHigh))
                        }</span>

                        // Overdue testing
                        <span class="cov0" title="0">if ctrlTrack.LastTested == nil || time.Since(*ctrlTrack.LastTested) &gt; 60*24*time.Hour </span><span class="cov0" title="0">{
                                report.ControlGaps = append(report.ControlGaps, ControlGap{
                                        ControlID:      ctrlTrack.ControlID,
                                        RequirementID:  reqDef.RequirementID,
                                        Title:          cd.Title,
                                        GapType:        GapOverdueControlTest,
                                        Severity:       GapSeverityMedium,
                                        Description:    "Control testing overdue (&gt;60 days)",
                                        Recommendation: "Schedule and perform control tests; attach results",
                                })
                                g.bump(report, string(GapOverdueControlTest))
                                g.bumpSeverity(report, string(GapSeverityMedium))
                        }</span>

                        // Control evidence missing
                        <span class="cov0" title="0">if len(ctrlTrack.Evidence) == 0 &amp;&amp; cd != nil </span><span class="cov0" title="0">{
                                report.EvidenceGaps = append(report.EvidenceGaps, EvidenceGap{
                                        RequirementID:  reqDef.RequirementID,
                                        ControlID:      ctrlTrack.ControlID,
                                        MissingCount:   1,
                                        Severity:       GapSeverityMedium,
                                        Recommendation: "Attach operating evidence for the control (e.g., logs, screenshots)",
                                })
                                g.bump(report, string(GapMissingEvidence))
                                g.bumpSeverity(report, string(GapSeverityMedium))
                        }</span>
                }
        }

        // Sort outputs for stable presentation
        <span class="cov0" title="0">sort.SliceStable(report.RequirementGaps, func(i, j int) bool </span><span class="cov0" title="0">{
                return report.RequirementGaps[i].RequirementID &lt; report.RequirementGaps[j].RequirementID
        }</span>)
        <span class="cov0" title="0">sort.SliceStable(report.ControlGaps, func(i, j int) bool </span><span class="cov0" title="0">{
                return report.ControlGaps[i].RequirementID+report.ControlGaps[i].ControlID &lt; report.ControlGaps[j].RequirementID+report.ControlGaps[j].ControlID
        }</span>)

        <span class="cov0" title="0">g.logger.Info("Gap analysis completed",
                "request_id", requestID,
                "business_id", businessID,
                "framework_id", frameworkID,
                "req_gaps", len(report.RequirementGaps),
                "ctrl_gaps", len(report.ControlGaps),
                "evidence_gaps", len(report.EvidenceGaps),
        )

        return report, nil</span>
}

func (g *GapAnalyzer) severityFromDef(req *ComplianceRequirement) GapSeverity <span class="cov0" title="0">{
        switch req.RiskLevel </span>{
        case ComplianceRiskLevelCritical:<span class="cov0" title="0">
                return GapSeverityCritical</span>
        case ComplianceRiskLevelHigh:<span class="cov0" title="0">
                return GapSeverityHigh</span>
        case ComplianceRiskLevelMedium:<span class="cov0" title="0">
                return GapSeverityMedium</span>
        default:<span class="cov0" title="0">
                return GapSeverityLow</span>
        }
}

func (g *GapAnalyzer) addReqGap(report *GapAnalysisReport, gap RequirementGap) <span class="cov0" title="0">{
        report.RequirementGaps = append(report.RequirementGaps, gap)
        g.bump(report, string(gap.GapType))
        g.bumpSeverity(report, string(gap.Severity))
}</span>

func (g *GapAnalyzer) bump(report *GapAnalysisReport, key string) <span class="cov0" title="0">{
        report.Totals[key] = report.Totals[key] + 1
}</span>

func (g *GapAnalyzer) bumpSeverity(report *GapAnalysisReport, sev string) <span class="cov0" title="0">{
        report.SeverityCounts[sev] = report.SeverityCounts[sev] + 1
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package compliance

import (
        "time"
)

// GDPRFramework defines the GDPR compliance framework
const (
        FrameworkGDPR = "GDPR"

        // GDPR Versions
        GDPRVersion2018 = "2018"
        GDPRVersion2016 = "2016"

        // GDPR Principles
        GDPRPrincipleLawfulness     = "Lawfulness, Fairness and Transparency"
        GDPRPrinciplePurpose        = "Purpose Limitation"
        GDPRPrincipleMinimization   = "Data Minimization"
        GDPRPrincipleAccuracy       = "Accuracy"
        GDPRPrincipleStorage        = "Storage Limitation"
        GDPRPrincipleIntegrity      = "Integrity and Confidentiality"
        GDPRPrincipleAccountability = "Accountability"

        // GDPR Data Subject Rights
        GDPRRightAccess        = "Right of Access"
        GDPRRightRectification = "Right to Rectification"
        GDPRRightErasure       = "Right to Erasure"
        GDPRRightPortability   = "Right to Data Portability"
        GDPRRightObjection     = "Right to Object"
        GDPRRightRestriction   = "Right to Restriction of Processing"
        GDPRRightAutomated     = "Right to Automated Decision Making"
        GDPRRightCompensation  = "Right to Compensation"

        // GDPR Legal Bases
        GDPRLegalBasisConsent             = "Consent"
        GDPRLegalBasisContract            = "Contract"
        GDPRLegalBasisLegalObligation     = "Legal Obligation"
        GDPRLegalBasisVitalInterests      = "Vital Interests"
        GDPRLegalBasisPublicTask          = "Public Task"
        GDPRLegalBasisLegitimateInterests = "Legitimate Interests"
)

// GDPRRequirement represents a GDPR requirement
type GDPRRequirement struct {
        ID                   string                 `json:"id"`
        RequirementID        string                 `json:"requirement_id"` // e.g., Art.5, Art.6, Art.12
        Article              string                 `json:"article"`        // GDPR Article number
        Principle            string                 `json:"principle"`      // GDPR Principle
        Category             string                 `json:"category"`       // Data Protection, Rights, etc.
        Title                string                 `json:"title"`
        Description          string                 `json:"description"`
        DetailedDescription  string                 `json:"detailed_description"`
        LegalBasis           []string               `json:"legal_basis"`
        DataSubjectRights    []string               `json:"data_subject_rights"`
        RiskLevel            ComplianceRiskLevel    `json:"risk_level"`
        Priority             CompliancePriority     `json:"priority"`
        ImplementationStatus ImplementationStatus   `json:"implementation_status"`
        EvidenceRequired     bool                   `json:"evidence_required"`
        EvidenceDescription  string                 `json:"evidence_description"`
        KeyControls          []string               `json:"key_controls"`
        SubRequirements      []GDPRRequirement      `json:"sub_requirements,omitempty"`
        ParentRequirementID  *string                `json:"parent_requirement_id,omitempty"`
        EffectiveDate        time.Time              `json:"effective_date"`
        LastUpdated          time.Time              `json:"last_updated"`
        NextReviewDate       time.Time              `json:"next_review_date"`
        ReviewFrequency      string                 `json:"review_frequency"`
        ComplianceOfficer    string                 `json:"compliance_officer"`
        Tags                 []string               `json:"tags"`
        Metadata             map[string]interface{} `json:"metadata,omitempty"`
}

// GDPRFrameworkDefinition represents the complete GDPR framework
type GDPRFrameworkDefinition struct {
        ID                string                 `json:"id"`
        Name              string                 `json:"name"`
        Version           string                 `json:"version"`
        Description       string                 `json:"description"`
        Type              FrameworkType          `json:"type"`
        Jurisdiction      string                 `json:"jurisdiction"`
        GeographicScope   []string               `json:"geographic_scope"`
        IndustryScope     []string               `json:"industry_scope"`
        EffectiveDate     time.Time              `json:"effective_date"`
        LastUpdated       time.Time              `json:"last_updated"`
        NextReviewDate    time.Time              `json:"next_review_date"`
        Requirements      []GDPRRequirement      `json:"requirements"`
        Principles        []GDPRPrinciple        `json:"principles"`
        DataSubjectRights []GDPRDataSubjectRight `json:"data_subject_rights"`
        MappingRules      []FrameworkMapping     `json:"mapping_rules"`
        Metadata          map[string]interface{} `json:"metadata,omitempty"`
}

// GDPRPrinciple represents a GDPR principle
type GDPRPrinciple struct {
        ID            string                 `json:"id"`
        Name          string                 `json:"name"`
        Code          string                 `json:"code"`
        Description   string                 `json:"description"`
        Requirements  []string               `json:"requirements"` // Requirement IDs
        RiskLevel     ComplianceRiskLevel    `json:"risk_level"`
        Priority      CompliancePriority     `json:"priority"`
        EffectiveDate time.Time              `json:"effective_date"`
        LastUpdated   time.Time              `json:"last_updated"`
        Metadata      map[string]interface{} `json:"metadata,omitempty"`
}

// GDPRDataSubjectRight represents a GDPR data subject right
type GDPRDataSubjectRight struct {
        ID            string                 `json:"id"`
        Name          string                 `json:"name"`
        Code          string                 `json:"code"`
        Description   string                 `json:"description"`
        Requirements  []string               `json:"requirements"` // Requirement IDs
        RiskLevel     ComplianceRiskLevel    `json:"risk_level"`
        Priority      CompliancePriority     `json:"priority"`
        EffectiveDate time.Time              `json:"effective_date"`
        LastUpdated   time.Time              `json:"last_updated"`
        Metadata      map[string]interface{} `json:"metadata,omitempty"`
}

// GDPRComplianceStatus represents GDPR specific compliance status
type GDPRComplianceStatus struct {
        BusinessID            string                            `json:"business_id"`
        Framework             string                            `json:"framework"`
        Version               string                            `json:"version"`
        DataController        bool                              `json:"data_controller"`
        DataProcessor         bool                              `json:"data_processor"`
        DataProtectionOfficer string                            `json:"data_protection_officer"`
        OverallStatus         ComplianceStatus                  `json:"overall_status"`
        ComplianceScore       float64                           `json:"compliance_score"`
        PrincipleStatus       map[string]PrincipleStatus        `json:"principle_status"`
        RightsStatus          map[string]DataSubjectRightStatus `json:"rights_status"`
        RequirementsStatus    map[string]GDPRRequirementStatus  `json:"requirements_status"`
        LastAssessment        time.Time                         `json:"last_assessment"`
        NextAssessment        time.Time                         `json:"next_assessment"`
        AssessmentFrequency   string                            `json:"assessment_frequency"`
        ComplianceOfficer     string                            `json:"compliance_officer"`
        SupervisoryAuthority  string                            `json:"supervisory_authority,omitempty"`
        CertificationDate     *time.Time                        `json:"certification_date,omitempty"`
        CertificationExpiry   *time.Time                        `json:"certification_expiry,omitempty"`
        CertificationBody     string                            `json:"certification_body,omitempty"`
        CertificationNumber   string                            `json:"certification_number,omitempty"`
        Notes                 string                            `json:"notes"`
        Metadata              map[string]interface{}            `json:"metadata,omitempty"`
}

// PrincipleStatus represents status for a specific GDPR principle
type PrincipleStatus struct {
        PrincipleID       string           `json:"principle_id"`
        PrincipleName     string           `json:"principle_name"`
        Status            ComplianceStatus `json:"status"`
        Score             float64          `json:"score"`
        RequirementCount  int              `json:"requirement_count"`
        ImplementedCount  int              `json:"implemented_count"`
        VerifiedCount     int              `json:"verified_count"`
        NonCompliantCount int              `json:"non_compliant_count"`
        ExemptCount       int              `json:"exempt_count"`
        LastReviewed      time.Time        `json:"last_reviewed"`
        NextReview        time.Time        `json:"next_review"`
        Reviewer          string           `json:"reviewer"`
        Notes             string           `json:"notes"`
}

// DataSubjectRightStatus represents status for a specific GDPR data subject right
type DataSubjectRightStatus struct {
        RightID           string           `json:"right_id"`
        RightName         string           `json:"right_name"`
        Status            ComplianceStatus `json:"status"`
        Score             float64          `json:"score"`
        RequirementCount  int              `json:"requirement_count"`
        ImplementedCount  int              `json:"implemented_count"`
        VerifiedCount     int              `json:"verified_count"`
        NonCompliantCount int              `json:"non_compliant_count"`
        ExemptCount       int              `json:"exempt_count"`
        LastReviewed      time.Time        `json:"last_reviewed"`
        NextReview        time.Time        `json:"next_review"`
        Reviewer          string           `json:"reviewer"`
        Notes             string           `json:"notes"`
}

// GDPRRequirementStatus represents status for a specific GDPR requirement
type GDPRRequirementStatus struct {
        RequirementID        string               `json:"requirement_id"`
        ArticleID            string               `json:"article_id"`
        PrincipleID          string               `json:"principle_id"`
        Title                string               `json:"title"`
        Status               ComplianceStatus     `json:"status"`
        ImplementationStatus ImplementationStatus `json:"implementation_status"`
        ComplianceScore      float64              `json:"compliance_score"`
        RiskLevel            ComplianceRiskLevel  `json:"risk_level"`
        Priority             CompliancePriority   `json:"priority"`
        LastReviewed         time.Time            `json:"last_reviewed"`
        NextReview           time.Time            `json:"next_review"`
        Reviewer             string               `json:"reviewer"`
        EvidenceCount        int                  `json:"evidence_count"`
        ExceptionCount       int                  `json:"exception_count"`
        RemediationPlanCount int                  `json:"remediation_plan_count"`
        Trend                string               `json:"trend"`
        TrendStrength        string               `json:"trend_strength"`
        Notes                string               `json:"notes"`
}

// NewGDPRFramework creates a new GDPR framework definition
func NewGDPRFramework() *GDPRFrameworkDefinition <span class="cov0" title="0">{
        return &amp;GDPRFrameworkDefinition{
                ID:                FrameworkGDPR,
                Name:              "General Data Protection Regulation",
                Version:           GDPRVersion2018,
                Description:       "The GDPR is a regulation in EU law on data protection and privacy in the European Union and the European Economic Area",
                Type:              FrameworkTypePrivacy,
                Jurisdiction:      "European Union",
                GeographicScope:   []string{"European Union", "European Economic Area"},
                IndustryScope:     []string{"All Industries"},
                EffectiveDate:     time.Date(2018, 5, 25, 0, 0, 0, 0, time.UTC),
                LastUpdated:       time.Now(),
                NextReviewDate:    time.Now().AddDate(1, 0, 0),
                Requirements:      getGDPRRequirements(),
                Principles:        getGDPRPrinciples(),
                DataSubjectRights: getGDPRDataSubjectRights(),
                Metadata:          make(map[string]interface{}),
        }
}</span>

// getGDPRPrinciples returns the GDPR principles
func getGDPRPrinciples() []GDPRPrinciple <span class="cov0" title="0">{
        return []GDPRPrinciple{
                {
                        ID:           GDPRPrincipleLawfulness,
                        Name:         "Lawfulness, Fairness and Transparency",
                        Code:         "Art.5(1)(a)",
                        Description:  "Personal data shall be processed lawfully, fairly and in a transparent manner",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"Art.5.1.a", "Art.6", "Art.7", "Art.8", "Art.9"},
                },
                {
                        ID:           GDPRPrinciplePurpose,
                        Name:         "Purpose Limitation",
                        Code:         "Art.5(1)(b)",
                        Description:  "Personal data shall be collected for specified, explicit and legitimate purposes",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"Art.5.1.b", "Art.6.4"},
                },
                {
                        ID:           GDPRPrincipleMinimization,
                        Name:         "Data Minimization",
                        Code:         "Art.5(1)(c)",
                        Description:  "Personal data shall be adequate, relevant and limited to what is necessary",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"Art.5.1.c", "Art.25"},
                },
                {
                        ID:           GDPRPrincipleAccuracy,
                        Name:         "Accuracy",
                        Code:         "Art.5(1)(d)",
                        Description:  "Personal data shall be accurate and, where necessary, kept up to date",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"Art.5.1.d", "Art.16"},
                },
                {
                        ID:           GDPRPrincipleStorage,
                        Name:         "Storage Limitation",
                        Code:         "Art.5(1)(e)",
                        Description:  "Personal data shall be kept in a form which permits identification for no longer than necessary",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"Art.5.1.e", "Art.17"},
                },
                {
                        ID:           GDPRPrincipleIntegrity,
                        Name:         "Integrity and Confidentiality",
                        Code:         "Art.5(1)(f)",
                        Description:  "Personal data shall be processed in a manner that ensures appropriate security",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"Art.5.1.f", "Art.32"},
                },
                {
                        ID:           GDPRPrincipleAccountability,
                        Name:         "Accountability",
                        Code:         "Art.5(2)",
                        Description:  "The controller shall be responsible for, and be able to demonstrate compliance",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"Art.5.2", "Art.24", "Art.25", "Art.30", "Art.33", "Art.34"},
                },
        }
}</span>

// getGDPRDataSubjectRights returns the GDPR data subject rights
func getGDPRDataSubjectRights() []GDPRDataSubjectRight <span class="cov0" title="0">{
        return []GDPRDataSubjectRight{
                {
                        ID:           GDPRRightAccess,
                        Name:         "Right of Access",
                        Code:         "Art.15",
                        Description:  "Data subjects have the right to obtain confirmation and access to their personal data",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"Art.15", "Art.12"},
                },
                {
                        ID:           GDPRRightRectification,
                        Name:         "Right to Rectification",
                        Code:         "Art.16",
                        Description:  "Data subjects have the right to have inaccurate personal data rectified",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"Art.16", "Art.12"},
                },
                {
                        ID:           GDPRRightErasure,
                        Name:         "Right to Erasure",
                        Code:         "Art.17",
                        Description:  "Data subjects have the right to have their personal data erased",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"Art.17", "Art.12"},
                },
                {
                        ID:           GDPRRightPortability,
                        Name:         "Right to Data Portability",
                        Code:         "Art.20",
                        Description:  "Data subjects have the right to receive their personal data in a structured format",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"Art.20", "Art.12"},
                },
                {
                        ID:           GDPRRightObjection,
                        Name:         "Right to Object",
                        Code:         "Art.21",
                        Description:  "Data subjects have the right to object to processing of their personal data",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"Art.21", "Art.12"},
                },
                {
                        ID:           GDPRRightRestriction,
                        Name:         "Right to Restriction of Processing",
                        Code:         "Art.18",
                        Description:  "Data subjects have the right to restrict processing of their personal data",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"Art.18", "Art.12"},
                },
                {
                        ID:           GDPRRightAutomated,
                        Name:         "Right to Automated Decision Making",
                        Code:         "Art.22",
                        Description:  "Data subjects have the right not to be subject to automated decision-making",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"Art.22", "Art.12"},
                },
                {
                        ID:           GDPRRightCompensation,
                        Name:         "Right to Compensation",
                        Code:         "Art.82",
                        Description:  "Data subjects have the right to compensation for material or non-material damage",
                        RiskLevel:    ComplianceRiskLevelLow,
                        Priority:     CompliancePriorityLow,
                        Requirements: []string{"Art.82"},
                },
        }
}</span>

// getGDPRRequirements returns the GDPR requirements
func getGDPRRequirements() []GDPRRequirement <span class="cov0" title="0">{
        return []GDPRRequirement{
                // Lawfulness, Fairness and Transparency
                {
                        ID:                   "Art.5.1.a",
                        RequirementID:        "Art.5.1.a",
                        Article:              "Article 5(1)(a)",
                        Principle:            GDPRPrincipleLawfulness,
                        Category:             "Data Protection Principles",
                        Title:                "Lawfulness, Fairness and Transparency",
                        Description:          "Personal data shall be processed lawfully, fairly and in a transparent manner",
                        DetailedDescription:  "Processing of personal data must have a legal basis, be fair to the data subject, and be transparent about how data is processed",
                        LegalBasis:           []string{GDPRLegalBasisConsent, GDPRLegalBasisContract, GDPRLegalBasisLegalObligation, GDPRLegalBasisVitalInterests, GDPRLegalBasisPublicTask, GDPRLegalBasisLegitimateInterests},
                        DataSubjectRights:    []string{GDPRRightAccess, GDPRRightObjection},
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Legal basis documentation, privacy notices, transparency measures",
                        KeyControls:          []string{"Legal Basis Assessment", "Privacy Notices", "Transparency Measures", "Fair Processing"},
                        EffectiveDate:        time.Date(2018, 5, 25, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"lawfulness", "fairness", "transparency", "legal-basis"},
                },
                {
                        ID:                   "Art.6",
                        RequirementID:        "Art.6",
                        Article:              "Article 6",
                        Principle:            GDPRPrincipleLawfulness,
                        Category:             "Legal Basis",
                        Title:                "Lawfulness of Processing",
                        Description:          "Processing shall be lawful only if and to the extent that at least one legal basis applies",
                        DetailedDescription:  "Personal data processing must have a valid legal basis under Article 6(1) of the GDPR",
                        LegalBasis:           []string{GDPRLegalBasisConsent, GDPRLegalBasisContract, GDPRLegalBasisLegalObligation, GDPRLegalBasisVitalInterests, GDPRLegalBasisPublicTask, GDPRLegalBasisLegitimateInterests},
                        DataSubjectRights:    []string{GDPRRightAccess, GDPRRightObjection},
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Legal basis documentation, consent records, legitimate interest assessments",
                        KeyControls:          []string{"Legal Basis Documentation", "Consent Management", "Legitimate Interest Assessment", "Contract Processing"},
                        EffectiveDate:        time.Date(2018, 5, 25, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"legal-basis", "lawfulness", "consent", "legitimate-interests"},
                },

                // Purpose Limitation
                {
                        ID:                   "Art.5.1.b",
                        RequirementID:        "Art.5.1.b",
                        Article:              "Article 5(1)(b)",
                        Principle:            GDPRPrinciplePurpose,
                        Category:             "Data Protection Principles",
                        Title:                "Purpose Limitation",
                        Description:          "Personal data shall be collected for specified, explicit and legitimate purposes",
                        DetailedDescription:  "Personal data must be collected for specific, clearly defined purposes and not processed in a manner incompatible with those purposes",
                        LegalBasis:           []string{GDPRLegalBasisConsent, GDPRLegalBasisContract, GDPRLegalBasisLegitimateInterests},
                        DataSubjectRights:    []string{GDPRRightAccess, GDPRRightObjection},
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Purpose documentation, privacy notices, processing records",
                        KeyControls:          []string{"Purpose Documentation", "Privacy Notices", "Processing Records", "Purpose Limitation"},
                        EffectiveDate:        time.Date(2018, 5, 25, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"purpose-limitation", "data-collection", "processing-purposes"},
                },

                // Data Minimization
                {
                        ID:                   "Art.5.1.c",
                        RequirementID:        "Art.5.1.c",
                        Article:              "Article 5(1)(c)",
                        Principle:            GDPRPrincipleMinimization,
                        Category:             "Data Protection Principles",
                        Title:                "Data Minimization",
                        Description:          "Personal data shall be adequate, relevant and limited to what is necessary",
                        DetailedDescription:  "Only collect and process personal data that is necessary for the specified purposes",
                        LegalBasis:           []string{GDPRLegalBasisConsent, GDPRLegalBasisContract, GDPRLegalBasisLegitimateInterests},
                        DataSubjectRights:    []string{GDPRRightAccess, GDPRRightRectification},
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Data minimization assessments, processing records, data inventory",
                        KeyControls:          []string{"Data Minimization Assessment", "Processing Records", "Data Inventory", "Collection Limits"},
                        EffectiveDate:        time.Date(2018, 5, 25, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"data-minimization", "adequacy", "relevance", "necessity"},
                },

                // Accuracy
                {
                        ID:                   "Art.5.1.d",
                        RequirementID:        "Art.5.1.d",
                        Article:              "Article 5(1)(d)",
                        Principle:            GDPRPrincipleAccuracy,
                        Category:             "Data Protection Principles",
                        Title:                "Accuracy",
                        Description:          "Personal data shall be accurate and, where necessary, kept up to date",
                        DetailedDescription:  "Personal data must be accurate and kept up to date, with reasonable steps taken to ensure accuracy",
                        LegalBasis:           []string{GDPRLegalBasisConsent, GDPRLegalBasisContract, GDPRLegalBasisLegitimateInterests},
                        DataSubjectRights:    []string{GDPRRightAccess, GDPRRightRectification},
                        RiskLevel:            ComplianceRiskLevelMedium,
                        Priority:             CompliancePriorityMedium,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Data accuracy procedures, update processes, rectification records",
                        KeyControls:          []string{"Data Accuracy Procedures", "Update Processes", "Rectification Records", "Quality Controls"},
                        EffectiveDate:        time.Date(2018, 5, 25, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"accuracy", "data-quality", "updates", "rectification"},
                },

                // Storage Limitation
                {
                        ID:                   "Art.5.1.e",
                        RequirementID:        "Art.5.1.e",
                        Article:              "Article 5(1)(e)",
                        Principle:            GDPRPrincipleStorage,
                        Category:             "Data Protection Principles",
                        Title:                "Storage Limitation",
                        Description:          "Personal data shall be kept in a form which permits identification for no longer than necessary",
                        DetailedDescription:  "Personal data must not be kept longer than necessary for the specified purposes",
                        LegalBasis:           []string{GDPRLegalBasisConsent, GDPRLegalBasisContract, GDPRLegalBasisLegalObligation},
                        DataSubjectRights:    []string{GDPRRightAccess, GDPRRightErasure},
                        RiskLevel:            ComplianceRiskLevelMedium,
                        Priority:             CompliancePriorityMedium,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Retention policies, deletion procedures, storage records",
                        KeyControls:          []string{"Retention Policies", "Deletion Procedures", "Storage Records", "Retention Limits"},
                        EffectiveDate:        time.Date(2018, 5, 25, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"storage-limitation", "retention", "deletion", "identification"},
                },

                // Integrity and Confidentiality
                {
                        ID:                   "Art.5.1.f",
                        RequirementID:        "Art.5.1.f",
                        Article:              "Article 5(1)(f)",
                        Principle:            GDPRPrincipleIntegrity,
                        Category:             "Data Protection Principles",
                        Title:                "Integrity and Confidentiality",
                        Description:          "Personal data shall be processed in a manner that ensures appropriate security",
                        DetailedDescription:  "Personal data must be processed with appropriate technical and organizational security measures",
                        LegalBasis:           []string{GDPRLegalBasisConsent, GDPRLegalBasisContract, GDPRLegalBasisLegitimateInterests},
                        DataSubjectRights:    []string{GDPRRightAccess, GDPRRightCompensation},
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Security measures documentation, risk assessments, incident response procedures",
                        KeyControls:          []string{"Security Measures", "Risk Assessments", "Incident Response", "Access Controls"},
                        EffectiveDate:        time.Date(2018, 5, 25, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"integrity", "confidentiality", "security", "protection"},
                },

                // Accountability
                {
                        ID:                   "Art.5.2",
                        RequirementID:        "Art.5.2",
                        Article:              "Article 5(2)",
                        Principle:            GDPRPrincipleAccountability,
                        Category:             "Data Protection Principles",
                        Title:                "Accountability",
                        Description:          "The controller shall be responsible for, and be able to demonstrate compliance",
                        DetailedDescription:  "Data controllers must be able to demonstrate compliance with all GDPR principles",
                        LegalBasis:           []string{GDPRLegalBasisConsent, GDPRLegalBasisContract, GDPRLegalBasisLegitimateInterests},
                        DataSubjectRights:    []string{GDPRRightAccess, GDPRRightCompensation},
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Compliance documentation, audit trails, governance procedures",
                        KeyControls:          []string{"Compliance Documentation", "Audit Trails", "Governance Procedures", "Demonstration"},
                        EffectiveDate:        time.Date(2018, 5, 25, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"accountability", "compliance", "demonstration", "governance"},
                },

                // Data Subject Rights
                {
                        ID:                   "Art.15",
                        RequirementID:        "Art.15",
                        Article:              "Article 15",
                        Principle:            GDPRPrincipleLawfulness,
                        Category:             "Data Subject Rights",
                        Title:                "Right of Access",
                        Description:          "Data subjects have the right to obtain confirmation and access to their personal data",
                        DetailedDescription:  "Data subjects must be able to access their personal data and obtain information about processing",
                        LegalBasis:           []string{GDPRLegalBasisConsent, GDPRLegalBasisContract, GDPRLegalBasisLegitimateInterests},
                        DataSubjectRights:    []string{GDPRRightAccess},
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Access request procedures, response templates, processing records",
                        KeyControls:          []string{"Access Request Procedures", "Response Templates", "Processing Records", "Verification"},
                        EffectiveDate:        time.Date(2018, 5, 25, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"access-right", "data-subject-rights", "transparency"},
                },
                {
                        ID:                   "Art.16",
                        RequirementID:        "Art.16",
                        Article:              "Article 16",
                        Principle:            GDPRPrincipleAccuracy,
                        Category:             "Data Subject Rights",
                        Title:                "Right to Rectification",
                        Description:          "Data subjects have the right to have inaccurate personal data rectified",
                        DetailedDescription:  "Data subjects must be able to have inaccurate or incomplete personal data corrected",
                        LegalBasis:           []string{GDPRLegalBasisConsent, GDPRLegalBasisContract, GDPRLegalBasisLegitimateInterests},
                        DataSubjectRights:    []string{GDPRRightRectification},
                        RiskLevel:            ComplianceRiskLevelMedium,
                        Priority:             CompliancePriorityMedium,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Rectification procedures, verification processes, update records",
                        KeyControls:          []string{"Rectification Procedures", "Verification Processes", "Update Records", "Accuracy Checks"},
                        EffectiveDate:        time.Date(2018, 5, 25, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"rectification", "accuracy", "correction", "data-subject-rights"},
                },
                {
                        ID:                   "Art.17",
                        RequirementID:        "Art.17",
                        Article:              "Article 17",
                        Principle:            GDPRPrincipleStorage,
                        Category:             "Data Subject Rights",
                        Title:                "Right to Erasure",
                        Description:          "Data subjects have the right to have their personal data erased",
                        DetailedDescription:  "Data subjects have the right to have their personal data deleted in certain circumstances",
                        LegalBasis:           []string{GDPRLegalBasisConsent, GDPRLegalBasisContract, GDPRLegalBasisLegitimateInterests},
                        DataSubjectRights:    []string{GDPRRightErasure},
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Erasure procedures, deletion verification, third-party notification",
                        KeyControls:          []string{"Erasure Procedures", "Deletion Verification", "Third-party Notification", "Backup Deletion"},
                        EffectiveDate:        time.Date(2018, 5, 25, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"erasure", "deletion", "right-to-be-forgotten", "data-subject-rights"},
                },
        }
}</span>

// ConvertGDPRToRegulatoryFramework converts GDPRFrameworkDefinition to RegulatoryFramework
func (gdpr *GDPRFrameworkDefinition) ConvertGDPRToRegulatoryFramework() *RegulatoryFramework <span class="cov0" title="0">{
        requirements := make([]ComplianceRequirement, len(gdpr.Requirements))
        for i, req := range gdpr.Requirements </span><span class="cov0" title="0">{
                requirements[i] = ComplianceRequirement{
                        ID:                   req.ID,
                        Framework:            gdpr.ID,
                        Category:             req.Category,
                        RequirementID:        req.RequirementID,
                        Title:                req.Title,
                        Description:          req.Description,
                        DetailedDescription:  req.DetailedDescription,
                        RiskLevel:            req.RiskLevel,
                        Priority:             req.Priority,
                        Status:               ComplianceStatusNotStarted,
                        ImplementationStatus: req.ImplementationStatus,
                        EvidenceRequired:     req.EvidenceRequired,
                        EvidenceDescription:  req.EvidenceDescription,
                        Controls:             []ComplianceControl{},
                        SubRequirements:      []ComplianceRequirement{},
                        ParentRequirementID:  req.ParentRequirementID,
                        ApplicableBusinesses: []string{},
                        GeographicScope:      gdpr.GeographicScope,
                        IndustryScope:        gdpr.IndustryScope,
                        EffectiveDate:        req.EffectiveDate,
                        LastUpdated:          req.LastUpdated,
                        NextReviewDate:       req.NextReviewDate,
                        ReviewFrequency:      req.ReviewFrequency,
                        ComplianceOfficer:    req.ComplianceOfficer,
                        Tags:                 req.Tags,
                        Metadata:             req.Metadata,
                }
        }</span>

        <span class="cov0" title="0">return &amp;RegulatoryFramework{
                ID:              gdpr.ID,
                Name:            gdpr.Name,
                Version:         gdpr.Version,
                Description:     gdpr.Description,
                Type:            gdpr.Type,
                Jurisdiction:    gdpr.Jurisdiction,
                GeographicScope: gdpr.GeographicScope,
                IndustryScope:   gdpr.IndustryScope,
                EffectiveDate:   gdpr.EffectiveDate,
                LastUpdated:     gdpr.LastUpdated,
                NextReviewDate:  gdpr.NextReviewDate,
                Requirements:    requirements,
                MappingRules:    gdpr.MappingRules,
                Metadata:        gdpr.Metadata,
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package compliance

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// GDPRTrackingService provides GDPR specific compliance tracking
type GDPRTrackingService struct {
        logger        *observability.Logger
        statusSystem  *ComplianceStatusSystem
        mappingSystem *FrameworkMappingSystem
        mu            sync.RWMutex
        gdprData      map[string]*GDPRComplianceStatus // businessID -&gt; GDPR status
}

// NewGDPRTrackingService creates a new GDPR tracking service
func NewGDPRTrackingService(logger *observability.Logger, statusSystem *ComplianceStatusSystem, mappingSystem *FrameworkMappingSystem) *GDPRTrackingService <span class="cov0" title="0">{
        return &amp;GDPRTrackingService{
                logger:        logger,
                statusSystem:  statusSystem,
                mappingSystem: mappingSystem,
                gdprData:      make(map[string]*GDPRComplianceStatus),
        }
}</span>

// InitializeGDPRTracking initializes GDPR tracking for a business
func (s *GDPRTrackingService) InitializeGDPRTracking(ctx context.Context, businessID string, dataController bool, dataProcessor bool, dataProtectionOfficer string) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Initializing GDPR tracking for business",
                "request_id", requestID,
                "business_id", businessID,
                "data_controller", dataController,
                "data_processor", dataProcessor,
                "data_protection_officer", dataProtectionOfficer,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        // Check if GDPR tracking already exists
        if _, exists := s.gdprData[businessID]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("GDPR tracking already initialized for business %s", businessID)
        }</span>

        // Validate that at least one role is specified
        <span class="cov0" title="0">if !dataController &amp;&amp; !dataProcessor </span><span class="cov0" title="0">{
                return fmt.Errorf("business must be either a data controller or data processor")
        }</span>

        // Create new GDPR compliance status
        <span class="cov0" title="0">gdprStatus := &amp;GDPRComplianceStatus{
                BusinessID:            businessID,
                Framework:             FrameworkGDPR,
                Version:               GDPRVersion2018,
                DataController:        dataController,
                DataProcessor:         dataProcessor,
                DataProtectionOfficer: dataProtectionOfficer,
                OverallStatus:         ComplianceStatusNotStarted,
                ComplianceScore:       0.0,
                PrincipleStatus:       make(map[string]PrincipleStatus),
                RightsStatus:          make(map[string]DataSubjectRightStatus),
                RequirementsStatus:    make(map[string]GDPRRequirementStatus),
                LastAssessment:        time.Now(),
                NextAssessment:        time.Now().AddDate(1, 0, 0),
                AssessmentFrequency:   "annually",
                ComplianceOfficer:     "system",
                Metadata:              make(map[string]interface{}),
        }

        // Initialize principle status
        gdprFramework := NewGDPRFramework()
        for _, principle := range gdprFramework.Principles </span><span class="cov0" title="0">{
                gdprStatus.PrincipleStatus[principle.ID] = PrincipleStatus{
                        PrincipleID:      principle.ID,
                        PrincipleName:    principle.Name,
                        Status:           ComplianceStatusNotStarted,
                        Score:            0.0,
                        RequirementCount: 0,
                        LastReviewed:     time.Now(),
                        NextReview:       time.Now().AddDate(0, 6, 0),
                        Reviewer:         "system",
                }
        }</span>

        // Initialize data subject rights status
        <span class="cov0" title="0">for _, right := range gdprFramework.DataSubjectRights </span><span class="cov0" title="0">{
                gdprStatus.RightsStatus[right.ID] = DataSubjectRightStatus{
                        RightID:          right.ID,
                        RightName:        right.Name,
                        Status:           ComplianceStatusNotStarted,
                        Score:            0.0,
                        RequirementCount: 0,
                        LastReviewed:     time.Now(),
                        NextReview:       time.Now().AddDate(0, 6, 0),
                        Reviewer:         "system",
                }
        }</span>

        // Initialize requirements status
        <span class="cov0" title="0">for _, requirement := range gdprFramework.Requirements </span><span class="cov0" title="0">{
                gdprStatus.RequirementsStatus[requirement.RequirementID] = GDPRRequirementStatus{
                        RequirementID:        requirement.RequirementID,
                        ArticleID:            requirement.Article,
                        PrincipleID:          requirement.Principle,
                        Title:                requirement.Title,
                        Status:               ComplianceStatusNotStarted,
                        ImplementationStatus: requirement.ImplementationStatus,
                        ComplianceScore:      0.0,
                        RiskLevel:            requirement.RiskLevel,
                        Priority:             requirement.Priority,
                        LastReviewed:         time.Now(),
                        NextReview:           requirement.NextReviewDate,
                        Reviewer:             "system",
                        EvidenceCount:        0,
                        ExceptionCount:       0,
                        RemediationPlanCount: 0,
                        Trend:                "stable",
                        TrendStrength:        "none",
                }
        }</span>

        // Store the GDPR status
        <span class="cov0" title="0">s.gdprData[businessID] = gdprStatus

        // Register GDPR framework with mapping system if not already registered
        gdprRegulatoryFramework := gdprFramework.ConvertGDPRToRegulatoryFramework()
        err := s.mappingSystem.RegisterFramework(ctx, gdprRegulatoryFramework)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to register GDPR framework with mapping system",
                        "request_id", requestID,
                        "business_id", businessID,
                        "error", err.Error(),
                )
                // Don't fail the initialization for this
        }</span>

        <span class="cov0" title="0">s.logger.Info("GDPR tracking initialized successfully",
                "request_id", requestID,
                "business_id", businessID,
                "data_controller", dataController,
                "data_processor", dataProcessor,
                "principle_count", len(gdprStatus.PrincipleStatus),
                "rights_count", len(gdprStatus.RightsStatus),
                "requirements_count", len(gdprStatus.RequirementsStatus),
        )

        return nil</span>
}

// GetGDPRStatus retrieves GDPR compliance status for a business
func (s *GDPRTrackingService) GetGDPRStatus(ctx context.Context, businessID string) (*GDPRComplianceStatus, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.mu.RLock()
        defer s.mu.RUnlock()

        gdprStatus, exists := s.gdprData[businessID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GDPR tracking not initialized for business %s", businessID)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Retrieved GDPR status",
                "request_id", requestID,
                "business_id", businessID,
                "overall_status", gdprStatus.OverallStatus,
                "compliance_score", gdprStatus.ComplianceScore,
        )

        return gdprStatus, nil</span>
}

// UpdateGDPRRequirementStatus updates the status of a specific GDPR requirement
func (s *GDPRTrackingService) UpdateGDPRRequirementStatus(ctx context.Context, businessID, requirementID string, status ComplianceStatus, implementationStatus ImplementationStatus, score float64, reviewer string) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Updating GDPR requirement status",
                "request_id", requestID,
                "business_id", businessID,
                "requirement_id", requirementID,
                "status", status,
                "implementation_status", implementationStatus,
                "score", score,
                "reviewer", reviewer,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        gdprStatus, exists := s.gdprData[businessID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("GDPR tracking not initialized for business %s", businessID)
        }</span>

        <span class="cov0" title="0">reqStatus, exists := gdprStatus.RequirementsStatus[requirementID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("requirement %s not found in GDPR framework", requirementID)
        }</span>

        // Update requirement status
        <span class="cov0" title="0">reqStatus.Status = status
        reqStatus.ImplementationStatus = implementationStatus
        reqStatus.ComplianceScore = score
        reqStatus.LastReviewed = time.Now()
        reqStatus.Reviewer = reviewer

        gdprStatus.RequirementsStatus[requirementID] = reqStatus

        // Update principle status
        s.updatePrincipleStatus(gdprStatus, reqStatus.PrincipleID)

        // Update overall status
        s.updateOverallStatus(gdprStatus)

        s.logger.Info("GDPR requirement status updated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "requirement_id", requirementID,
                "new_status", status,
                "new_score", score,
        )

        return nil</span>
}

// UpdateGDPRPrincipleStatus updates the status of a specific GDPR principle
func (s *GDPRTrackingService) UpdateGDPRPrincipleStatus(ctx context.Context, businessID, principleID string, status ComplianceStatus, score float64, reviewer string) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Updating GDPR principle status",
                "request_id", requestID,
                "business_id", businessID,
                "principle_id", principleID,
                "status", status,
                "score", score,
                "reviewer", reviewer,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        gdprStatus, exists := s.gdprData[businessID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("GDPR tracking not initialized for business %s", businessID)
        }</span>

        <span class="cov0" title="0">principleStatus, exists := gdprStatus.PrincipleStatus[principleID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("principle %s not found in GDPR framework", principleID)
        }</span>

        // Update principle status
        <span class="cov0" title="0">principleStatus.Status = status
        principleStatus.Score = score
        principleStatus.LastReviewed = time.Now()
        principleStatus.Reviewer = reviewer

        gdprStatus.PrincipleStatus[principleID] = principleStatus

        // Update overall status
        s.updateOverallStatus(gdprStatus)

        s.logger.Info("GDPR principle status updated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "principle_id", principleID,
                "new_status", status,
                "new_score", score,
        )

        return nil</span>
}

// UpdateGDPRDataSubjectRightStatus updates the status of a specific GDPR data subject right
func (s *GDPRTrackingService) UpdateGDPRDataSubjectRightStatus(ctx context.Context, businessID, rightID string, status ComplianceStatus, score float64, reviewer string) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Updating GDPR data subject right status",
                "request_id", requestID,
                "business_id", businessID,
                "right_id", rightID,
                "status", status,
                "score", score,
                "reviewer", reviewer,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        gdprStatus, exists := s.gdprData[businessID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("GDPR tracking not initialized for business %s", businessID)
        }</span>

        <span class="cov0" title="0">rightStatus, exists := gdprStatus.RightsStatus[rightID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("data subject right %s not found in GDPR framework", rightID)
        }</span>

        // Update right status
        <span class="cov0" title="0">rightStatus.Status = status
        rightStatus.Score = score
        rightStatus.LastReviewed = time.Now()
        rightStatus.Reviewer = reviewer

        gdprStatus.RightsStatus[rightID] = rightStatus

        // Update overall status
        s.updateOverallStatus(gdprStatus)

        s.logger.Info("GDPR data subject right status updated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "right_id", rightID,
                "new_status", status,
                "new_score", score,
        )

        return nil</span>
}

// AssessGDPRCompliance performs a comprehensive GDPR compliance assessment
func (s *GDPRTrackingService) AssessGDPRCompliance(ctx context.Context, businessID string) (*GDPRComplianceStatus, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Starting GDPR compliance assessment",
                "request_id", requestID,
                "business_id", businessID,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        gdprStatus, exists := s.gdprData[businessID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GDPR tracking not initialized for business %s", businessID)
        }</span>

        // Perform assessment for each principle
        <span class="cov0" title="0">gdprFramework := NewGDPRFramework()
        for _, principle := range gdprFramework.Principles </span><span class="cov0" title="0">{
                principleScore := s.assessPrinciple(ctx, gdprStatus, principle.ID)
                principleStatus := gdprStatus.PrincipleStatus[principle.ID]
                principleStatus.Score = principleScore
                principleStatus.LastReviewed = time.Now()
                principleStatus.Reviewer = "system"

                // Determine principle status based on score
                if principleScore &gt;= 90.0 </span><span class="cov0" title="0">{
                        principleStatus.Status = ComplianceStatusVerified
                }</span> else<span class="cov0" title="0"> if principleScore &gt;= 70.0 </span><span class="cov0" title="0">{
                        principleStatus.Status = ComplianceStatusImplemented
                }</span> else<span class="cov0" title="0"> if principleScore &gt;= 30.0 </span><span class="cov0" title="0">{
                        principleStatus.Status = ComplianceStatusInProgress
                }</span> else<span class="cov0" title="0"> {
                        principleStatus.Status = ComplianceStatusNotStarted
                }</span>

                <span class="cov0" title="0">gdprStatus.PrincipleStatus[principle.ID] = principleStatus</span>
        }

        // Perform assessment for each data subject right
        <span class="cov0" title="0">for _, right := range gdprFramework.DataSubjectRights </span><span class="cov0" title="0">{
                rightScore := s.assessDataSubjectRight(ctx, gdprStatus, right.ID)
                rightStatus := gdprStatus.RightsStatus[right.ID]
                rightStatus.Score = rightScore
                rightStatus.LastReviewed = time.Now()
                rightStatus.Reviewer = "system"

                // Determine right status based on score
                if rightScore &gt;= 90.0 </span><span class="cov0" title="0">{
                        rightStatus.Status = ComplianceStatusVerified
                }</span> else<span class="cov0" title="0"> if rightScore &gt;= 70.0 </span><span class="cov0" title="0">{
                        rightStatus.Status = ComplianceStatusImplemented
                }</span> else<span class="cov0" title="0"> if rightScore &gt;= 30.0 </span><span class="cov0" title="0">{
                        rightStatus.Status = ComplianceStatusInProgress
                }</span> else<span class="cov0" title="0"> {
                        rightStatus.Status = ComplianceStatusNotStarted
                }</span>

                <span class="cov0" title="0">gdprStatus.RightsStatus[right.ID] = rightStatus</span>
        }

        // Update overall status
        <span class="cov0" title="0">s.updateOverallStatus(gdprStatus)

        // Update assessment timestamp
        gdprStatus.LastAssessment = time.Now()
        gdprStatus.NextAssessment = time.Now().AddDate(1, 0, 0)

        s.logger.Info("GDPR compliance assessment completed",
                "request_id", requestID,
                "business_id", businessID,
                "overall_status", gdprStatus.OverallStatus,
                "compliance_score", gdprStatus.ComplianceScore,
        )

        return gdprStatus, nil</span>
}

// GetGDPRReport generates a GDPR compliance report
func (s *GDPRTrackingService) GetGDPRReport(ctx context.Context, businessID string, reportType string) (*ComplianceReport, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Generating GDPR compliance report",
                "request_id", requestID,
                "business_id", businessID,
                "report_type", reportType,
        )

        gdprStatus, err := s.GetGDPRStatus(ctx, businessID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert GDPR status to compliance report
        <span class="cov0" title="0">report := &amp;ComplianceReport{
                ID:               fmt.Sprintf("gdpr_report_%s_%s", businessID, time.Now().Format("20060102")),
                BusinessID:       businessID,
                Framework:        FrameworkGDPR,
                ReportType:       ReportTypeStatus,
                Title:            fmt.Sprintf("GDPR Compliance Report - %s", businessID),
                Description:      "GDPR compliance assessment report",
                GeneratedAt:      time.Now(),
                GeneratedBy:      "system",
                Period:           "annual",
                OverallStatus:    gdprStatus.OverallStatus,
                ComplianceScore:  gdprStatus.ComplianceScore,
                Requirements:     []RequirementReport{},
                Controls:         []ControlReport{},
                Exceptions:       []ExceptionReport{},
                RemediationPlans: []RemediationReport{},
                Recommendations:  []ComplianceRecommendation{},
                Metadata:         make(map[string]interface{}),
        }

        // Add GDPR specific metadata
        report.Metadata["gdpr_version"] = gdprStatus.Version
        report.Metadata["data_controller"] = gdprStatus.DataController
        report.Metadata["data_processor"] = gdprStatus.DataProcessor
        report.Metadata["data_protection_officer"] = gdprStatus.DataProtectionOfficer
        report.Metadata["principle_count"] = len(gdprStatus.PrincipleStatus)
        report.Metadata["rights_count"] = len(gdprStatus.RightsStatus)
        report.Metadata["requirements_count"] = len(gdprStatus.RequirementsStatus)

        // Convert requirements to report format
        for reqID, reqStatus := range gdprStatus.RequirementsStatus </span><span class="cov0" title="0">{
                requirementReport := RequirementReport{
                        RequirementID:        reqID,
                        Title:                reqStatus.Title,
                        Status:               reqStatus.Status,
                        ImplementationStatus: reqStatus.ImplementationStatus,
                        ComplianceScore:      reqStatus.ComplianceScore,
                        RiskLevel:            reqStatus.RiskLevel,
                        Priority:             reqStatus.Priority,
                        LastReviewed:         reqStatus.LastReviewed,
                        NextReview:           reqStatus.NextReview,
                        Controls:             []ControlReport{},
                        Exceptions:           []ExceptionReport{},
                        RemediationPlans:     []RemediationReport{},
                }
                report.Requirements = append(report.Requirements, requirementReport)
        }</span>

        <span class="cov0" title="0">s.logger.Info("GDPR compliance report generated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "report_id", report.ID,
                "requirements_count", len(report.Requirements),
        )

        return report, nil</span>
}

// updatePrincipleStatus updates the status of a principle based on its requirements
func (s *GDPRTrackingService) updatePrincipleStatus(gdprStatus *GDPRComplianceStatus, principleID string) <span class="cov0" title="0">{
        principleStatus := gdprStatus.PrincipleStatus[principleID]

        var totalScore float64
        var requirementCount int
        var implementedCount int
        var verifiedCount int
        var nonCompliantCount int
        var exemptCount int

        // Calculate principle status based on requirements
        for _, reqStatus := range gdprStatus.RequirementsStatus </span><span class="cov0" title="0">{
                if reqStatus.PrincipleID == principleID </span><span class="cov0" title="0">{
                        requirementCount++
                        totalScore += reqStatus.ComplianceScore

                        switch reqStatus.Status </span>{
                        case ComplianceStatusVerified:<span class="cov0" title="0">
                                verifiedCount++</span>
                        case ComplianceStatusImplemented:<span class="cov0" title="0">
                                implementedCount++</span>
                        case ComplianceStatusNonCompliant:<span class="cov0" title="0">
                                nonCompliantCount++</span>
                        case ComplianceStatusExempt:<span class="cov0" title="0">
                                exemptCount++</span>
                        }
                }
        }

        <span class="cov0" title="0">if requirementCount &gt; 0 </span><span class="cov0" title="0">{
                principleStatus.Score = totalScore / float64(requirementCount)
                principleStatus.RequirementCount = requirementCount
                principleStatus.ImplementedCount = implementedCount
                principleStatus.VerifiedCount = verifiedCount
                principleStatus.NonCompliantCount = nonCompliantCount
                principleStatus.ExemptCount = exemptCount

                // Determine principle status based on score
                if principleStatus.Score &gt;= 90.0 </span><span class="cov0" title="0">{
                        principleStatus.Status = ComplianceStatusVerified
                }</span> else<span class="cov0" title="0"> if principleStatus.Score &gt;= 70.0 </span><span class="cov0" title="0">{
                        principleStatus.Status = ComplianceStatusImplemented
                }</span> else<span class="cov0" title="0"> if principleStatus.Score &gt;= 30.0 </span><span class="cov0" title="0">{
                        principleStatus.Status = ComplianceStatusInProgress
                }</span> else<span class="cov0" title="0"> {
                        principleStatus.Status = ComplianceStatusNotStarted
                }</span>
        }

        <span class="cov0" title="0">gdprStatus.PrincipleStatus[principleID] = principleStatus</span>
}

// updateOverallStatus updates the overall GDPR compliance status
func (s *GDPRTrackingService) updateOverallStatus(gdprStatus *GDPRComplianceStatus) <span class="cov0" title="0">{
        var totalScore float64
        var componentCount int

        // Calculate overall score based on principle and rights scores
        for _, principleStatus := range gdprStatus.PrincipleStatus </span><span class="cov0" title="0">{
                totalScore += principleStatus.Score
                componentCount++
        }</span>

        <span class="cov0" title="0">for _, rightStatus := range gdprStatus.RightsStatus </span><span class="cov0" title="0">{
                totalScore += rightStatus.Score
                componentCount++
        }</span>

        <span class="cov0" title="0">if componentCount &gt; 0 </span><span class="cov0" title="0">{
                gdprStatus.ComplianceScore = totalScore / float64(componentCount)
        }</span>

        // Determine overall status based on score
        <span class="cov0" title="0">if gdprStatus.ComplianceScore &gt;= 90.0 </span><span class="cov0" title="0">{
                gdprStatus.OverallStatus = ComplianceStatusVerified
        }</span> else<span class="cov0" title="0"> if gdprStatus.ComplianceScore &gt;= 70.0 </span><span class="cov0" title="0">{
                gdprStatus.OverallStatus = ComplianceStatusImplemented
        }</span> else<span class="cov0" title="0"> if gdprStatus.ComplianceScore &gt;= 30.0 </span><span class="cov0" title="0">{
                gdprStatus.OverallStatus = ComplianceStatusInProgress
        }</span> else<span class="cov0" title="0"> {
                gdprStatus.OverallStatus = ComplianceStatusNotStarted
        }</span>
}

// assessPrinciple performs assessment for a specific principle
func (s *GDPRTrackingService) assessPrinciple(ctx context.Context, gdprStatus *GDPRComplianceStatus, principleID string) float64 <span class="cov0" title="0">{
        var totalScore float64
        var requirementCount int

        // Calculate principle score based on requirements
        for _, reqStatus := range gdprStatus.RequirementsStatus </span><span class="cov0" title="0">{
                if reqStatus.PrincipleID == principleID </span><span class="cov0" title="0">{
                        requirementCount++
                        totalScore += reqStatus.ComplianceScore
                }</span>
        }

        <span class="cov0" title="0">if requirementCount &gt; 0 </span><span class="cov0" title="0">{
                return totalScore / float64(requirementCount)
        }</span>

        <span class="cov0" title="0">return 0.0</span>
}

// assessDataSubjectRight performs assessment for a specific data subject right
func (s *GDPRTrackingService) assessDataSubjectRight(ctx context.Context, gdprStatus *GDPRComplianceStatus, rightID string) float64 <span class="cov0" title="0">{
        var totalScore float64
        var requirementCount int

        // Calculate right score based on requirements
        for _, reqStatus := range gdprStatus.RequirementsStatus </span><span class="cov0" title="0">{
                // This is a simplified assessment - in a real implementation, you'd map requirements to rights
                // For now, we'll use a placeholder score
                requirementCount++
                totalScore += reqStatus.ComplianceScore
        }</span>

        <span class="cov0" title="0">if requirementCount &gt; 0 </span><span class="cov0" title="0">{
                return totalScore / float64(requirementCount)
        }</span>

        <span class="cov0" title="0">return 0.0</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package compliance

import (
        "time"
)

// PCIDSSFramework defines the PCI DSS compliance framework
const (
        FrameworkPCIDSS = "PCIDSS"

        // PCI DSS Versions
        PCIDSSVersion4 = "4.0"
        PCIDSSVersion3 = "3.2.1"

        // PCI DSS Requirements Categories
        PCIDSSBuildMaintain = "Build and Maintain a Secure Network and Systems"
        PCIDSSProtectData   = "Protect Account Data"
        PCIDSSMaintainVuln  = "Maintain a Vulnerability Management Program"
        PCIDSSAccessControl = "Implement Strong Access Control Measures"
        PCIDSSMonitorTest   = "Regularly Monitor and Test Networks"
        PCIDSSPolicyInfo    = "Maintain an Information Security Policy"
)

// PCIDSSRequirement represents a PCI DSS requirement
type PCIDSSRequirement struct {
        ID                   string                 `json:"id"`
        RequirementID        string                 `json:"requirement_id"` // e.g., 1.1, 2.1, 3.1
        Category             string                 `json:"category"`       // Build and Maintain, Protect Data, etc.
        Title                string                 `json:"title"`
        Description          string                 `json:"description"`
        DetailedDescription  string                 `json:"detailed_description"`
        TestingProcedures    []string               `json:"testing_procedures"`
        Guidance             string                 `json:"guidance"`
        RiskLevel            ComplianceRiskLevel    `json:"risk_level"`
        Priority             CompliancePriority     `json:"priority"`
        ImplementationStatus ImplementationStatus   `json:"implementation_status"`
        EvidenceRequired     bool                   `json:"evidence_required"`
        EvidenceDescription  string                 `json:"evidence_description"`
        KeyControls          []string               `json:"key_controls"`
        SubRequirements      []PCIDSSRequirement    `json:"sub_requirements,omitempty"`
        ParentRequirementID  *string                `json:"parent_requirement_id,omitempty"`
        EffectiveDate        time.Time              `json:"effective_date"`
        LastUpdated          time.Time              `json:"last_updated"`
        NextReviewDate       time.Time              `json:"next_review_date"`
        ReviewFrequency      string                 `json:"review_frequency"`
        ComplianceOfficer    string                 `json:"compliance_officer"`
        Tags                 []string               `json:"tags"`
        Metadata             map[string]interface{} `json:"metadata,omitempty"`
}

// PCIDSSFrameworkDefinition represents the complete PCI DSS framework
type PCIDSSFrameworkDefinition struct {
        ID              string                 `json:"id"`
        Name            string                 `json:"name"`
        Version         string                 `json:"version"`
        Description     string                 `json:"description"`
        Type            FrameworkType          `json:"type"`
        Jurisdiction    string                 `json:"jurisdiction"`
        GeographicScope []string               `json:"geographic_scope"`
        IndustryScope   []string               `json:"industry_scope"`
        EffectiveDate   time.Time              `json:"effective_date"`
        LastUpdated     time.Time              `json:"last_updated"`
        NextReviewDate  time.Time              `json:"next_review_date"`
        Requirements    []PCIDSSRequirement    `json:"requirements"`
        Categories      []PCIDSSCategory       `json:"categories"`
        MappingRules    []FrameworkMapping     `json:"mapping_rules"`
        Metadata        map[string]interface{} `json:"metadata,omitempty"`
}

// PCIDSSCategory represents a PCI DSS requirement category
type PCIDSSCategory struct {
        ID            string                 `json:"id"`
        Name          string                 `json:"name"`
        Code          string                 `json:"code"`
        Description   string                 `json:"description"`
        Requirements  []string               `json:"requirements"` // Requirement IDs
        RiskLevel     ComplianceRiskLevel    `json:"risk_level"`
        Priority      CompliancePriority     `json:"priority"`
        EffectiveDate time.Time              `json:"effective_date"`
        LastUpdated   time.Time              `json:"last_updated"`
        Metadata      map[string]interface{} `json:"metadata,omitempty"`
}

// PCIDSSComplianceStatus represents PCI DSS specific compliance status
type PCIDSSComplianceStatus struct {
        BusinessID          string                             `json:"business_id"`
        Framework           string                             `json:"framework"`
        Version             string                             `json:"version"`
        MerchantLevel       string                             `json:"merchant_level"` // Level 1, 2, 3, 4
        ServiceProvider     bool                               `json:"service_provider"`
        OverallStatus       ComplianceStatus                   `json:"overall_status"`
        ComplianceScore     float64                            `json:"compliance_score"`
        CategoryStatus      map[string]CategoryStatus          `json:"category_status"`
        RequirementsStatus  map[string]PCIDSSRequirementStatus `json:"requirements_status"`
        LastAssessment      time.Time                          `json:"last_assessment"`
        NextAssessment      time.Time                          `json:"next_assessment"`
        AssessmentFrequency string                             `json:"assessment_frequency"`
        ComplianceOfficer   string                             `json:"compliance_officer"`
        QSA                 string                             `json:"qsa,omitempty"`
        CertificationDate   *time.Time                         `json:"certification_date,omitempty"`
        CertificationExpiry *time.Time                         `json:"certification_expiry,omitempty"`
        CertificationBody   string                             `json:"certification_body,omitempty"`
        CertificationNumber string                             `json:"certification_number,omitempty"`
        Notes               string                             `json:"notes"`
        Metadata            map[string]interface{}             `json:"metadata,omitempty"`
}

// CategoryStatus represents status for a specific PCI DSS category
type CategoryStatus struct {
        CategoryID        string           `json:"category_id"`
        CategoryName      string           `json:"category_name"`
        Status            ComplianceStatus `json:"status"`
        Score             float64          `json:"score"`
        RequirementCount  int              `json:"requirement_count"`
        ImplementedCount  int              `json:"implemented_count"`
        VerifiedCount     int              `json:"verified_count"`
        NonCompliantCount int              `json:"non_compliant_count"`
        ExemptCount       int              `json:"exempt_count"`
        LastReviewed      time.Time        `json:"last_reviewed"`
        NextReview        time.Time        `json:"next_review"`
        Reviewer          string           `json:"reviewer"`
        Notes             string           `json:"notes"`
}

// PCIDSSRequirementStatus represents status for a specific PCI DSS requirement
type PCIDSSRequirementStatus struct {
        RequirementID        string               `json:"requirement_id"`
        CategoryID           string               `json:"category_id"`
        Title                string               `json:"title"`
        Status               ComplianceStatus     `json:"status"`
        ImplementationStatus ImplementationStatus `json:"implementation_status"`
        ComplianceScore      float64              `json:"compliance_score"`
        RiskLevel            ComplianceRiskLevel  `json:"risk_level"`
        Priority             CompliancePriority   `json:"priority"`
        LastReviewed         time.Time            `json:"last_reviewed"`
        NextReview           time.Time            `json:"next_review"`
        Reviewer             string               `json:"reviewer"`
        EvidenceCount        int                  `json:"evidence_count"`
        ExceptionCount       int                  `json:"exception_count"`
        RemediationPlanCount int                  `json:"remediation_plan_count"`
        Trend                string               `json:"trend"`
        TrendStrength        string               `json:"trend_strength"`
        Notes                string               `json:"notes"`
}

// NewPCIDSSFramework creates a new PCI DSS framework definition
func NewPCIDSSFramework() *PCIDSSFrameworkDefinition <span class="cov0" title="0">{
        return &amp;PCIDSSFrameworkDefinition{
                ID:              FrameworkPCIDSS,
                Name:            "Payment Card Industry Data Security Standard",
                Version:         PCIDSSVersion4,
                Description:     "PCI DSS is a set of security standards designed to ensure that all companies that process, store, or transmit credit card information maintain a secure environment",
                Type:            FrameworkTypeSecurity,
                Jurisdiction:    "International",
                GeographicScope: []string{"Global"},
                IndustryScope:   []string{"Financial Services", "Retail", "E-commerce", "Technology"},
                EffectiveDate:   time.Date(2022, 3, 31, 0, 0, 0, 0, time.UTC),
                LastUpdated:     time.Now(),
                NextReviewDate:  time.Now().AddDate(1, 0, 0),
                Requirements:    getPCIDSSRequirements(),
                Categories:      getPCIDSSCategories(),
                Metadata:        make(map[string]interface{}),
        }
}</span>

// getPCIDSSCategories returns the PCI DSS requirement categories
func getPCIDSSCategories() []PCIDSSCategory <span class="cov0" title="0">{
        return []PCIDSSCategory{
                {
                        ID:           PCIDSSBuildMaintain,
                        Name:         "Build and Maintain a Secure Network and Systems",
                        Code:         "1-2",
                        Description:  "Requirements 1-2: Network security and system hardening",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "2.1", "2.2", "2.3", "2.4", "2.5", "2.6", "2.7", "2.8"},
                },
                {
                        ID:           PCIDSSProtectData,
                        Name:         "Protect Account Data",
                        Code:         "3-4",
                        Description:  "Requirements 3-4: Data protection and encryption",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"3.1", "3.2", "3.3", "3.4", "3.5", "3.6", "3.7", "3.8", "4.1", "4.2", "4.3"},
                },
                {
                        ID:           PCIDSSMaintainVuln,
                        Name:         "Maintain a Vulnerability Management Program",
                        Code:         "5-6",
                        Description:  "Requirements 5-6: Vulnerability management and security",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"5.1", "5.2", "5.3", "5.4", "6.1", "6.2", "6.3", "6.4", "6.5", "6.6", "6.7", "6.8"},
                },
                {
                        ID:           PCIDSSAccessControl,
                        Name:         "Implement Strong Access Control Measures",
                        Code:         "7-9",
                        Description:  "Requirements 7-9: Access control and physical security",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"7.1", "7.2", "8.1", "8.2", "8.3", "8.4", "8.5", "8.6", "8.7", "8.8", "9.1", "9.2", "9.3", "9.4", "9.5", "9.6", "9.7", "9.8", "9.9", "9.10"},
                },
                {
                        ID:           PCIDSSMonitorTest,
                        Name:         "Regularly Monitor and Test Networks",
                        Code:         "10-11",
                        Description:  "Requirements 10-11: Monitoring and testing",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"10.1", "10.2", "10.3", "10.4", "10.5", "10.6", "10.7", "10.8", "11.1", "11.2", "11.3", "11.4", "11.5", "11.6"},
                },
                {
                        ID:           PCIDSSPolicyInfo,
                        Name:         "Maintain an Information Security Policy",
                        Code:         "12",
                        Description:  "Requirement 12: Security policy and procedures",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"12.1", "12.2", "12.3", "12.4", "12.5", "12.6", "12.7", "12.8", "12.9", "12.10", "12.11"},
                },
        }
}</span>

// getPCIDSSRequirements returns the PCI DSS requirements
func getPCIDSSRequirements() []PCIDSSRequirement <span class="cov0" title="0">{
        return []PCIDSSRequirement{
                // Build and Maintain a Secure Network and Systems
                {
                        ID:                   "1.1",
                        RequirementID:        "1.1",
                        Category:             PCIDSSBuildMaintain,
                        Title:                "Install and maintain network security controls",
                        Description:          "Install and maintain network security controls to protect cardholder data",
                        DetailedDescription:  "Network security controls (NSCs) are implemented to protect the CDE from unauthorized access. NSCs are configured to restrict connections to untrusted networks and prevent unauthorized access to the CDE.",
                        TestingProcedures:    []string{"Review network security controls configuration", "Verify firewall rules and access control lists", "Test network segmentation"},
                        Guidance:             "Implement network security controls to protect the cardholder data environment from unauthorized access",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Network security controls configuration, firewall rules, access control lists, network segmentation documentation",
                        KeyControls:          []string{"Firewalls", "Network Segmentation", "Access Control Lists", "Intrusion Detection/Prevention Systems"},
                        EffectiveDate:        time.Date(2022, 3, 31, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"network-security", "firewalls", "segmentation"},
                },
                {
                        ID:                   "1.2",
                        RequirementID:        "1.2",
                        Category:             PCIDSSBuildMaintain,
                        Title:                "Configure network security controls",
                        Description:          "Configure network security controls to protect cardholder data",
                        DetailedDescription:  "Network security controls are configured to restrict connections to untrusted networks and prevent unauthorized access to the CDE. Default settings are changed and security parameters are configured.",
                        TestingProcedures:    []string{"Review network security control configurations", "Verify default settings have been changed", "Test security parameter configurations"},
                        Guidance:             "Configure network security controls with secure settings and change default configurations",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Network security control configurations, change management documentation, security parameter settings",
                        KeyControls:          []string{"Configuration Management", "Security Parameters", "Default Settings", "Change Management"},
                        EffectiveDate:        time.Date(2022, 3, 31, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"configuration", "security-parameters", "default-settings"},
                },
                {
                        ID:                   "2.1",
                        RequirementID:        "2.1",
                        Category:             PCIDSSBuildMaintain,
                        Title:                "Apply secure configurations to all system components",
                        Description:          "Apply secure configurations to all system components to protect cardholder data",
                        DetailedDescription:  "Secure configurations are applied to all system components to protect cardholder data. Default settings are changed and security parameters are configured according to vendor recommendations and industry best practices.",
                        TestingProcedures:    []string{"Review system configurations", "Verify default settings have been changed", "Test security parameter configurations"},
                        Guidance:             "Apply secure configurations to all system components and change default settings",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "System configuration documentation, change management records, security parameter settings",
                        KeyControls:          []string{"System Hardening", "Configuration Management", "Security Baselines", "Change Management"},
                        EffectiveDate:        time.Date(2022, 3, 31, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"system-hardening", "configuration", "security-baselines"},
                },

                // Protect Account Data
                {
                        ID:                   "3.1",
                        RequirementID:        "3.1",
                        Category:             PCIDSSProtectData,
                        Title:                "Define and implement data retention and disposal policies",
                        Description:          "Define and implement data retention and disposal policies for cardholder data",
                        DetailedDescription:  "Data retention and disposal policies are defined and implemented to ensure that cardholder data is retained only for the time period required by business, legal, and/or regulatory requirements, and is disposed of securely when no longer needed.",
                        TestingProcedures:    []string{"Review data retention and disposal policies", "Verify policy implementation", "Test data disposal procedures"},
                        Guidance:             "Define and implement policies for data retention and secure disposal",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Data retention and disposal policies, implementation documentation, disposal procedures",
                        KeyControls:          []string{"Data Retention Policy", "Data Disposal Policy", "Secure Disposal Procedures", "Policy Implementation"},
                        EffectiveDate:        time.Date(2022, 3, 31, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"data-retention", "data-disposal", "policies"},
                },
                {
                        ID:                   "3.2",
                        RequirementID:        "3.2",
                        Category:             PCIDSSProtectData,
                        Title:                "Protect stored cardholder data",
                        Description:          "Protect stored cardholder data using strong cryptography",
                        DetailedDescription:  "Stored cardholder data is protected using strong cryptography. Encryption keys are managed securely and cryptographic algorithms are industry-accepted and properly implemented.",
                        TestingProcedures:    []string{"Review encryption implementation", "Verify key management procedures", "Test cryptographic algorithms"},
                        Guidance:             "Protect stored cardholder data using strong cryptography and secure key management",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Encryption implementation documentation, key management procedures, cryptographic algorithm specifications",
                        KeyControls:          []string{"Strong Cryptography", "Key Management", "Encryption Algorithms", "Data Protection"},
                        EffectiveDate:        time.Date(2022, 3, 31, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"encryption", "key-management", "cryptography"},
                },

                // Maintain a Vulnerability Management Program
                {
                        ID:                   "5.1",
                        RequirementID:        "5.1",
                        Category:             PCIDSSMaintainVuln,
                        Title:                "Define and implement processes to protect against malware",
                        Description:          "Define and implement processes to protect against malware",
                        DetailedDescription:  "Processes are defined and implemented to protect against malware. Anti-malware solutions are deployed and maintained on all systems commonly affected by malware.",
                        TestingProcedures:    []string{"Review anti-malware processes", "Verify anti-malware deployment", "Test malware protection"},
                        Guidance:             "Define and implement processes to protect against malware on all systems",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Anti-malware processes, deployment documentation, protection testing results",
                        KeyControls:          []string{"Anti-malware Software", "Malware Protection", "Process Documentation", "System Protection"},
                        EffectiveDate:        time.Date(2022, 3, 31, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"malware-protection", "anti-malware", "system-protection"},
                },
                {
                        ID:                   "6.1",
                        RequirementID:        "6.1",
                        Category:             PCIDSSMaintainVuln,
                        Title:                "Define and implement a process to identify security vulnerabilities",
                        Description:          "Define and implement a process to identify security vulnerabilities",
                        DetailedDescription:  "A process is defined and implemented to identify security vulnerabilities using industry-recognized vulnerability sources. Vulnerabilities are identified and ranked according to risk.",
                        TestingProcedures:    []string{"Review vulnerability identification process", "Verify vulnerability sources", "Test vulnerability ranking"},
                        Guidance:             "Define and implement a process to identify and rank security vulnerabilities",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Vulnerability identification process, vulnerability sources, ranking methodology",
                        KeyControls:          []string{"Vulnerability Management", "Vulnerability Sources", "Risk Ranking", "Process Documentation"},
                        EffectiveDate:        time.Date(2022, 3, 31, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"vulnerability-management", "security-vulnerabilities", "risk-ranking"},
                },

                // Implement Strong Access Control Measures
                {
                        ID:                   "7.1",
                        RequirementID:        "7.1",
                        Category:             PCIDSSAccessControl,
                        Title:                "Define and implement roles and responsibilities for managing logical access",
                        Description:          "Define and implement roles and responsibilities for managing logical access",
                        DetailedDescription:  "Roles and responsibilities for managing logical access to system components and cardholder data are defined and implemented. Access is based on job function and least privilege principles.",
                        TestingProcedures:    []string{"Review roles and responsibilities", "Verify access management procedures", "Test least privilege implementation"},
                        Guidance:             "Define and implement roles and responsibilities for logical access management",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Roles and responsibilities documentation, access management procedures, least privilege implementation",
                        KeyControls:          []string{"Role Definition", "Access Management", "Least Privilege", "Responsibility Assignment"},
                        EffectiveDate:        time.Date(2022, 3, 31, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"access-control", "roles", "responsibilities", "least-privilege"},
                },
                {
                        ID:                   "8.1",
                        RequirementID:        "8.1",
                        Category:             PCIDSSAccessControl,
                        Title:                "Define and implement processes for user identification and authentication",
                        Description:          "Define and implement processes for user identification and authentication",
                        DetailedDescription:  "Processes are defined and implemented for user identification and authentication. Users are uniquely identified and authenticated before accessing system components and cardholder data.",
                        TestingProcedures:    []string{"Review user identification processes", "Verify authentication procedures", "Test unique user identification"},
                        Guidance:             "Define and implement processes for user identification and authentication",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "User identification processes, authentication procedures, unique user identification implementation",
                        KeyControls:          []string{"User Identification", "Authentication", "Unique User IDs", "Access Control"},
                        EffectiveDate:        time.Date(2022, 3, 31, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"user-identification", "authentication", "access-control"},
                },

                // Regularly Monitor and Test Networks
                {
                        ID:                   "10.1",
                        RequirementID:        "10.1",
                        Category:             PCIDSSMonitorTest,
                        Title:                "Implement audit logging",
                        Description:          "Implement audit logging to link access to system components to each individual user",
                        DetailedDescription:  "Audit logging is implemented to link access to system components to each individual user. Audit logs capture all access to system components and cardholder data.",
                        TestingProcedures:    []string{"Review audit logging implementation", "Verify log capture procedures", "Test user access linking"},
                        Guidance:             "Implement audit logging to link system access to individual users",
                        RiskLevel:            ComplianceRiskLevelMedium,
                        Priority:             CompliancePriorityMedium,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Audit logging implementation, log capture procedures, user access linking documentation",
                        KeyControls:          []string{"Audit Logging", "Log Capture", "User Access Tracking", "System Monitoring"},
                        EffectiveDate:        time.Date(2022, 3, 31, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"audit-logging", "system-monitoring", "user-tracking"},
                },
                {
                        ID:                   "11.1",
                        RequirementID:        "11.1",
                        Category:             PCIDSSMonitorTest,
                        Title:                "Implement processes to test for the presence of wireless access points",
                        Description:          "Implement processes to test for the presence of wireless access points",
                        DetailedDescription:  "Processes are implemented to test for the presence of wireless access points and detect unauthorized wireless access points. Wireless access points are identified and authorized.",
                        TestingProcedures:    []string{"Review wireless testing processes", "Verify wireless access point detection", "Test unauthorized access point detection"},
                        Guidance:             "Implement processes to test for and detect wireless access points",
                        RiskLevel:            ComplianceRiskLevelMedium,
                        Priority:             CompliancePriorityMedium,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Wireless testing processes, access point detection procedures, unauthorized access point detection",
                        KeyControls:          []string{"Wireless Testing", "Access Point Detection", "Unauthorized Detection", "Network Monitoring"},
                        EffectiveDate:        time.Date(2022, 3, 31, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"wireless-testing", "access-point-detection", "network-monitoring"},
                },

                // Maintain an Information Security Policy
                {
                        ID:                   "12.1",
                        RequirementID:        "12.1",
                        Category:             PCIDSSPolicyInfo,
                        Title:                "Establish, publish, maintain, and disseminate a security policy",
                        Description:          "Establish, publish, maintain, and disseminate a security policy",
                        DetailedDescription:  "A security policy is established, published, maintained, and disseminated to all personnel. The policy defines security expectations and responsibilities for all personnel.",
                        TestingProcedures:    []string{"Review security policy", "Verify policy dissemination", "Test policy maintenance procedures"},
                        Guidance:             "Establish, publish, maintain, and disseminate a comprehensive security policy",
                        RiskLevel:            ComplianceRiskLevelMedium,
                        Priority:             CompliancePriorityMedium,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Security policy document, policy dissemination procedures, policy maintenance documentation",
                        KeyControls:          []string{"Security Policy", "Policy Dissemination", "Policy Maintenance", "Documentation"},
                        EffectiveDate:        time.Date(2022, 3, 31, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"security-policy", "policy-management", "documentation"},
                },
        }
}</span>

// ConvertPCIDSSToRegulatoryFramework converts PCIDSSFrameworkDefinition to RegulatoryFramework
func (pci *PCIDSSFrameworkDefinition) ConvertPCIDSSToRegulatoryFramework() *RegulatoryFramework <span class="cov0" title="0">{
        requirements := make([]ComplianceRequirement, len(pci.Requirements))
        for i, req := range pci.Requirements </span><span class="cov0" title="0">{
                requirements[i] = ComplianceRequirement{
                        ID:                   req.ID,
                        Framework:            pci.ID,
                        Category:             req.Category,
                        RequirementID:        req.RequirementID,
                        Title:                req.Title,
                        Description:          req.Description,
                        DetailedDescription:  req.DetailedDescription,
                        RiskLevel:            req.RiskLevel,
                        Priority:             req.Priority,
                        Status:               ComplianceStatusNotStarted,
                        ImplementationStatus: req.ImplementationStatus,
                        EvidenceRequired:     req.EvidenceRequired,
                        EvidenceDescription:  req.EvidenceDescription,
                        Controls:             []ComplianceControl{},
                        SubRequirements:      []ComplianceRequirement{},
                        ParentRequirementID:  req.ParentRequirementID,
                        ApplicableBusinesses: []string{},
                        GeographicScope:      pci.GeographicScope,
                        IndustryScope:        pci.IndustryScope,
                        EffectiveDate:        req.EffectiveDate,
                        LastUpdated:          req.LastUpdated,
                        NextReviewDate:       req.NextReviewDate,
                        ReviewFrequency:      req.ReviewFrequency,
                        ComplianceOfficer:    req.ComplianceOfficer,
                        Tags:                 req.Tags,
                        Metadata:             req.Metadata,
                }
        }</span>

        <span class="cov0" title="0">return &amp;RegulatoryFramework{
                ID:              pci.ID,
                Name:            pci.Name,
                Version:         pci.Version,
                Description:     pci.Description,
                Type:            pci.Type,
                Jurisdiction:    pci.Jurisdiction,
                GeographicScope: pci.GeographicScope,
                IndustryScope:   pci.IndustryScope,
                EffectiveDate:   pci.EffectiveDate,
                LastUpdated:     pci.LastUpdated,
                NextReviewDate:  pci.NextReviewDate,
                Requirements:    requirements,
                MappingRules:    pci.MappingRules,
                Metadata:        pci.Metadata,
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package compliance

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// PCIDSSTrackingService provides PCI DSS specific compliance tracking
type PCIDSSTrackingService struct {
        logger        *observability.Logger
        statusSystem  *ComplianceStatusSystem
        mappingSystem *FrameworkMappingSystem
        mu            sync.RWMutex
        pciData       map[string]*PCIDSSComplianceStatus // businessID -&gt; PCI DSS status
}

// NewPCIDSSTrackingService creates a new PCI DSS tracking service
func NewPCIDSSTrackingService(logger *observability.Logger, statusSystem *ComplianceStatusSystem, mappingSystem *FrameworkMappingSystem) *PCIDSSTrackingService <span class="cov0" title="0">{
        return &amp;PCIDSSTrackingService{
                logger:        logger,
                statusSystem:  statusSystem,
                mappingSystem: mappingSystem,
                pciData:       make(map[string]*PCIDSSComplianceStatus),
        }
}</span>

// InitializePCIDSSTracking initializes PCI DSS tracking for a business
func (s *PCIDSSTrackingService) InitializePCIDSSTracking(ctx context.Context, businessID string, merchantLevel string, serviceProvider bool) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Initializing PCI DSS tracking for business",
                "request_id", requestID,
                "business_id", businessID,
                "merchant_level", merchantLevel,
                "service_provider", serviceProvider,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        // Check if PCI DSS tracking already exists
        if _, exists := s.pciData[businessID]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("PCI DSS tracking already initialized for business %s", businessID)
        }</span>

        // Validate merchant level
        <span class="cov0" title="0">validLevels := []string{"Level 1", "Level 2", "Level 3", "Level 4"}
        validLevel := false
        for _, level := range validLevels </span><span class="cov0" title="0">{
                if merchantLevel == level </span><span class="cov0" title="0">{
                        validLevel = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !validLevel </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid merchant level: %s. Must be one of: %v", merchantLevel, validLevels)
        }</span>

        // Create new PCI DSS compliance status
        <span class="cov0" title="0">pciStatus := &amp;PCIDSSComplianceStatus{
                BusinessID:          businessID,
                Framework:           FrameworkPCIDSS,
                Version:             PCIDSSVersion4,
                MerchantLevel:       merchantLevel,
                ServiceProvider:     serviceProvider,
                OverallStatus:       ComplianceStatusNotStarted,
                ComplianceScore:     0.0,
                CategoryStatus:      make(map[string]CategoryStatus),
                RequirementsStatus:  make(map[string]PCIDSSRequirementStatus),
                LastAssessment:      time.Now(),
                NextAssessment:      time.Now().AddDate(1, 0, 0),
                AssessmentFrequency: "annually",
                ComplianceOfficer:   "system",
                Metadata:            make(map[string]interface{}),
        }

        // Initialize category status
        pciFramework := NewPCIDSSFramework()
        for _, category := range pciFramework.Categories </span><span class="cov0" title="0">{
                pciStatus.CategoryStatus[category.ID] = CategoryStatus{
                        CategoryID:       category.ID,
                        CategoryName:     category.Name,
                        Status:           ComplianceStatusNotStarted,
                        Score:            0.0,
                        RequirementCount: 0,
                        LastReviewed:     time.Now(),
                        NextReview:       time.Now().AddDate(0, 6, 0),
                        Reviewer:         "system",
                }
        }</span>

        // Initialize requirements status
        <span class="cov0" title="0">for _, requirement := range pciFramework.Requirements </span><span class="cov0" title="0">{
                pciStatus.RequirementsStatus[requirement.RequirementID] = PCIDSSRequirementStatus{
                        RequirementID:        requirement.RequirementID,
                        CategoryID:           requirement.Category,
                        Title:                requirement.Title,
                        Status:               ComplianceStatusNotStarted,
                        ImplementationStatus: requirement.ImplementationStatus,
                        ComplianceScore:      0.0,
                        RiskLevel:            requirement.RiskLevel,
                        Priority:             requirement.Priority,
                        LastReviewed:         time.Now(),
                        NextReview:           requirement.NextReviewDate,
                        Reviewer:             "system",
                        EvidenceCount:        0,
                        ExceptionCount:       0,
                        RemediationPlanCount: 0,
                        Trend:                "stable",
                        TrendStrength:        "none",
                }
        }</span>

        // Store the PCI DSS status
        <span class="cov0" title="0">s.pciData[businessID] = pciStatus

        // Register PCI DSS framework with mapping system if not already registered
        pciRegulatoryFramework := pciFramework.ConvertPCIDSSToRegulatoryFramework()
        err := s.mappingSystem.RegisterFramework(ctx, pciRegulatoryFramework)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to register PCI DSS framework with mapping system",
                        "request_id", requestID,
                        "business_id", businessID,
                        "error", err.Error(),
                )
                // Don't fail the initialization for this
        }</span>

        <span class="cov0" title="0">s.logger.Info("PCI DSS tracking initialized successfully",
                "request_id", requestID,
                "business_id", businessID,
                "merchant_level", merchantLevel,
                "service_provider", serviceProvider,
                "category_count", len(pciStatus.CategoryStatus),
                "requirements_count", len(pciStatus.RequirementsStatus),
        )

        return nil</span>
}

// GetPCIDSSStatus retrieves PCI DSS compliance status for a business
func (s *PCIDSSTrackingService) GetPCIDSSStatus(ctx context.Context, businessID string) (*PCIDSSComplianceStatus, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.mu.RLock()
        defer s.mu.RUnlock()

        pciStatus, exists := s.pciData[businessID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PCI DSS tracking not initialized for business %s", businessID)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Retrieved PCI DSS status",
                "request_id", requestID,
                "business_id", businessID,
                "overall_status", pciStatus.OverallStatus,
                "compliance_score", pciStatus.ComplianceScore,
        )

        return pciStatus, nil</span>
}

// UpdatePCIDSSRequirementStatus updates the status of a specific PCI DSS requirement
func (s *PCIDSSTrackingService) UpdatePCIDSSRequirementStatus(ctx context.Context, businessID, requirementID string, status ComplianceStatus, implementationStatus ImplementationStatus, score float64, reviewer string) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Updating PCI DSS requirement status",
                "request_id", requestID,
                "business_id", businessID,
                "requirement_id", requirementID,
                "status", status,
                "implementation_status", implementationStatus,
                "score", score,
                "reviewer", reviewer,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        pciStatus, exists := s.pciData[businessID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("PCI DSS tracking not initialized for business %s", businessID)
        }</span>

        <span class="cov0" title="0">reqStatus, exists := pciStatus.RequirementsStatus[requirementID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("requirement %s not found in PCI DSS framework", requirementID)
        }</span>

        // Update requirement status
        <span class="cov0" title="0">reqStatus.Status = status
        reqStatus.ImplementationStatus = implementationStatus
        reqStatus.ComplianceScore = score
        reqStatus.LastReviewed = time.Now()
        reqStatus.Reviewer = reviewer

        pciStatus.RequirementsStatus[requirementID] = reqStatus

        // Update category status
        s.updateCategoryStatus(pciStatus, reqStatus.CategoryID)

        // Update overall status
        s.updateOverallStatus(pciStatus)

        s.logger.Info("PCI DSS requirement status updated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "requirement_id", requirementID,
                "new_status", status,
                "new_score", score,
        )

        return nil</span>
}

// UpdatePCIDSSCategoryStatus updates the status of a specific PCI DSS category
func (s *PCIDSSTrackingService) UpdatePCIDSSCategoryStatus(ctx context.Context, businessID, categoryID string, status ComplianceStatus, score float64, reviewer string) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Updating PCI DSS category status",
                "request_id", requestID,
                "business_id", businessID,
                "category_id", categoryID,
                "status", status,
                "score", score,
                "reviewer", reviewer,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        pciStatus, exists := s.pciData[businessID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("PCI DSS tracking not initialized for business %s", businessID)
        }</span>

        <span class="cov0" title="0">categoryStatus, exists := pciStatus.CategoryStatus[categoryID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("category %s not found in PCI DSS framework", categoryID)
        }</span>

        // Update category status
        <span class="cov0" title="0">categoryStatus.Status = status
        categoryStatus.Score = score
        categoryStatus.LastReviewed = time.Now()
        categoryStatus.Reviewer = reviewer

        pciStatus.CategoryStatus[categoryID] = categoryStatus

        // Update overall status
        s.updateOverallStatus(pciStatus)

        s.logger.Info("PCI DSS category status updated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "category_id", categoryID,
                "new_status", status,
                "new_score", score,
        )

        return nil</span>
}

// AssessPCIDSSCompliance performs a comprehensive PCI DSS compliance assessment
func (s *PCIDSSTrackingService) AssessPCIDSSCompliance(ctx context.Context, businessID string) (*PCIDSSComplianceStatus, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Starting PCI DSS compliance assessment",
                "request_id", requestID,
                "business_id", businessID,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        pciStatus, exists := s.pciData[businessID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PCI DSS tracking not initialized for business %s", businessID)
        }</span>

        // Perform assessment for each category
        <span class="cov0" title="0">pciFramework := NewPCIDSSFramework()
        for _, category := range pciFramework.Categories </span><span class="cov0" title="0">{
                categoryScore := s.assessCategory(ctx, pciStatus, category.ID)
                categoryStatus := pciStatus.CategoryStatus[category.ID]
                categoryStatus.Score = categoryScore
                categoryStatus.LastReviewed = time.Now()
                categoryStatus.Reviewer = "system"

                // Determine category status based on score
                if categoryScore &gt;= 90.0 </span><span class="cov0" title="0">{
                        categoryStatus.Status = ComplianceStatusVerified
                }</span> else<span class="cov0" title="0"> if categoryScore &gt;= 70.0 </span><span class="cov0" title="0">{
                        categoryStatus.Status = ComplianceStatusImplemented
                }</span> else<span class="cov0" title="0"> if categoryScore &gt;= 30.0 </span><span class="cov0" title="0">{
                        categoryStatus.Status = ComplianceStatusInProgress
                }</span> else<span class="cov0" title="0"> {
                        categoryStatus.Status = ComplianceStatusNotStarted
                }</span>

                <span class="cov0" title="0">pciStatus.CategoryStatus[category.ID] = categoryStatus</span>
        }

        // Update overall status
        <span class="cov0" title="0">s.updateOverallStatus(pciStatus)

        // Update assessment timestamp
        pciStatus.LastAssessment = time.Now()
        pciStatus.NextAssessment = time.Now().AddDate(1, 0, 0)

        s.logger.Info("PCI DSS compliance assessment completed",
                "request_id", requestID,
                "business_id", businessID,
                "overall_status", pciStatus.OverallStatus,
                "compliance_score", pciStatus.ComplianceScore,
        )

        return pciStatus, nil</span>
}

// GetPCIDSSReport generates a PCI DSS compliance report
func (s *PCIDSSTrackingService) GetPCIDSSReport(ctx context.Context, businessID string, reportType string) (*ComplianceReport, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Generating PCI DSS compliance report",
                "request_id", requestID,
                "business_id", businessID,
                "report_type", reportType,
        )

        pciStatus, err := s.GetPCIDSSStatus(ctx, businessID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert PCI DSS status to compliance report
        <span class="cov0" title="0">report := &amp;ComplianceReport{
                ID:               fmt.Sprintf("pci_dss_report_%s_%s", businessID, time.Now().Format("20060102")),
                BusinessID:       businessID,
                Framework:        FrameworkPCIDSS,
                ReportType:       ReportTypeStatus,
                Title:            fmt.Sprintf("PCI DSS Compliance Report - %s", businessID),
                Description:      "PCI DSS compliance assessment report",
                GeneratedAt:      time.Now(),
                GeneratedBy:      "system",
                Period:           "annual",
                OverallStatus:    pciStatus.OverallStatus,
                ComplianceScore:  pciStatus.ComplianceScore,
                Requirements:     []RequirementReport{},
                Controls:         []ControlReport{},
                Exceptions:       []ExceptionReport{},
                RemediationPlans: []RemediationReport{},
                Recommendations:  []ComplianceRecommendation{},
                Metadata:         make(map[string]interface{}),
        }

        // Add PCI DSS specific metadata
        report.Metadata["pci_dss_version"] = pciStatus.Version
        report.Metadata["merchant_level"] = pciStatus.MerchantLevel
        report.Metadata["service_provider"] = pciStatus.ServiceProvider
        report.Metadata["category_count"] = len(pciStatus.CategoryStatus)
        report.Metadata["requirements_count"] = len(pciStatus.RequirementsStatus)

        // Convert requirements to report format
        for reqID, reqStatus := range pciStatus.RequirementsStatus </span><span class="cov0" title="0">{
                requirementReport := RequirementReport{
                        RequirementID:        reqID,
                        Title:                reqStatus.Title,
                        Status:               reqStatus.Status,
                        ImplementationStatus: reqStatus.ImplementationStatus,
                        ComplianceScore:      reqStatus.ComplianceScore,
                        RiskLevel:            reqStatus.RiskLevel,
                        Priority:             reqStatus.Priority,
                        LastReviewed:         reqStatus.LastReviewed,
                        NextReview:           reqStatus.NextReview,
                        Controls:             []ControlReport{},
                        Exceptions:           []ExceptionReport{},
                        RemediationPlans:     []RemediationReport{},
                }
                report.Requirements = append(report.Requirements, requirementReport)
        }</span>

        <span class="cov0" title="0">s.logger.Info("PCI DSS compliance report generated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "report_id", report.ID,
                "requirements_count", len(report.Requirements),
        )

        return report, nil</span>
}

// updateCategoryStatus updates the status of a category based on its requirements
func (s *PCIDSSTrackingService) updateCategoryStatus(pciStatus *PCIDSSComplianceStatus, categoryID string) <span class="cov0" title="0">{
        categoryStatus := pciStatus.CategoryStatus[categoryID]

        var totalScore float64
        var requirementCount int
        var implementedCount int
        var verifiedCount int
        var nonCompliantCount int
        var exemptCount int

        // Calculate category status based on requirements
        for _, reqStatus := range pciStatus.RequirementsStatus </span><span class="cov0" title="0">{
                if reqStatus.CategoryID == categoryID </span><span class="cov0" title="0">{
                        requirementCount++
                        totalScore += reqStatus.ComplianceScore

                        switch reqStatus.Status </span>{
                        case ComplianceStatusVerified:<span class="cov0" title="0">
                                verifiedCount++</span>
                        case ComplianceStatusImplemented:<span class="cov0" title="0">
                                implementedCount++</span>
                        case ComplianceStatusNonCompliant:<span class="cov0" title="0">
                                nonCompliantCount++</span>
                        case ComplianceStatusExempt:<span class="cov0" title="0">
                                exemptCount++</span>
                        }
                }
        }

        <span class="cov0" title="0">if requirementCount &gt; 0 </span><span class="cov0" title="0">{
                categoryStatus.Score = totalScore / float64(requirementCount)
                categoryStatus.RequirementCount = requirementCount
                categoryStatus.ImplementedCount = implementedCount
                categoryStatus.VerifiedCount = verifiedCount
                categoryStatus.NonCompliantCount = nonCompliantCount
                categoryStatus.ExemptCount = exemptCount

                // Determine category status based on score
                if categoryStatus.Score &gt;= 90.0 </span><span class="cov0" title="0">{
                        categoryStatus.Status = ComplianceStatusVerified
                }</span> else<span class="cov0" title="0"> if categoryStatus.Score &gt;= 70.0 </span><span class="cov0" title="0">{
                        categoryStatus.Status = ComplianceStatusImplemented
                }</span> else<span class="cov0" title="0"> if categoryStatus.Score &gt;= 30.0 </span><span class="cov0" title="0">{
                        categoryStatus.Status = ComplianceStatusInProgress
                }</span> else<span class="cov0" title="0"> {
                        categoryStatus.Status = ComplianceStatusNotStarted
                }</span>
        }

        <span class="cov0" title="0">pciStatus.CategoryStatus[categoryID] = categoryStatus</span>
}

// updateOverallStatus updates the overall PCI DSS compliance status
func (s *PCIDSSTrackingService) updateOverallStatus(pciStatus *PCIDSSComplianceStatus) <span class="cov0" title="0">{
        var totalScore float64
        var categoryCount int

        // Calculate overall score based on category scores
        for _, categoryStatus := range pciStatus.CategoryStatus </span><span class="cov0" title="0">{
                totalScore += categoryStatus.Score
                categoryCount++
        }</span>

        <span class="cov0" title="0">if categoryCount &gt; 0 </span><span class="cov0" title="0">{
                pciStatus.ComplianceScore = totalScore / float64(categoryCount)
        }</span>

        // Determine overall status based on score
        <span class="cov0" title="0">if pciStatus.ComplianceScore &gt;= 90.0 </span><span class="cov0" title="0">{
                pciStatus.OverallStatus = ComplianceStatusVerified
        }</span> else<span class="cov0" title="0"> if pciStatus.ComplianceScore &gt;= 70.0 </span><span class="cov0" title="0">{
                pciStatus.OverallStatus = ComplianceStatusImplemented
        }</span> else<span class="cov0" title="0"> if pciStatus.ComplianceScore &gt;= 30.0 </span><span class="cov0" title="0">{
                pciStatus.OverallStatus = ComplianceStatusInProgress
        }</span> else<span class="cov0" title="0"> {
                pciStatus.OverallStatus = ComplianceStatusNotStarted
        }</span>
}

// assessCategory performs assessment for a specific category
func (s *PCIDSSTrackingService) assessCategory(ctx context.Context, pciStatus *PCIDSSComplianceStatus, categoryID string) float64 <span class="cov0" title="0">{
        var totalScore float64
        var requirementCount int

        // Calculate category score based on requirements
        for _, reqStatus := range pciStatus.RequirementsStatus </span><span class="cov0" title="0">{
                if reqStatus.CategoryID == categoryID </span><span class="cov0" title="0">{
                        requirementCount++
                        totalScore += reqStatus.ComplianceScore
                }</span>
        }

        <span class="cov0" title="0">if requirementCount &gt; 0 </span><span class="cov0" title="0">{
                return totalScore / float64(requirementCount)
        }</span>

        <span class="cov0" title="0">return 0.0</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package compliance

import (
        "context"
        "fmt"
        "sort"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// RecommendationEngine generates actionable recommendations based on gaps and scores
type RecommendationEngine struct {
        logger      *observability.Logger
        scoring     *ScoringEngine
        gapAnalyzer *GapAnalyzer
}

func NewRecommendationEngine(logger *observability.Logger, scoring *ScoringEngine, gapAnalyzer *GapAnalyzer) *RecommendationEngine <span class="cov0" title="0">{
        return &amp;RecommendationEngine{logger: logger, scoring: scoring, gapAnalyzer: gapAnalyzer}
}</span>

// GenerateRecommendations produces recommendations for a business across frameworks
// If frameworks is empty, caller should enumerate known ones.
func (e *RecommendationEngine) GenerateRecommendations(ctx context.Context, businessID string, frameworks []string) ([]ComplianceRecommendation, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        e.logger.Info("Generating compliance recommendations",
                "request_id", requestID,
                "business_id", businessID,
                "framework_count", len(frameworks),
        )

        if e.gapAnalyzer == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("gap analyzer not initialized")
        }</span>

        <span class="cov0" title="0">recs := make([]ComplianceRecommendation, 0)
        now := time.Now()

        for _, fw := range frameworks </span><span class="cov0" title="0">{
                report, err := e.gapAnalyzer.AnalyzeGaps(ctx, businessID, fw)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("gap analysis failed for %s: %w", fw, err)
                }</span>

                // Requirement gaps -&gt; recommendations
                <span class="cov0" title="0">for i := range report.RequirementGaps </span><span class="cov0" title="0">{
                        gap := report.RequirementGaps[i]
                        recs = append(recs, e.recForRequirementGap(fw, &amp;gap, now))
                }</span>

                // Control gaps -&gt; recommendations
                <span class="cov0" title="0">for i := range report.ControlGaps </span><span class="cov0" title="0">{
                        gap := report.ControlGaps[i]
                        recs = append(recs, e.recForControlGap(fw, &amp;gap, now))
                }</span>

                // Evidence gaps -&gt; recommendations
                <span class="cov0" title="0">for i := range report.EvidenceGaps </span><span class="cov0" title="0">{
                        gap := report.EvidenceGaps[i]
                        recs = append(recs, e.recForEvidenceGap(fw, &amp;gap, now))
                }</span>
        }

        // de-duplicate by (title+requirement/control) to avoid noise
        <span class="cov0" title="0">recs = dedupeRecommendations(recs)

        // stable order: priority (critical-&gt;low), then title
        sort.SliceStable(recs, func(i, j int) bool </span><span class="cov0" title="0">{
                pi := priorityRank(recs[i].Priority)
                pj := priorityRank(recs[j].Priority)
                if pi == pj </span><span class="cov0" title="0">{
                        return recs[i].Title &lt; recs[j].Title
                }</span>
                <span class="cov0" title="0">return pi &gt; pj</span>
        })

        <span class="cov0" title="0">e.logger.Info("Compliance recommendations generated",
                "request_id", requestID,
                "business_id", businessID,
                "count", len(recs),
        )

        return recs, nil</span>
}

func (e *RecommendationEngine) recForRequirementGap(framework string, gap *RequirementGap, now time.Time) ComplianceRecommendation <span class="cov0" title="0">{
        id := fmt.Sprintf("rec_req_%s_%s_%d", framework, gap.RequirementID, now.UnixNano())
        priority := priorityFromGapSeverity(gap.Severity)
        return ComplianceRecommendation{
                ID:            id,
                Type:          RecommendationTypeImplementation,
                Priority:      priority,
                Title:         fmt.Sprintf("%s: %s", framework, gap.Title),
                Description:   fmt.Sprintf("Gap: %s - %s", gap.GapType, gap.Description),
                Action:        gap.Recommendation,
                Timeline:      timelineFromPriority(priority),
                Impact:        impactFromPriority(priority),
                Effort:        effortFromGapType(gap.GapType),
                RequirementID: strPtr(gap.RequirementID),
                AssignedTo:    "compliance_officer",
                Status:        RecommendationStatusOpen,
                CreatedAt:     now,
                UpdatedAt:     now,
        }
}</span>

func (e *RecommendationEngine) recForControlGap(framework string, gap *ControlGap, now time.Time) ComplianceRecommendation <span class="cov0" title="0">{
        id := fmt.Sprintf("rec_ctrl_%s_%s_%d", framework, gap.ControlID, now.UnixNano())
        priority := priorityFromGapSeverity(gap.Severity)
        return ComplianceRecommendation{
                ID:            id,
                Type:          RecommendationTypeImplementation,
                Priority:      priority,
                Title:         fmt.Sprintf("%s Control: %s", framework, gap.Title),
                Description:   fmt.Sprintf("Gap: %s - %s", gap.GapType, gap.Description),
                Action:        gap.Recommendation,
                Timeline:      timelineFromPriority(priority),
                Impact:        impactFromPriority(priority),
                Effort:        effortFromGapType(gap.GapType),
                RequirementID: strPtr(gap.RequirementID),
                ControlID:     strPtr(gap.ControlID),
                AssignedTo:    "control_owner",
                Status:        RecommendationStatusOpen,
                CreatedAt:     now,
                UpdatedAt:     now,
        }
}</span>

func (e *RecommendationEngine) recForEvidenceGap(framework string, gap *EvidenceGap, now time.Time) ComplianceRecommendation <span class="cov0" title="0">{
        id := fmt.Sprintf("rec_evd_%s_%s_%s_%d", framework, gap.RequirementID, gap.ControlID, now.UnixNano())
        priority := CompliancePriorityMedium
        return ComplianceRecommendation{
                ID:            id,
                Type:          RecommendationTypeDocumentation,
                Priority:      priority,
                Title:         fmt.Sprintf("%s Evidence: Requirement %s", framework, gap.RequirementID),
                Description:   "Missing required evidence",
                Action:        gap.Recommendation,
                Timeline:      timelineFromPriority(priority),
                Impact:        impactFromPriority(priority),
                Effort:        "Low",
                RequirementID: strPtr(gap.RequirementID),
                ControlID:     strPtr(gap.ControlID),
                AssignedTo:    "compliance_analyst",
                Status:        RecommendationStatusOpen,
                CreatedAt:     now,
                UpdatedAt:     now,
        }
}</span>

// helpers

func strPtr(s string) *string <span class="cov0" title="0">{ return &amp;s }</span>

func dedupeRecommendations(in []ComplianceRecommendation) []ComplianceRecommendation <span class="cov0" title="0">{
        if len(in) == 0 </span><span class="cov0" title="0">{
                return in
        }</span>
        <span class="cov0" title="0">seen := make(map[string]bool)
        out := make([]ComplianceRecommendation, 0, len(in))
        for _, r := range in </span><span class="cov0" title="0">{
                key := fmt.Sprintf("%s|%s|%s|%s", r.Title, r.Description, valOrEmpty(r.RequirementID), valOrEmpty(r.ControlID))
                if !seen[key] </span><span class="cov0" title="0">{
                        seen[key] = true
                        out = append(out, r)
                }</span>
        }
        <span class="cov0" title="0">return out</span>
}

func valOrEmpty(p *string) string <span class="cov0" title="0">{
        if p == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return *p</span>
}

func priorityFromGapSeverity(sev GapSeverity) CompliancePriority <span class="cov0" title="0">{
        switch sev </span>{
        case GapSeverityCritical:<span class="cov0" title="0">
                return CompliancePriorityCritical</span>
        case GapSeverityHigh:<span class="cov0" title="0">
                return CompliancePriorityHigh</span>
        case GapSeverityMedium:<span class="cov0" title="0">
                return CompliancePriorityMedium</span>
        default:<span class="cov0" title="0">
                return CompliancePriorityLow</span>
        }
}

func priorityRank(p CompliancePriority) int <span class="cov0" title="0">{
        switch p </span>{
        case CompliancePriorityCritical:<span class="cov0" title="0">
                return 4</span>
        case CompliancePriorityHigh:<span class="cov0" title="0">
                return 3</span>
        case CompliancePriorityMedium:<span class="cov0" title="0">
                return 2</span>
        case CompliancePriorityLow:<span class="cov0" title="0">
                return 1</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

func timelineFromPriority(p CompliancePriority) string <span class="cov0" title="0">{
        switch p </span>{
        case CompliancePriorityCritical:<span class="cov0" title="0">
                return "1-2 weeks"</span>
        case CompliancePriorityHigh:<span class="cov0" title="0">
                return "2-4 weeks"</span>
        case CompliancePriorityMedium:<span class="cov0" title="0">
                return "4-8 weeks"</span>
        default:<span class="cov0" title="0">
                return "&gt; 8 weeks"</span>
        }
}

func impactFromPriority(p CompliancePriority) string <span class="cov0" title="0">{
        switch p </span>{
        case CompliancePriorityCritical:<span class="cov0" title="0">
                return "Critical - audit blocking"</span>
        case CompliancePriorityHigh:<span class="cov0" title="0">
                return "High - significant risk reduction"</span>
        case CompliancePriorityMedium:<span class="cov0" title="0">
                return "Medium - improves evidence and posture"</span>
        default:<span class="cov0" title="0">
                return "Low - hygiene improvement"</span>
        }
}

func effortFromGapType(gt GapType) string <span class="cov0" title="0">{
        switch gt </span>{
        case GapMissingRequirement, GapMissingControl:<span class="cov0" title="0">
                return "High"</span>
        case GapNonCompliant, GapIneffectiveControl:<span class="cov0" title="0">
                return "Medium"</span>
        case GapOverdueReview, GapOverdueControlTest, GapMissingEvidence, GapOpenException, GapRequirementNotReady:<span class="cov0" title="0">
                return "Low"</span>
        default:<span class="cov0" title="0">
                return "Medium"</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package compliance

import (
        "time"
)

// RegionalFramework defines the regional compliance frameworks
const (
        // Regional Framework Types
        FrameworkCCPA   = "CCPA"
        FrameworkLGPD   = "LGPD"
        FrameworkPIPEDA = "PIPEDA"
        FrameworkPOPIA  = "POPIA"
        FrameworkPDPA   = "PDPA"
        FrameworkAPPI   = "APPI"

        // CCPA Versions
        CCPAVersion2020 = "2020"
        CCPAVersion2023 = "2023"

        // LGPD Versions
        LGPDVersion2020 = "2020"
        LGPDVersion2021 = "2021"

        // PIPEDA Versions
        PIPEDAVersion2000 = "2000"
        PIPEDAVersion2015 = "2015"

        // POPIA Versions
        POPIAVersion2021 = "2021"

        // PDPA Versions
        PDPAVersion2012 = "2012"
        PDPAVersion2021 = "2021"

        // APPI Versions
        APPIVersion2003 = "2003"
        APPIVersion2022 = "2022"

        // CCPA Categories
        CCPACategoryConsumerRights      = "Consumer Rights"
        CCPACategoryBusinessObligations = "Business Obligations"
        CCPACategoryDataTransparency    = "Data Transparency"
        CCPACategoryEnforcement         = "Enforcement"

        // LGPD Categories
        LGPDCategoryLegalBasis          = "Legal Basis for Processing"
        LGPDCategoryDataSubjectRights   = "Data Subject Rights"
        LGPDCategoryBusinessObligations = "Business Obligations"
        LGPDCategoryDataProtection      = "Data Protection"

        // PIPEDA Categories
        PIPEDACategoryConsent               = "Consent"
        PIPEDACategoryLimitingCollection    = "Limiting Collection"
        PIPEDACategoryLimitingUse           = "Limiting Use, Disclosure, and Retention"
        PIPEDACategoryAccuracy              = "Accuracy"
        PIPEDACategorySafeguards            = "Safeguards"
        PIPEDACategoryOpenness              = "Openness"
        PIPEDACategoryIndividualAccess      = "Individual Access"
        PIPEDACategoryChallengingCompliance = "Challenging Compliance"
)

// RegionalRequirement represents a regional compliance requirement
type RegionalRequirement struct {
        ID                   string                 `json:"id"`
        RequirementID        string                 `json:"requirement_id"` // e.g., CCPA-1798.100, LGPD-Art.5
        Framework            string                 `json:"framework"`      // CCPA, LGPD, PIPEDA, etc.
        Category             string                 `json:"category"`       // Consumer Rights, Business Obligations, etc.
        Section              string                 `json:"section"`        // Legal section reference
        Title                string                 `json:"title"`
        Description          string                 `json:"description"`
        DetailedDescription  string                 `json:"detailed_description"`
        LegalBasis           []string               `json:"legal_basis"`
        DataSubjectRights    []string               `json:"data_subject_rights"`
        RiskLevel            ComplianceRiskLevel    `json:"risk_level"`
        Priority             CompliancePriority     `json:"priority"`
        ImplementationStatus ImplementationStatus   `json:"implementation_status"`
        EvidenceRequired     bool                   `json:"evidence_required"`
        EvidenceDescription  string                 `json:"evidence_description"`
        KeyControls          []string               `json:"key_controls"`
        SubRequirements      []RegionalRequirement  `json:"sub_requirements,omitempty"`
        ParentRequirementID  *string                `json:"parent_requirement_id,omitempty"`
        EffectiveDate        time.Time              `json:"effective_date"`
        LastUpdated          time.Time              `json:"last_updated"`
        NextReviewDate       time.Time              `json:"next_review_date"`
        ReviewFrequency      string                 `json:"review_frequency"`
        ComplianceOfficer    string                 `json:"compliance_officer"`
        Tags                 []string               `json:"tags"`
        Metadata             map[string]interface{} `json:"metadata,omitempty"`
}

// RegionalFrameworkDefinition represents a regional compliance framework
type RegionalFrameworkDefinition struct {
        ID              string                 `json:"id"`
        Name            string                 `json:"name"`
        Version         string                 `json:"version"`
        Description     string                 `json:"description"`
        Type            FrameworkType          `json:"type"`
        Jurisdiction    string                 `json:"jurisdiction"`
        GeographicScope []string               `json:"geographic_scope"`
        IndustryScope   []string               `json:"industry_scope"`
        EffectiveDate   time.Time              `json:"effective_date"`
        LastUpdated     time.Time              `json:"last_updated"`
        NextReviewDate  time.Time              `json:"next_review_date"`
        Requirements    []RegionalRequirement  `json:"requirements"`
        Categories      []RegionalCategory     `json:"categories"`
        MappingRules    []FrameworkMapping     `json:"mapping_rules"`
        Metadata        map[string]interface{} `json:"metadata,omitempty"`
}

// RegionalCategory represents a category within a regional framework
type RegionalCategory struct {
        ID            string                 `json:"id"`
        Name          string                 `json:"name"`
        Code          string                 `json:"code"`
        Description   string                 `json:"description"`
        Requirements  []string               `json:"requirements"` // Requirement IDs
        RiskLevel     ComplianceRiskLevel    `json:"risk_level"`
        Priority      CompliancePriority     `json:"priority"`
        EffectiveDate time.Time              `json:"effective_date"`
        LastUpdated   time.Time              `json:"last_updated"`
        Metadata      map[string]interface{} `json:"metadata,omitempty"`
}

// RegionalComplianceStatus represents regional compliance status
type RegionalComplianceStatus struct {
        BusinessID          string                               `json:"business_id"`
        Framework           string                               `json:"framework"`
        Version             string                               `json:"version"`
        Jurisdiction        string                               `json:"jurisdiction"`
        DataController      bool                                 `json:"data_controller"`
        DataProcessor       bool                                 `json:"data_processor"`
        OverallStatus       ComplianceStatus                     `json:"overall_status"`
        ComplianceScore     float64                              `json:"compliance_score"`
        CategoryStatus      map[string]RegionalCategoryStatus    `json:"category_status"`
        RequirementsStatus  map[string]RegionalRequirementStatus `json:"requirements_status"`
        LastAssessment      time.Time                            `json:"last_assessment"`
        NextAssessment      time.Time                            `json:"next_assessment"`
        AssessmentFrequency string                               `json:"assessment_frequency"`
        ComplianceOfficer   string                               `json:"compliance_officer"`
        RegulatoryAuthority string                               `json:"regulatory_authority,omitempty"`
        CertificationDate   *time.Time                           `json:"certification_date,omitempty"`
        CertificationExpiry *time.Time                           `json:"certification_expiry,omitempty"`
        CertificationBody   string                               `json:"certification_body,omitempty"`
        CertificationNumber string                               `json:"certification_number,omitempty"`
        Notes               string                               `json:"notes"`
        Metadata            map[string]interface{}               `json:"metadata,omitempty"`
}

// RegionalCategoryStatus represents status for a specific regional category
type RegionalCategoryStatus struct {
        CategoryID        string           `json:"category_id"`
        CategoryName      string           `json:"category_name"`
        Status            ComplianceStatus `json:"status"`
        Score             float64          `json:"score"`
        RequirementCount  int              `json:"requirement_count"`
        ImplementedCount  int              `json:"implemented_count"`
        VerifiedCount     int              `json:"verified_count"`
        NonCompliantCount int              `json:"non_compliant_count"`
        ExemptCount       int              `json:"exempt_count"`
        LastReviewed      time.Time        `json:"last_reviewed"`
        NextReview        time.Time        `json:"next_review"`
        Reviewer          string           `json:"reviewer"`
        Notes             string           `json:"notes"`
}

// RegionalRequirementStatus represents status for a specific regional requirement
type RegionalRequirementStatus struct {
        RequirementID        string               `json:"requirement_id"`
        FrameworkID          string               `json:"framework_id"`
        CategoryID           string               `json:"category_id"`
        Title                string               `json:"title"`
        Status               ComplianceStatus     `json:"status"`
        ImplementationStatus ImplementationStatus `json:"implementation_status"`
        ComplianceScore      float64              `json:"compliance_score"`
        RiskLevel            ComplianceRiskLevel  `json:"risk_level"`
        Priority             CompliancePriority   `json:"priority"`
        LastReviewed         time.Time            `json:"last_reviewed"`
        NextReview           time.Time            `json:"next_review"`
        Reviewer             string               `json:"reviewer"`
        EvidenceCount        int                  `json:"evidence_count"`
        ExceptionCount       int                  `json:"exception_count"`
        RemediationPlanCount int                  `json:"remediation_plan_count"`
        Trend                string               `json:"trend"`
        TrendStrength        string               `json:"trend_strength"`
        Notes                string               `json:"notes"`
}

// NewCCPAFramework creates a new CCPA framework definition
func NewCCPAFramework() *RegionalFrameworkDefinition <span class="cov8" title="1">{
        return &amp;RegionalFrameworkDefinition{
                ID:              FrameworkCCPA,
                Name:            "California Consumer Privacy Act",
                Version:         CCPAVersion2023,
                Description:     "The CCPA is a state statute intended to enhance privacy rights and consumer protection for residents of California",
                Type:            FrameworkTypePrivacy,
                Jurisdiction:    "California, United States",
                GeographicScope: []string{"California", "United States"},
                IndustryScope:   []string{"All Industries"},
                EffectiveDate:   time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC),
                LastUpdated:     time.Now(),
                NextReviewDate:  time.Now().AddDate(1, 0, 0),
                Requirements:    getCCPARequirements(),
                Categories:      getCCPACategories(),
                Metadata:        make(map[string]interface{}),
        }
}</span>

// NewLGPDFramework creates a new LGPD framework definition
func NewLGPDFramework() *RegionalFrameworkDefinition <span class="cov8" title="1">{
        return &amp;RegionalFrameworkDefinition{
                ID:              FrameworkLGPD,
                Name:            "Lei Geral de Proteo de Dados",
                Version:         LGPDVersion2021,
                Description:     "The LGPD is Brazil's comprehensive data protection law that regulates the processing of personal data",
                Type:            FrameworkTypePrivacy,
                Jurisdiction:    "Brazil",
                GeographicScope: []string{"Brazil"},
                IndustryScope:   []string{"All Industries"},
                EffectiveDate:   time.Date(2021, 9, 18, 0, 0, 0, 0, time.UTC),
                LastUpdated:     time.Now(),
                NextReviewDate:  time.Now().AddDate(1, 0, 0),
                Requirements:    getLGPDRequirements(),
                Categories:      getLGPDCategories(),
                Metadata:        make(map[string]interface{}),
        }
}</span>

// NewPIPEDAFramework creates a new PIPEDA framework definition
func NewPIPEDAFramework() *RegionalFrameworkDefinition <span class="cov8" title="1">{
        return &amp;RegionalFrameworkDefinition{
                ID:              FrameworkPIPEDA,
                Name:            "Personal Information Protection and Electronic Documents Act",
                Version:         PIPEDAVersion2015,
                Description:     "PIPEDA is Canada's federal privacy law for private-sector organizations",
                Type:            FrameworkTypePrivacy,
                Jurisdiction:    "Canada",
                GeographicScope: []string{"Canada"},
                IndustryScope:   []string{"All Industries"},
                EffectiveDate:   time.Date(2015, 6, 18, 0, 0, 0, 0, time.UTC),
                LastUpdated:     time.Now(),
                NextReviewDate:  time.Now().AddDate(1, 0, 0),
                Requirements:    getPIPEDARequirements(),
                Categories:      getPIPEDACategories(),
                Metadata:        make(map[string]interface{}),
        }
}</span>

// NewPOPIAFramework creates a new POPIA framework definition
func NewPOPIAFramework() *RegionalFrameworkDefinition <span class="cov8" title="1">{
        return &amp;RegionalFrameworkDefinition{
                ID:              FrameworkPOPIA,
                Name:            "Protection of Personal Information Act",
                Version:         POPIAVersion2021,
                Description:     "POPIA is South Africa's comprehensive data protection law that regulates the processing of personal information",
                Type:            FrameworkTypePrivacy,
                Jurisdiction:    "South Africa",
                GeographicScope: []string{"South Africa"},
                IndustryScope:   []string{"All Industries"},
                EffectiveDate:   time.Date(2021, 7, 1, 0, 0, 0, 0, time.UTC),
                LastUpdated:     time.Now(),
                NextReviewDate:  time.Now().AddDate(1, 0, 0),
                Requirements:    getPOPIARequirements(),
                Categories:      getPOPIACategories(),
                Metadata:        make(map[string]interface{}),
        }
}</span>

// NewPDPAFramework creates a new PDPA framework definition
func NewPDPAFramework() *RegionalFrameworkDefinition <span class="cov8" title="1">{
        return &amp;RegionalFrameworkDefinition{
                ID:              FrameworkPDPA,
                Name:            "Personal Data Protection Act",
                Version:         PDPAVersion2021,
                Description:     "PDPA is Singapore's comprehensive data protection law that governs the collection, use, and disclosure of personal data",
                Type:            FrameworkTypePrivacy,
                Jurisdiction:    "Singapore",
                GeographicScope: []string{"Singapore"},
                IndustryScope:   []string{"All Industries"},
                EffectiveDate:   time.Date(2021, 2, 1, 0, 0, 0, 0, time.UTC),
                LastUpdated:     time.Now(),
                NextReviewDate:  time.Now().AddDate(1, 0, 0),
                Requirements:    getPDPARequirements(),
                Categories:      getPDPACategories(),
                Metadata:        make(map[string]interface{}),
        }
}</span>

// NewAPPIFramework creates a new APPI framework definition
func NewAPPIFramework() *RegionalFrameworkDefinition <span class="cov8" title="1">{
        return &amp;RegionalFrameworkDefinition{
                ID:              FrameworkAPPI,
                Name:            "Act on the Protection of Personal Information",
                Version:         APPIVersion2022,
                Description:     "APPI is Japan's comprehensive data protection law that regulates the handling of personal information",
                Type:            FrameworkTypePrivacy,
                Jurisdiction:    "Japan",
                GeographicScope: []string{"Japan"},
                IndustryScope:   []string{"All Industries"},
                EffectiveDate:   time.Date(2022, 4, 1, 0, 0, 0, 0, time.UTC),
                LastUpdated:     time.Now(),
                NextReviewDate:  time.Now().AddDate(1, 0, 0),
                Requirements:    getAPPIRequirements(),
                Categories:      getAPPICategories(),
                Metadata:        make(map[string]interface{}),
        }
}</span>

// getCCPACategories returns the CCPA categories
func getCCPACategories() []RegionalCategory <span class="cov8" title="1">{
        return []RegionalCategory{
                {
                        ID:           CCPACategoryConsumerRights,
                        Name:         "Consumer Rights",
                        Code:         "CCPA-Rights",
                        Description:  "Consumer rights under CCPA including access, deletion, and opt-out",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"CCPA-1798.100", "CCPA-1798.105", "CCPA-1798.110", "CCPA-1798.115", "CCPA-1798.120", "CCPA-1798.125"},
                },
                {
                        ID:           CCPACategoryBusinessObligations,
                        Name:         "Business Obligations",
                        Code:         "CCPA-Obligations",
                        Description:  "Business obligations for data handling and consumer requests",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"CCPA-1798.130", "CCPA-1798.135", "CCPA-1798.140", "CCPA-1798.145"},
                },
                {
                        ID:           CCPACategoryDataTransparency,
                        Name:         "Data Transparency",
                        Code:         "CCPA-Transparency",
                        Description:  "Requirements for data transparency and disclosure",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"CCPA-1798.100", "CCPA-1798.130", "CCPA-1798.135"},
                },
                {
                        ID:           CCPACategoryEnforcement,
                        Name:         "Enforcement",
                        Code:         "CCPA-Enforcement",
                        Description:  "Enforcement mechanisms and penalties",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"CCPA-1798.150", "CCPA-1798.155", "CCPA-1798.160"},
                },
        }
}</span>

// getLGPDCategories returns the LGPD categories
func getLGPDCategories() []RegionalCategory <span class="cov8" title="1">{
        return []RegionalCategory{
                {
                        ID:           LGPDCategoryLegalBasis,
                        Name:         "Legal Basis for Processing",
                        Code:         "LGPD-Basis",
                        Description:  "Legal basis for processing personal data under LGPD",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"LGPD-Art.7", "LGPD-Art.8", "LGPD-Art.9", "LGPD-Art.10", "LGPD-Art.11"},
                },
                {
                        ID:           LGPDCategoryDataSubjectRights,
                        Name:         "Data Subject Rights",
                        Code:         "LGPD-Rights",
                        Description:  "Data subject rights under LGPD",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"LGPD-Art.18", "LGPD-Art.19", "LGPD-Art.20", "LGPD-Art.21", "LGPD-Art.22"},
                },
                {
                        ID:           LGPDCategoryBusinessObligations,
                        Name:         "Business Obligations",
                        Code:         "LGPD-Obligations",
                        Description:  "Business obligations for data processing",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"LGPD-Art.6", "LGPD-Art.12", "LGPD-Art.13", "LGPD-Art.14", "LGPD-Art.15"},
                },
                {
                        ID:           LGPDCategoryDataProtection,
                        Name:         "Data Protection",
                        Code:         "LGPD-Protection",
                        Description:  "Data protection and security requirements",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"LGPD-Art.46", "LGPD-Art.47", "LGPD-Art.48", "LGPD-Art.49"},
                },
        }
}</span>

// getPIPEDACategories returns the PIPEDA categories
func getPIPEDACategories() []RegionalCategory <span class="cov8" title="1">{
        return []RegionalCategory{
                {
                        ID:           PIPEDACategoryConsent,
                        Name:         "Consent",
                        Code:         "PIPEDA-Consent",
                        Description:  "Consent requirements for data collection and use",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"PIPEDA-Principle1", "PIPEDA-Principle2"},
                },
                {
                        ID:           PIPEDACategoryLimitingCollection,
                        Name:         "Limiting Collection",
                        Code:         "PIPEDA-LimitingCollection",
                        Description:  "Limiting collection of personal information",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"PIPEDA-Principle4", "PIPEDA-Principle5"},
                },
                {
                        ID:           PIPEDACategoryLimitingUse,
                        Name:         "Limiting Use, Disclosure, and Retention",
                        Code:         "PIPEDA-LimitingUse",
                        Description:  "Limiting use, disclosure, and retention of personal information",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"PIPEDA-Principle5", "PIPEDA-Principle6"},
                },
                {
                        ID:           PIPEDACategoryAccuracy,
                        Name:         "Accuracy",
                        Code:         "PIPEDA-Accuracy",
                        Description:  "Accuracy of personal information",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"PIPEDA-Principle6"},
                },
                {
                        ID:           PIPEDACategorySafeguards,
                        Name:         "Safeguards",
                        Code:         "PIPEDA-Safeguards",
                        Description:  "Security safeguards for personal information",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"PIPEDA-Principle7"},
                },
                {
                        ID:           PIPEDACategoryOpenness,
                        Name:         "Openness",
                        Code:         "PIPEDA-Openness",
                        Description:  "Openness about policies and practices",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"PIPEDA-Principle8"},
                },
                {
                        ID:           PIPEDACategoryIndividualAccess,
                        Name:         "Individual Access",
                        Code:         "PIPEDA-IndividualAccess",
                        Description:  "Individual access to personal information",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"PIPEDA-Principle9"},
                },
                {
                        ID:           PIPEDACategoryChallengingCompliance,
                        Name:         "Challenging Compliance",
                        Code:         "PIPEDA-ChallengingCompliance",
                        Description:  "Challenging compliance with PIPEDA principles",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"PIPEDA-Principle10"},
                },
        }
}</span>

// getPOPIACategories returns the POPIA categories
func getPOPIACategories() []RegionalCategory <span class="cov8" title="1">{
        return []RegionalCategory{
                {
                        ID:           "POPIA-ProcessingLimitation",
                        Name:         "Processing Limitation",
                        Code:         "POPIA-ProcessingLimitation",
                        Description:  "Limitations on processing personal information",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"POPIA-Section9", "POPIA-Section10", "POPIA-Section11", "POPIA-Section12"},
                },
                {
                        ID:           "POPIA-PurposeSpecification",
                        Name:         "Purpose Specification",
                        Code:         "POPIA-PurposeSpecification",
                        Description:  "Specification of purpose for processing",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"POPIA-Section13", "POPIA-Section14", "POPIA-Section15"},
                },
                {
                        ID:           "POPIA-InformationQuality",
                        Name:         "Information Quality",
                        Code:         "POPIA-InformationQuality",
                        Description:  "Quality of personal information",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"POPIA-Section16", "POPIA-Section17"},
                },
                {
                        ID:           "POPIA-Openness",
                        Name:         "Openness",
                        Code:         "POPIA-Openness",
                        Description:  "Openness about processing operations",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"POPIA-Section18", "POPIA-Section19"},
                },
                {
                        ID:           "POPIA-SecuritySafeguards",
                        Name:         "Security Safeguards",
                        Code:         "POPIA-SecuritySafeguards",
                        Description:  "Security safeguards for personal information",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"POPIA-Section19", "POPIA-Section20", "POPIA-Section21"},
                },
                {
                        ID:           "POPIA-DataSubjectParticipation",
                        Name:         "Data Subject Participation",
                        Code:         "POPIA-DataSubjectParticipation",
                        Description:  "Data subject participation rights",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"POPIA-Section22", "POPIA-Section23", "POPIA-Section24", "POPIA-Section25"},
                },
        }
}</span>

// getPDPACategories returns the PDPA categories
func getPDPACategories() []RegionalCategory <span class="cov8" title="1">{
        return []RegionalCategory{
                {
                        ID:           "PDPA-Consent",
                        Name:         "Consent",
                        Code:         "PDPA-Consent",
                        Description:  "Consent requirements for data collection and use",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"PDPA-Section13", "PDPA-Section14", "PDPA-Section15"},
                },
                {
                        ID:           "PDPA-PurposeLimitation",
                        Name:         "Purpose Limitation",
                        Code:         "PDPA-PurposeLimitation",
                        Description:  "Limitation of purpose for data processing",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"PDPA-Section25", "PDPA-Section26"},
                },
                {
                        ID:           "PDPA-Notification",
                        Name:         "Notification",
                        Code:         "PDPA-Notification",
                        Description:  "Notification requirements for data breaches",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"PDPA-Section26D", "PDPA-Section26E"},
                },
                {
                        ID:           "PDPA-TransferLimitation",
                        Name:         "Transfer Limitation",
                        Code:         "PDPA-TransferLimitation",
                        Description:  "Limitations on data transfers",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"PDPA-Section26", "PDPA-Section27"},
                },
                {
                        ID:           "PDPA-AccessCorrection",
                        Name:         "Access and Correction",
                        Code:         "PDPA-AccessCorrection",
                        Description:  "Access and correction rights",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"PDPA-Section21", "PDPA-Section22", "PDPA-Section23"},
                },
                {
                        ID:           "PDPA-Accuracy",
                        Name:         "Accuracy",
                        Code:         "PDPA-Accuracy",
                        Description:  "Accuracy of personal data",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"PDPA-Section23"},
                },
                {
                        ID:           "PDPA-Protection",
                        Name:         "Protection",
                        Code:         "PDPA-Protection",
                        Description:  "Protection of personal data",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"PDPA-Section24"},
                },
                {
                        ID:           "PDPA-RetentionLimitation",
                        Name:         "Retention Limitation",
                        Code:         "PDPA-RetentionLimitation",
                        Description:  "Limitation of data retention",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"PDPA-Section25"},
                },
        }
}</span>

// getAPPICategories returns the APPI categories
func getAPPICategories() []RegionalCategory <span class="cov8" title="1">{
        return []RegionalCategory{
                {
                        ID:           "APPI-PurposeSpecification",
                        Name:         "Purpose Specification",
                        Code:         "APPI-PurposeSpecification",
                        Description:  "Specification of purpose for personal information handling",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"APPI-Article15", "APPI-Article16", "APPI-Article17"},
                },
                {
                        ID:           "APPI-UseLimitation",
                        Name:         "Use Limitation",
                        Code:         "APPI-UseLimitation",
                        Description:  "Limitation of use of personal information",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"APPI-Article16", "APPI-Article17", "APPI-Article18"},
                },
                {
                        ID:           "APPI-AcquisitionLimitation",
                        Name:         "Acquisition Limitation",
                        Code:         "APPI-AcquisitionLimitation",
                        Description:  "Limitation of acquisition of personal information",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"APPI-Article17", "APPI-Article18"},
                },
                {
                        ID:           "APPI-SecurityControl",
                        Name:         "Security Control",
                        Code:         "APPI-SecurityControl",
                        Description:  "Security control measures for personal information",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"APPI-Article20", "APPI-Article21", "APPI-Article22"},
                },
                {
                        ID:           "APPI-Supervision",
                        Name:         "Supervision",
                        Code:         "APPI-Supervision",
                        Description:  "Supervision of personal information handling",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"APPI-Article23", "APPI-Article24"},
                },
                {
                        ID:           "APPI-IndividualRights",
                        Name:         "Individual Rights",
                        Code:         "APPI-IndividualRights",
                        Description:  "Rights of individuals regarding their personal information",
                        RiskLevel:    ComplianceRiskLevelHigh,
                        Priority:     CompliancePriorityHigh,
                        Requirements: []string{"APPI-Article28", "APPI-Article29", "APPI-Article30"},
                },
                {
                        ID:           "APPI-Remedies",
                        Name:         "Remedies",
                        Code:         "APPI-Remedies",
                        Description:  "Remedies for violations of personal information protection",
                        RiskLevel:    ComplianceRiskLevelMedium,
                        Priority:     CompliancePriorityMedium,
                        Requirements: []string{"APPI-Article31", "APPI-Article32", "APPI-Article33"},
                },
        }
}</span>

// getCCPARequirements returns the CCPA requirements
func getCCPARequirements() []RegionalRequirement <span class="cov8" title="1">{
        return []RegionalRequirement{
                {
                        ID:                   "CCPA-1798.100",
                        RequirementID:        "CCPA-1798.100",
                        Framework:            FrameworkCCPA,
                        Category:             CCPACategoryConsumerRights,
                        Section:              "1798.100",
                        Title:                "General Duties of Businesses that Collect Personal Information",
                        Description:          "Businesses must inform consumers about the categories of personal information collected and the purposes for which it is used",
                        DetailedDescription:  "Businesses that collect personal information must inform consumers at or before the point of collection about the categories of personal information to be collected and the purposes for which the categories of personal information shall be used",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Privacy notices, collection point disclosures, purpose documentation",
                        KeyControls:          []string{"Privacy Notices", "Collection Point Disclosures", "Purpose Documentation", "Consumer Notification"},
                        EffectiveDate:        time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"consumer-rights", "transparency", "collection-notice"},
                },
                {
                        ID:                   "CCPA-1798.105",
                        RequirementID:        "CCPA-1798.105",
                        Framework:            FrameworkCCPA,
                        Category:             CCPACategoryConsumerRights,
                        Section:              "1798.105",
                        Title:                "Right to Deletion",
                        Description:          "Consumers have the right to request deletion of their personal information",
                        DetailedDescription:  "A consumer shall have the right to request that a business delete any personal information about the consumer which the business has collected from the consumer",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Deletion request procedures, verification processes, deletion confirmation",
                        KeyControls:          []string{"Deletion Request Procedures", "Verification Processes", "Deletion Confirmation", "Third-party Notification"},
                        EffectiveDate:        time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"consumer-rights", "deletion", "right-to-be-forgotten"},
                },
                {
                        ID:                   "CCPA-1798.110",
                        RequirementID:        "CCPA-1798.110",
                        Framework:            FrameworkCCPA,
                        Category:             CCPACategoryConsumerRights,
                        Section:              "1798.110",
                        Title:                "Right to Know",
                        Description:          "Consumers have the right to know what personal information is collected and how it is used",
                        DetailedDescription:  "A consumer shall have the right to request that a business that collects personal information about the consumer disclose to the consumer the categories and specific pieces of personal information the business has collected",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Access request procedures, data inventory, response templates",
                        KeyControls:          []string{"Access Request Procedures", "Data Inventory", "Response Templates", "Verification"},
                        EffectiveDate:        time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"consumer-rights", "access", "transparency"},
                },
                {
                        ID:                   "CCPA-1798.120",
                        RequirementID:        "CCPA-1798.120",
                        Framework:            FrameworkCCPA,
                        Category:             CCPACategoryConsumerRights,
                        Section:              "1798.120",
                        Title:                "Right to Opt-Out",
                        Description:          "Consumers have the right to opt-out of the sale or sharing of personal information",
                        DetailedDescription:  "A consumer shall have the right, at any time, to direct a business that sells or shares personal information about the consumer to third parties not to sell or share the consumer's personal information",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Opt-out mechanisms, preference management, third-party compliance",
                        KeyControls:          []string{"Opt-out Mechanisms", "Preference Management", "Third-party Compliance", "Do Not Sell"},
                        EffectiveDate:        time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"consumer-rights", "opt-out", "do-not-sell"},
                },
        }
}</span>

// getLGPDRequirements returns the LGPD requirements
func getLGPDRequirements() []RegionalRequirement <span class="cov8" title="1">{
        return []RegionalRequirement{
                {
                        ID:                   "LGPD-Art.7",
                        RequirementID:        "LGPD-Art.7",
                        Framework:            FrameworkLGPD,
                        Category:             LGPDCategoryLegalBasis,
                        Section:              "Article 7",
                        Title:                "Legal Basis for Processing",
                        Description:          "Legal basis for processing personal data under LGPD",
                        DetailedDescription:  "Personal data may only be processed on the basis of legal grounds or for legitimate purposes, including consent, compliance with legal obligations, and legitimate interests",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Legal basis documentation, consent records, legitimate interest assessments",
                        KeyControls:          []string{"Legal Basis Documentation", "Consent Management", "Legitimate Interest Assessment", "Compliance Records"},
                        EffectiveDate:        time.Date(2021, 9, 18, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"legal-basis", "consent", "legitimate-interests"},
                },
                {
                        ID:                   "LGPD-Art.18",
                        RequirementID:        "LGPD-Art.18",
                        Framework:            FrameworkLGPD,
                        Category:             LGPDCategoryDataSubjectRights,
                        Section:              "Article 18",
                        Title:                "Data Subject Rights",
                        Description:          "Data subject rights under LGPD",
                        DetailedDescription:  "Data subjects have the right to confirmation of the existence of processing, access to data, correction of incomplete or inaccurate data, and other rights",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Rights request procedures, response templates, verification processes",
                        KeyControls:          []string{"Rights Request Procedures", "Response Templates", "Verification Processes", "Data Access"},
                        EffectiveDate:        time.Date(2021, 9, 18, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"data-subject-rights", "access", "correction"},
                },
                {
                        ID:                   "LGPD-Art.46",
                        RequirementID:        "LGPD-Art.46",
                        Framework:            FrameworkLGPD,
                        Category:             LGPDCategoryDataProtection,
                        Section:              "Article 46",
                        Title:                "Security Measures",
                        Description:          "Security measures for personal data processing",
                        DetailedDescription:  "Processing agents shall adopt security, technical and administrative measures able to protect personal data from unauthorized access and accidental or unlawful situations",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Security measures documentation, risk assessments, incident response procedures",
                        KeyControls:          []string{"Security Measures", "Risk Assessments", "Incident Response", "Access Controls"},
                        EffectiveDate:        time.Date(2021, 9, 18, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"security", "data-protection", "technical-measures"},
                },
        }
}</span>

// getPIPEDARequirements returns the PIPEDA requirements
func getPIPEDARequirements() []RegionalRequirement <span class="cov8" title="1">{
        return []RegionalRequirement{
                {
                        ID:                   "PIPEDA-Principle1",
                        RequirementID:        "PIPEDA-Principle1",
                        Framework:            FrameworkPIPEDA,
                        Category:             PIPEDACategoryConsent,
                        Section:              "Principle 1",
                        Title:                "Accountability",
                        Description:          "Organizations are accountable for personal information under their control",
                        DetailedDescription:  "An organization is responsible for personal information in its possession or custody, including information that has been transferred to a third party for processing",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Accountability policies, responsibility assignment, third-party oversight",
                        KeyControls:          []string{"Accountability Policies", "Responsibility Assignment", "Third-party Oversight", "Compliance Monitoring"},
                        EffectiveDate:        time.Date(2015, 6, 18, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"accountability", "responsibility", "oversight"},
                },
                {
                        ID:                   "PIPEDA-Principle2",
                        RequirementID:        "PIPEDA-Principle2",
                        Framework:            FrameworkPIPEDA,
                        Category:             PIPEDACategoryConsent,
                        Section:              "Principle 2",
                        Title:                "Identifying Purposes",
                        Description:          "Organizations must identify the purposes for which personal information is collected",
                        DetailedDescription:  "The purposes for which personal information is collected shall be identified by the organization at or before the time the information is collected",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Purpose documentation, collection notices, purpose identification",
                        KeyControls:          []string{"Purpose Documentation", "Collection Notices", "Purpose Identification", "Consent Management"},
                        EffectiveDate:        time.Date(2015, 6, 18, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"purpose-limitation", "consent", "transparency"},
                },
                {
                        ID:                   "PIPEDA-Principle7",
                        RequirementID:        "PIPEDA-Principle7",
                        Framework:            FrameworkPIPEDA,
                        Category:             PIPEDACategorySafeguards,
                        Section:              "Principle 7",
                        Title:                "Safeguards",
                        Description:          "Personal information shall be protected by security safeguards",
                        DetailedDescription:  "Personal information shall be protected by security safeguards appropriate to the sensitivity of the information",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Security safeguards documentation, risk assessments, protection measures",
                        KeyControls:          []string{"Security Safeguards", "Risk Assessments", "Protection Measures", "Access Controls"},
                        EffectiveDate:        time.Date(2015, 6, 18, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"security", "safeguards", "protection"},
                },
        }
}</span>

// getPOPIARequirements returns the POPIA requirements
func getPOPIARequirements() []RegionalRequirement <span class="cov8" title="1">{
        return []RegionalRequirement{
                {
                        ID:                   "POPIA-Section9",
                        RequirementID:        "POPIA-Section9",
                        Framework:            FrameworkPOPIA,
                        Category:             "POPIA-ProcessingLimitation",
                        Section:              "Section 9",
                        Title:                "Processing Limitation",
                        Description:          "Personal information may only be processed if it is adequate, relevant and not excessive",
                        DetailedDescription:  "Personal information may only be processed if, given the purpose for which it is processed, it is adequate, relevant and not excessive",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Processing limitation policies, adequacy assessments, relevance documentation",
                        KeyControls:          []string{"Processing Limitation Policies", "Adequacy Assessments", "Relevance Documentation", "Excessiveness Reviews"},
                        EffectiveDate:        time.Date(2021, 7, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"processing-limitation", "adequacy", "relevance"},
                },
                {
                        ID:                   "POPIA-Section13",
                        RequirementID:        "POPIA-Section13",
                        Framework:            FrameworkPOPIA,
                        Category:             "POPIA-PurposeSpecification",
                        Section:              "Section 13",
                        Title:                "Purpose Specification",
                        Description:          "Personal information must be collected for a specific, explicitly defined and lawful purpose",
                        DetailedDescription:  "Personal information must be collected for a specific, explicitly defined and lawful purpose related to a function or activity of the responsible party",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Purpose specification documentation, lawful basis assessment, function mapping",
                        KeyControls:          []string{"Purpose Specification", "Lawful Basis Assessment", "Function Mapping", "Purpose Documentation"},
                        EffectiveDate:        time.Date(2021, 7, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"purpose-specification", "lawful-basis", "function-activity"},
                },
                {
                        ID:                   "POPIA-Section19",
                        RequirementID:        "POPIA-Section19",
                        Framework:            FrameworkPOPIA,
                        Category:             "POPIA-SecuritySafeguards",
                        Section:              "Section 19",
                        Title:                "Security Safeguards",
                        Description:          "A responsible party must secure the integrity and confidentiality of personal information",
                        DetailedDescription:  "A responsible party must secure the integrity and confidentiality of personal information in its possession or under its control by taking appropriate, reasonable technical and organisational measures",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Security measures documentation, technical controls, organizational measures",
                        KeyControls:          []string{"Security Measures", "Technical Controls", "Organizational Measures", "Integrity Protection"},
                        EffectiveDate:        time.Date(2021, 7, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"security", "integrity", "confidentiality"},
                },
        }
}</span>

// getPDPARequirements returns the PDPA requirements
func getPDPARequirements() []RegionalRequirement <span class="cov8" title="1">{
        return []RegionalRequirement{
                {
                        ID:                   "PDPA-Section13",
                        RequirementID:        "PDPA-Section13",
                        Framework:            FrameworkPDPA,
                        Category:             "PDPA-Consent",
                        Section:              "Section 13",
                        Title:                "Consent Required",
                        Description:          "An organization shall not collect, use or disclose personal data about an individual unless the individual gives, or is deemed to have given, consent",
                        DetailedDescription:  "An organization shall not, on or after the appointed day, collect, use or disclose personal data about an individual unless the individual gives, or is deemed to have given, consent",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Consent management procedures, consent records, deemed consent documentation",
                        KeyControls:          []string{"Consent Management", "Consent Records", "Deemed Consent Documentation", "Consent Validation"},
                        EffectiveDate:        time.Date(2021, 2, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"consent", "collection", "use", "disclosure"},
                },
                {
                        ID:                   "PDPA-Section24",
                        RequirementID:        "PDPA-Section24",
                        Framework:            FrameworkPDPA,
                        Category:             "PDPA-Protection",
                        Section:              "Section 24",
                        Title:                "Protection of Personal Data",
                        Description:          "An organization shall protect personal data in its possession or under its control by making reasonable security arrangements",
                        DetailedDescription:  "An organization shall protect personal data in its possession or under its control by making reasonable security arrangements to prevent unauthorized access, collection, use, disclosure, copying, modification, disposal or similar risks",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Security arrangements documentation, access controls, risk assessments",
                        KeyControls:          []string{"Security Arrangements", "Access Controls", "Risk Assessments", "Protection Measures"},
                        EffectiveDate:        time.Date(2021, 2, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"protection", "security", "unauthorized-access"},
                },
                {
                        ID:                   "PDPA-Section26D",
                        RequirementID:        "PDPA-Section26D",
                        Framework:            FrameworkPDPA,
                        Category:             "PDPA-Notification",
                        Section:              "Section 26D",
                        Title:                "Data Breach Notification",
                        Description:          "An organization shall, as soon as practicable, assess whether it is notifiable data breach",
                        DetailedDescription:  "An organization shall, as soon as practicable, assess whether it is notifiable data breach and notify the Commission and affected individuals",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Breach assessment procedures, notification templates, incident response plans",
                        KeyControls:          []string{"Breach Assessment", "Notification Procedures", "Incident Response", "Commission Notification"},
                        EffectiveDate:        time.Date(2021, 2, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"data-breach", "notification", "incident-response"},
                },
        }
}</span>

// getAPPIRequirements returns the APPI requirements
func getAPPIRequirements() []RegionalRequirement <span class="cov8" title="1">{
        return []RegionalRequirement{
                {
                        ID:                   "APPI-Article15",
                        RequirementID:        "APPI-Article15",
                        Framework:            FrameworkAPPI,
                        Category:             "APPI-PurposeSpecification",
                        Section:              "Article 15",
                        Title:                "Purpose Specification",
                        Description:          "A personal information handling business operator shall specify the purpose of utilization as much as possible",
                        DetailedDescription:  "A personal information handling business operator shall specify the purpose of utilization of personal information as much as possible",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Purpose specification documentation, utilization scope definition, purpose clarity",
                        KeyControls:          []string{"Purpose Specification", "Utilization Scope", "Purpose Clarity", "Documentation"},
                        EffectiveDate:        time.Date(2022, 4, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"purpose-specification", "utilization", "clarity"},
                },
                {
                        ID:                   "APPI-Article20",
                        RequirementID:        "APPI-Article20",
                        Framework:            FrameworkAPPI,
                        Category:             "APPI-SecurityControl",
                        Section:              "Article 20",
                        Title:                "Security Control Measures",
                        Description:          "A personal information handling business operator shall take necessary and proper measures for the prevention of leakage, loss, or damage",
                        DetailedDescription:  "A personal information handling business operator shall take necessary and proper measures for the prevention of leakage, loss, or damage, and for other security control of personal data",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Security control measures documentation, leakage prevention, loss prevention, damage prevention",
                        KeyControls:          []string{"Security Control Measures", "Leakage Prevention", "Loss Prevention", "Damage Prevention"},
                        EffectiveDate:        time.Date(2022, 4, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"security-control", "leakage-prevention", "data-protection"},
                },
                {
                        ID:                   "APPI-Article28",
                        RequirementID:        "APPI-Article28",
                        Framework:            FrameworkAPPI,
                        Category:             "APPI-IndividualRights",
                        Section:              "Article 28",
                        Title:                "Individual Rights",
                        Description:          "An individual may request disclosure of personal data held by a personal information handling business operator",
                        DetailedDescription:  "An individual may request disclosure of personal data held by a personal information handling business operator",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Disclosure request procedures, response templates, verification processes",
                        KeyControls:          []string{"Disclosure Request Procedures", "Response Templates", "Verification Processes", "Data Access"},
                        EffectiveDate:        time.Date(2022, 4, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"individual-rights", "disclosure", "data-access"},
                },
        }
}</span>

// ConvertRegionalToRegulatoryFramework converts RegionalFrameworkDefinition to RegulatoryFramework
func (regional *RegionalFrameworkDefinition) ConvertRegionalToRegulatoryFramework() *RegulatoryFramework <span class="cov8" title="1">{
        requirements := make([]ComplianceRequirement, len(regional.Requirements))
        for i, req := range regional.Requirements </span><span class="cov8" title="1">{
                requirements[i] = ComplianceRequirement{
                        ID:                   req.ID,
                        Framework:            regional.ID,
                        Category:             req.Category,
                        RequirementID:        req.RequirementID,
                        Title:                req.Title,
                        Description:          req.Description,
                        DetailedDescription:  req.DetailedDescription,
                        RiskLevel:            req.RiskLevel,
                        Priority:             req.Priority,
                        Status:               ComplianceStatusNotStarted,
                        ImplementationStatus: req.ImplementationStatus,
                        EvidenceRequired:     req.EvidenceRequired,
                        EvidenceDescription:  req.EvidenceDescription,
                        Controls:             []ComplianceControl{},
                        SubRequirements:      []ComplianceRequirement{},
                        ParentRequirementID:  req.ParentRequirementID,
                        ApplicableBusinesses: []string{},
                        GeographicScope:      regional.GeographicScope,
                        IndustryScope:        regional.IndustryScope,
                        EffectiveDate:        req.EffectiveDate,
                        LastUpdated:          req.LastUpdated,
                        NextReviewDate:       req.NextReviewDate,
                        ReviewFrequency:      req.ReviewFrequency,
                        ComplianceOfficer:    req.ComplianceOfficer,
                        Tags:                 req.Tags,
                        Metadata:             req.Metadata,
                }
        }</span>

        <span class="cov8" title="1">return &amp;RegulatoryFramework{
                ID:              regional.ID,
                Name:            regional.Name,
                Version:         regional.Version,
                Description:     regional.Description,
                Type:            regional.Type,
                Jurisdiction:    regional.Jurisdiction,
                GeographicScope: regional.GeographicScope,
                IndustryScope:   regional.IndustryScope,
                EffectiveDate:   regional.EffectiveDate,
                LastUpdated:     regional.LastUpdated,
                NextReviewDate:  regional.NextReviewDate,
                Requirements:    requirements,
                MappingRules:    regional.MappingRules,
                Metadata:        regional.Metadata,
        }</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package compliance

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// RegionalTrackingService provides regional compliance tracking for multiple frameworks
type RegionalTrackingService struct {
        logger        *observability.Logger
        statusSystem  *ComplianceStatusSystem
        mappingSystem *FrameworkMappingSystem
        mu            sync.RWMutex
        regionalData  map[string]map[string]*RegionalComplianceStatus // businessID -&gt; framework -&gt; status
}

// NewRegionalTrackingService creates a new regional tracking service
func NewRegionalTrackingService(logger *observability.Logger, statusSystem *ComplianceStatusSystem, mappingSystem *FrameworkMappingSystem) *RegionalTrackingService <span class="cov0" title="0">{
        return &amp;RegionalTrackingService{
                logger:        logger,
                statusSystem:  statusSystem,
                mappingSystem: mappingSystem,
                regionalData:  make(map[string]map[string]*RegionalComplianceStatus),
        }
}</span>

// InitializeRegionalTracking initializes regional compliance tracking for a business
func (s *RegionalTrackingService) InitializeRegionalTracking(ctx context.Context, businessID string, framework string, jurisdiction string, dataController bool, dataProcessor bool) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Initializing regional compliance tracking for business",
                "request_id", requestID,
                "business_id", businessID,
                "framework", framework,
                "jurisdiction", jurisdiction,
                "data_controller", dataController,
                "data_processor", dataProcessor,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        // Validate framework
        validFrameworks := []string{FrameworkCCPA, FrameworkLGPD, FrameworkPIPEDA, FrameworkPOPIA, FrameworkPDPA, FrameworkAPPI}
        validFramework := false
        for _, fw := range validFrameworks </span><span class="cov0" title="0">{
                if framework == fw </span><span class="cov0" title="0">{
                        validFramework = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !validFramework </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid framework: %s. Must be one of: %v", framework, validFrameworks)
        }</span>

        // Check if regional tracking already exists for this business and framework
        <span class="cov0" title="0">if s.regionalData[businessID] == nil </span><span class="cov0" title="0">{
                s.regionalData[businessID] = make(map[string]*RegionalComplianceStatus)
        }</span>
        <span class="cov0" title="0">if _, exists := s.regionalData[businessID][framework]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("regional tracking for framework %s already initialized for business %s", framework, businessID)
        }</span>

        // Validate that at least one role is specified
        <span class="cov0" title="0">if !dataController &amp;&amp; !dataProcessor </span><span class="cov0" title="0">{
                return fmt.Errorf("business must be either a data controller or data processor")
        }</span>

        // Get framework definition
        <span class="cov0" title="0">var frameworkDef *RegionalFrameworkDefinition
        switch framework </span>{
        case FrameworkCCPA:<span class="cov0" title="0">
                frameworkDef = NewCCPAFramework()</span>
        case FrameworkLGPD:<span class="cov0" title="0">
                frameworkDef = NewLGPDFramework()</span>
        case FrameworkPIPEDA:<span class="cov0" title="0">
                frameworkDef = NewPIPEDAFramework()</span>
        case FrameworkPOPIA:<span class="cov0" title="0">
                frameworkDef = NewPOPIAFramework()</span>
        case FrameworkPDPA:<span class="cov0" title="0">
                frameworkDef = NewPDPAFramework()</span>
        case FrameworkAPPI:<span class="cov0" title="0">
                frameworkDef = NewAPPIFramework()</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("framework %s not yet implemented", framework)</span>
        }

        // Create new regional compliance status
        <span class="cov0" title="0">regionalStatus := &amp;RegionalComplianceStatus{
                BusinessID:          businessID,
                Framework:           framework,
                Version:             frameworkDef.Version,
                Jurisdiction:        jurisdiction,
                DataController:      dataController,
                DataProcessor:       dataProcessor,
                OverallStatus:       ComplianceStatusNotStarted,
                ComplianceScore:     0.0,
                CategoryStatus:      make(map[string]RegionalCategoryStatus),
                RequirementsStatus:  make(map[string]RegionalRequirementStatus),
                LastAssessment:      time.Now(),
                NextAssessment:      time.Now().AddDate(1, 0, 0),
                AssessmentFrequency: "annually",
                ComplianceOfficer:   "system",
                Metadata:            make(map[string]interface{}),
        }

        // Initialize category status
        for _, category := range frameworkDef.Categories </span><span class="cov0" title="0">{
                regionalStatus.CategoryStatus[category.ID] = RegionalCategoryStatus{
                        CategoryID:       category.ID,
                        CategoryName:     category.Name,
                        Status:           ComplianceStatusNotStarted,
                        Score:            0.0,
                        RequirementCount: 0,
                        LastReviewed:     time.Now(),
                        NextReview:       time.Now().AddDate(0, 6, 0),
                        Reviewer:         "system",
                }
        }</span>

        // Initialize requirements status
        <span class="cov0" title="0">for _, requirement := range frameworkDef.Requirements </span><span class="cov0" title="0">{
                regionalStatus.RequirementsStatus[requirement.RequirementID] = RegionalRequirementStatus{
                        RequirementID:        requirement.RequirementID,
                        FrameworkID:          framework,
                        CategoryID:           requirement.Category,
                        Title:                requirement.Title,
                        Status:               ComplianceStatusNotStarted,
                        ImplementationStatus: requirement.ImplementationStatus,
                        ComplianceScore:      0.0,
                        RiskLevel:            requirement.RiskLevel,
                        Priority:             requirement.Priority,
                        LastReviewed:         time.Now(),
                        NextReview:           requirement.NextReviewDate,
                        Reviewer:             "system",
                        EvidenceCount:        0,
                        ExceptionCount:       0,
                        RemediationPlanCount: 0,
                        Trend:                "stable",
                        TrendStrength:        "none",
                }
        }</span>

        // Store the regional status
        <span class="cov0" title="0">s.regionalData[businessID][framework] = regionalStatus

        // Register regional framework with mapping system if not already registered
        regionalRegulatoryFramework := frameworkDef.ConvertRegionalToRegulatoryFramework()
        err := s.mappingSystem.RegisterFramework(ctx, regionalRegulatoryFramework)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to register regional framework with mapping system",
                        "request_id", requestID,
                        "business_id", businessID,
                        "framework", framework,
                        "error", err.Error(),
                )
                // Don't fail the initialization for this
        }</span>

        <span class="cov0" title="0">s.logger.Info("Regional compliance tracking initialized successfully",
                "request_id", requestID,
                "business_id", businessID,
                "framework", framework,
                "jurisdiction", jurisdiction,
                "category_count", len(regionalStatus.CategoryStatus),
                "requirements_count", len(regionalStatus.RequirementsStatus),
        )

        return nil</span>
}

// GetRegionalStatus retrieves regional compliance status for a business and framework
func (s *RegionalTrackingService) GetRegionalStatus(ctx context.Context, businessID string, framework string) (*RegionalComplianceStatus, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.mu.RLock()
        defer s.mu.RUnlock()

        if s.regionalData[businessID] == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("regional tracking not initialized for business %s", businessID)
        }</span>

        <span class="cov0" title="0">regionalStatus, exists := s.regionalData[businessID][framework]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("regional tracking for framework %s not initialized for business %s", framework, businessID)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Retrieved regional compliance status",
                "request_id", requestID,
                "business_id", businessID,
                "framework", framework,
                "overall_status", regionalStatus.OverallStatus,
                "compliance_score", regionalStatus.ComplianceScore,
        )

        return regionalStatus, nil</span>
}

// UpdateRegionalRequirementStatus updates the status of a specific regional requirement
func (s *RegionalTrackingService) UpdateRegionalRequirementStatus(ctx context.Context, businessID, framework, requirementID string, status ComplianceStatus, implementationStatus ImplementationStatus, score float64, reviewer string) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Updating regional requirement status",
                "request_id", requestID,
                "business_id", businessID,
                "framework", framework,
                "requirement_id", requirementID,
                "status", status,
                "implementation_status", implementationStatus,
                "score", score,
                "reviewer", reviewer,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        if s.regionalData[businessID] == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("regional tracking not initialized for business %s", businessID)
        }</span>

        <span class="cov0" title="0">regionalStatus, exists := s.regionalData[businessID][framework]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("regional tracking for framework %s not initialized for business %s", framework, businessID)
        }</span>

        <span class="cov0" title="0">reqStatus, exists := regionalStatus.RequirementsStatus[requirementID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("requirement %s not found in regional framework %s", requirementID, framework)
        }</span>

        // Update requirement status
        <span class="cov0" title="0">reqStatus.Status = status
        reqStatus.ImplementationStatus = implementationStatus
        reqStatus.ComplianceScore = score
        reqStatus.LastReviewed = time.Now()
        reqStatus.Reviewer = reviewer

        regionalStatus.RequirementsStatus[requirementID] = reqStatus

        // Update category status
        s.updateRegionalCategoryStatus(regionalStatus, reqStatus.CategoryID)

        // Update overall status
        s.updateRegionalOverallStatus(regionalStatus)

        s.logger.Info("Regional requirement status updated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "framework", framework,
                "requirement_id", requirementID,
                "new_status", status,
                "new_score", score,
        )

        return nil</span>
}

// UpdateRegionalCategoryStatus updates the status of a specific regional category
func (s *RegionalTrackingService) UpdateRegionalCategoryStatus(ctx context.Context, businessID, framework, categoryID string, status ComplianceStatus, score float64, reviewer string) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Updating regional category status",
                "request_id", requestID,
                "business_id", businessID,
                "framework", framework,
                "category_id", categoryID,
                "status", status,
                "score", score,
                "reviewer", reviewer,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        if s.regionalData[businessID] == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("regional tracking not initialized for business %s", businessID)
        }</span>

        <span class="cov0" title="0">regionalStatus, exists := s.regionalData[businessID][framework]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("regional tracking for framework %s not initialized for business %s", framework, businessID)
        }</span>

        <span class="cov0" title="0">categoryStatus, exists := regionalStatus.CategoryStatus[categoryID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("category %s not found in regional framework %s", categoryID, framework)
        }</span>

        // Update category status
        <span class="cov0" title="0">categoryStatus.Status = status
        categoryStatus.Score = score
        categoryStatus.LastReviewed = time.Now()
        categoryStatus.Reviewer = reviewer

        regionalStatus.CategoryStatus[categoryID] = categoryStatus

        // Update overall status
        s.updateRegionalOverallStatus(regionalStatus)

        s.logger.Info("Regional category status updated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "framework", framework,
                "category_id", categoryID,
                "new_status", status,
                "new_score", score,
        )

        return nil</span>
}

// AssessRegionalCompliance performs a comprehensive regional compliance assessment
func (s *RegionalTrackingService) AssessRegionalCompliance(ctx context.Context, businessID string, framework string) (*RegionalComplianceStatus, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Starting regional compliance assessment",
                "request_id", requestID,
                "business_id", businessID,
                "framework", framework,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        if s.regionalData[businessID] == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("regional tracking not initialized for business %s", businessID)
        }</span>

        <span class="cov0" title="0">regionalStatus, exists := s.regionalData[businessID][framework]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("regional tracking for framework %s not initialized for business %s", framework, businessID)
        }</span>

        // Get framework definition
        <span class="cov0" title="0">var frameworkDef *RegionalFrameworkDefinition
        switch framework </span>{
        case FrameworkCCPA:<span class="cov0" title="0">
                frameworkDef = NewCCPAFramework()</span>
        case FrameworkLGPD:<span class="cov0" title="0">
                frameworkDef = NewLGPDFramework()</span>
        case FrameworkPIPEDA:<span class="cov0" title="0">
                frameworkDef = NewPIPEDAFramework()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("framework %s not yet implemented", framework)</span>
        }

        // Perform assessment for each category
        <span class="cov0" title="0">for _, category := range frameworkDef.Categories </span><span class="cov0" title="0">{
                categoryScore := s.assessRegionalCategory(ctx, regionalStatus, category.ID)
                categoryStatus := regionalStatus.CategoryStatus[category.ID]
                categoryStatus.Score = categoryScore
                categoryStatus.LastReviewed = time.Now()
                categoryStatus.Reviewer = "system"

                // Determine category status based on score
                if categoryScore &gt;= 90.0 </span><span class="cov0" title="0">{
                        categoryStatus.Status = ComplianceStatusVerified
                }</span> else<span class="cov0" title="0"> if categoryScore &gt;= 70.0 </span><span class="cov0" title="0">{
                        categoryStatus.Status = ComplianceStatusImplemented
                }</span> else<span class="cov0" title="0"> if categoryScore &gt;= 30.0 </span><span class="cov0" title="0">{
                        categoryStatus.Status = ComplianceStatusInProgress
                }</span> else<span class="cov0" title="0"> {
                        categoryStatus.Status = ComplianceStatusNotStarted
                }</span>

                <span class="cov0" title="0">regionalStatus.CategoryStatus[category.ID] = categoryStatus</span>
        }

        // Update overall status
        <span class="cov0" title="0">s.updateRegionalOverallStatus(regionalStatus)

        // Update assessment timestamp
        regionalStatus.LastAssessment = time.Now()
        regionalStatus.NextAssessment = time.Now().AddDate(1, 0, 0)

        s.logger.Info("Regional compliance assessment completed",
                "request_id", requestID,
                "business_id", businessID,
                "framework", framework,
                "overall_status", regionalStatus.OverallStatus,
                "compliance_score", regionalStatus.ComplianceScore,
        )

        return regionalStatus, nil</span>
}

// GetRegionalReport generates a regional compliance report
func (s *RegionalTrackingService) GetRegionalReport(ctx context.Context, businessID string, framework string, reportType string) (*ComplianceReport, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Generating regional compliance report",
                "request_id", requestID,
                "business_id", businessID,
                "framework", framework,
                "report_type", reportType,
        )

        regionalStatus, err := s.GetRegionalStatus(ctx, businessID, framework)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert regional status to compliance report
        <span class="cov0" title="0">report := &amp;ComplianceReport{
                ID:               fmt.Sprintf("regional_report_%s_%s_%s", framework, businessID, time.Now().Format("20060102")),
                BusinessID:       businessID,
                Framework:        framework,
                ReportType:       ReportTypeStatus,
                Title:            fmt.Sprintf("%s Compliance Report - %s", framework, businessID),
                Description:      fmt.Sprintf("%s compliance assessment report", framework),
                GeneratedAt:      time.Now(),
                GeneratedBy:      "system",
                Period:           "annual",
                OverallStatus:    regionalStatus.OverallStatus,
                ComplianceScore:  regionalStatus.ComplianceScore,
                Requirements:     []RequirementReport{},
                Controls:         []ControlReport{},
                Exceptions:       []ExceptionReport{},
                RemediationPlans: []RemediationReport{},
                Recommendations:  []ComplianceRecommendation{},
                Metadata:         make(map[string]interface{}),
        }

        // Add regional specific metadata
        report.Metadata["framework"] = framework
        report.Metadata["version"] = regionalStatus.Version
        report.Metadata["jurisdiction"] = regionalStatus.Jurisdiction
        report.Metadata["data_controller"] = regionalStatus.DataController
        report.Metadata["data_processor"] = regionalStatus.DataProcessor
        report.Metadata["category_count"] = len(regionalStatus.CategoryStatus)
        report.Metadata["requirements_count"] = len(regionalStatus.RequirementsStatus)

        // Convert requirements to report format
        for reqID, reqStatus := range regionalStatus.RequirementsStatus </span><span class="cov0" title="0">{
                requirementReport := RequirementReport{
                        RequirementID:        reqID,
                        Title:                reqStatus.Title,
                        Status:               reqStatus.Status,
                        ImplementationStatus: reqStatus.ImplementationStatus,
                        ComplianceScore:      reqStatus.ComplianceScore,
                        RiskLevel:            reqStatus.RiskLevel,
                        Priority:             reqStatus.Priority,
                        LastReviewed:         reqStatus.LastReviewed,
                        NextReview:           reqStatus.NextReview,
                        Controls:             []ControlReport{},
                        Exceptions:           []ExceptionReport{},
                        RemediationPlans:     []RemediationReport{},
                }
                report.Requirements = append(report.Requirements, requirementReport)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Regional compliance report generated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "framework", framework,
                "report_id", report.ID,
                "requirements_count", len(report.Requirements),
        )

        return report, nil</span>
}

// GetSupportedFrameworks returns the list of supported regional frameworks
func (s *RegionalTrackingService) GetSupportedFrameworks(ctx context.Context) []string <span class="cov0" title="0">{
        return []string{
                FrameworkCCPA,
                FrameworkLGPD,
                FrameworkPIPEDA,
                FrameworkPOPIA,
                FrameworkPDPA,
                FrameworkAPPI,
        }
}</span>

// updateRegionalCategoryStatus updates the status of a category based on its requirements
func (s *RegionalTrackingService) updateRegionalCategoryStatus(regionalStatus *RegionalComplianceStatus, categoryID string) <span class="cov0" title="0">{
        categoryStatus := regionalStatus.CategoryStatus[categoryID]

        var totalScore float64
        var requirementCount int
        var implementedCount int
        var verifiedCount int
        var nonCompliantCount int
        var exemptCount int

        // Calculate category status based on requirements
        for _, reqStatus := range regionalStatus.RequirementsStatus </span><span class="cov0" title="0">{
                if reqStatus.CategoryID == categoryID </span><span class="cov0" title="0">{
                        requirementCount++
                        totalScore += reqStatus.ComplianceScore

                        switch reqStatus.Status </span>{
                        case ComplianceStatusVerified:<span class="cov0" title="0">
                                verifiedCount++</span>
                        case ComplianceStatusImplemented:<span class="cov0" title="0">
                                implementedCount++</span>
                        case ComplianceStatusNonCompliant:<span class="cov0" title="0">
                                nonCompliantCount++</span>
                        case ComplianceStatusExempt:<span class="cov0" title="0">
                                exemptCount++</span>
                        }
                }
        }

        <span class="cov0" title="0">if requirementCount &gt; 0 </span><span class="cov0" title="0">{
                categoryStatus.Score = totalScore / float64(requirementCount)
                categoryStatus.RequirementCount = requirementCount
                categoryStatus.ImplementedCount = implementedCount
                categoryStatus.VerifiedCount = verifiedCount
                categoryStatus.NonCompliantCount = nonCompliantCount
                categoryStatus.ExemptCount = exemptCount

                // Determine category status based on score
                if categoryStatus.Score &gt;= 90.0 </span><span class="cov0" title="0">{
                        categoryStatus.Status = ComplianceStatusVerified
                }</span> else<span class="cov0" title="0"> if categoryStatus.Score &gt;= 70.0 </span><span class="cov0" title="0">{
                        categoryStatus.Status = ComplianceStatusImplemented
                }</span> else<span class="cov0" title="0"> if categoryStatus.Score &gt;= 30.0 </span><span class="cov0" title="0">{
                        categoryStatus.Status = ComplianceStatusInProgress
                }</span> else<span class="cov0" title="0"> {
                        categoryStatus.Status = ComplianceStatusNotStarted
                }</span>
        }

        <span class="cov0" title="0">regionalStatus.CategoryStatus[categoryID] = categoryStatus</span>
}

// updateRegionalOverallStatus updates the overall regional compliance status
func (s *RegionalTrackingService) updateRegionalOverallStatus(regionalStatus *RegionalComplianceStatus) <span class="cov0" title="0">{
        var totalScore float64
        var categoryCount int

        // Calculate overall score based on category scores
        for _, categoryStatus := range regionalStatus.CategoryStatus </span><span class="cov0" title="0">{
                totalScore += categoryStatus.Score
                categoryCount++
        }</span>

        <span class="cov0" title="0">if categoryCount &gt; 0 </span><span class="cov0" title="0">{
                regionalStatus.ComplianceScore = totalScore / float64(categoryCount)
        }</span>

        // Determine overall status based on score
        <span class="cov0" title="0">if regionalStatus.ComplianceScore &gt;= 90.0 </span><span class="cov0" title="0">{
                regionalStatus.OverallStatus = ComplianceStatusVerified
        }</span> else<span class="cov0" title="0"> if regionalStatus.ComplianceScore &gt;= 70.0 </span><span class="cov0" title="0">{
                regionalStatus.OverallStatus = ComplianceStatusImplemented
        }</span> else<span class="cov0" title="0"> if regionalStatus.ComplianceScore &gt;= 30.0 </span><span class="cov0" title="0">{
                regionalStatus.OverallStatus = ComplianceStatusInProgress
        }</span> else<span class="cov0" title="0"> {
                regionalStatus.OverallStatus = ComplianceStatusNotStarted
        }</span>
}

// assessRegionalCategory performs assessment for a specific category
func (s *RegionalTrackingService) assessRegionalCategory(ctx context.Context, regionalStatus *RegionalComplianceStatus, categoryID string) float64 <span class="cov0" title="0">{
        var totalScore float64
        var requirementCount int

        // Calculate category score based on requirements
        for _, reqStatus := range regionalStatus.RequirementsStatus </span><span class="cov0" title="0">{
                if reqStatus.CategoryID == categoryID </span><span class="cov0" title="0">{
                        requirementCount++
                        totalScore += reqStatus.ComplianceScore
                }</span>
        }

        <span class="cov0" title="0">if requirementCount &gt; 0 </span><span class="cov0" title="0">{
                return totalScore / float64(requirementCount)
        }</span>

        <span class="cov0" title="0">return 0.0</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package compliance

import (
        "context"
        "fmt"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// ReportGenerationService provides comprehensive compliance report generation functionality
type ReportGenerationService struct {
        logger          *observability.Logger
        checkEngine     *CheckEngine
        tracking        *TrackingSystem
        gapAnalyzer     *GapAnalyzer
        recommendations *RecommendationEngine
}

// NewReportGenerationService creates a new compliance report generation service
func NewReportGenerationService(logger *observability.Logger, checkEngine *CheckEngine, tracking *TrackingSystem, gapAnalyzer *GapAnalyzer, recommendations *RecommendationEngine) *ReportGenerationService <span class="cov8" title="1">{
        return &amp;ReportGenerationService{
                logger:          logger,
                checkEngine:     checkEngine,
                tracking:        tracking,
                gapAnalyzer:     gapAnalyzer,
                recommendations: recommendations,
        }
}</span>

// ReportRequest represents a request to generate a compliance report
type ReportRequest struct {
        BusinessID     string                 `json:"business_id"`
        Framework      string                 `json:"framework,omitempty"` // if empty, generate for all frameworks
        ReportType     ReportType             `json:"report_type"`
        Format         ReportFormat           `json:"format,omitempty"`
        DateRange      *DateRange             `json:"date_range,omitempty"`
        IncludeDetails bool                   `json:"include_details,omitempty"`
        GeneratedBy    string                 `json:"generated_by"`
        Metadata       map[string]interface{} `json:"metadata,omitempty"`
}

// DateRange represents a date range for report generation
type DateRange struct {
        StartDate time.Time `json:"start_date"`
        EndDate   time.Time `json:"end_date"`
}

// ReportFormat represents the format of the report
type ReportFormat string

const (
        ReportFormatJSON ReportFormat = "json"
        ReportFormatPDF  ReportFormat = "pdf"
        ReportFormatHTML ReportFormat = "html"
        ReportFormatCSV  ReportFormat = "csv"
)

// GenerateComplianceReport generates a comprehensive compliance report
func (s *ReportGenerationService) GenerateComplianceReport(ctx context.Context, request ReportRequest) (*ComplianceReport, error) <span class="cov8" title="1">{
        requestID := ""
        if ctx.Value("request_id") != nil </span><span class="cov8" title="1">{
                requestID = ctx.Value("request_id").(string)
        }</span>

        <span class="cov8" title="1">s.logger.Info("Generating compliance report",
                "request_id", requestID,
                "business_id", request.BusinessID,
                "framework", request.Framework,
                "report_type", request.ReportType,
                "format", request.Format,
        )

        // Validate request
        if request.BusinessID == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("business_id is required")
        }</span>

        <span class="cov8" title="1">if request.ReportType == "" </span><span class="cov8" title="1">{
                request.ReportType = ReportTypeStatus // Default to status report
        }</span>

        <span class="cov8" title="1">if request.Format == "" </span><span class="cov8" title="1">{
                request.Format = ReportFormatJSON // Default to JSON
        }</span>

        // Determine frameworks to include
        <span class="cov8" title="1">frameworks, err := s.getFrameworksToInclude(ctx, request.BusinessID, request.Framework)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to determine frameworks: %w", err)
        }</span>

        // Generate report based on type
        <span class="cov0" title="0">var report *ComplianceReport
        switch request.ReportType </span>{
        case ReportTypeStatus:<span class="cov0" title="0">
                report, err = s.generateStatusReport(ctx, request, frameworks)</span>
        case ReportTypeGap:<span class="cov0" title="0">
                report, err = s.generateGapReport(ctx, request, frameworks)</span>
        case ReportTypeRemediation:<span class="cov0" title="0">
                report, err = s.generateRemediationReport(ctx, request, frameworks)</span>
        case ReportTypeAudit:<span class="cov0" title="0">
                report, err = s.generateAuditReport(ctx, request, frameworks)</span>
        case ReportTypeExecutive:<span class="cov0" title="0">
                report, err = s.generateExecutiveReport(ctx, request, frameworks)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported report type: %s", request.ReportType)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate %s report: %w", request.ReportType, err)
        }</span>

        // Set common report fields
        <span class="cov0" title="0">report.GeneratedBy = request.GeneratedBy
        report.Metadata = request.Metadata

        s.logger.Info("Compliance report generated successfully",
                "request_id", requestID,
                "business_id", request.BusinessID,
                "report_type", request.ReportType,
                "framework_count", len(frameworks),
                "requirement_count", len(report.Requirements),
                "control_count", len(report.Controls),
        )

        return report, nil</span>
}

// generateStatusReport generates a status report showing current compliance status
func (s *ReportGenerationService) generateStatusReport(ctx context.Context, request ReportRequest, frameworks []string) (*ComplianceReport, error) <span class="cov0" title="0">{
        report := &amp;ComplianceReport{
                ID:          fmt.Sprintf("status_report_%s_%d", request.BusinessID, time.Now().Unix()),
                BusinessID:  request.BusinessID,
                ReportType:  ReportTypeStatus,
                Title:       "Compliance Status Report",
                Description: "Current compliance status across all frameworks",
                GeneratedAt: time.Now(),
                Period:      "current",
        }

        // Get compliance check results
        checkReq := CheckRequest{
                BusinessID: request.BusinessID,
                Frameworks: frameworks,
                Options:    EvaluationOptions{},
        }

        checkResp, err := s.checkEngine.Check(ctx, checkReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to run compliance check: %w", err)
        }</span>

        // Calculate overall status and score
        <span class="cov0" title="0">report.OverallStatus, report.ComplianceScore = s.calculateOverallStatus(checkResp)

        // Build requirements and controls from check results
        report.Requirements, report.Controls = s.buildRequirementsAndControls(ctx, checkResp, request.IncludeDetails)

        // Get recommendations
        if s.recommendations != nil </span><span class="cov0" title="0">{
                recommendations, err := s.recommendations.GenerateRecommendations(ctx, request.BusinessID, frameworks)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to generate recommendations", "error", err.Error())
                }</span> else<span class="cov0" title="0"> {
                        report.Recommendations = recommendations
                }</span>
        }

        <span class="cov0" title="0">return report, nil</span>
}

// generateGapReport generates a gap analysis report
func (s *ReportGenerationService) generateGapReport(ctx context.Context, request ReportRequest, frameworks []string) (*ComplianceReport, error) <span class="cov0" title="0">{
        report := &amp;ComplianceReport{
                ID:          fmt.Sprintf("gap_report_%s_%d", request.BusinessID, time.Now().Unix()),
                BusinessID:  request.BusinessID,
                ReportType:  ReportTypeGap,
                Title:       "Compliance Gap Analysis Report",
                Description: "Detailed analysis of compliance gaps and remediation needs",
                GeneratedAt: time.Now(),
                Period:      "current",
        }

        // Run gap analysis for each framework
        for _, framework := range frameworks </span><span class="cov0" title="0">{
                gapReport, err := s.gapAnalyzer.AnalyzeGaps(ctx, request.BusinessID, framework)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to analyze gaps for framework", "framework", framework, "error", err.Error())
                        continue</span>
                }

                // Convert gap analysis to report format
                <span class="cov0" title="0">requirements, controls := s.convertGapAnalysisToReport(ctx, gapReport)
                report.Requirements = append(report.Requirements, requirements...)
                report.Controls = append(report.Controls, controls...)</span>
        }

        // Calculate overall status based on gaps
        <span class="cov0" title="0">report.OverallStatus, report.ComplianceScore = s.calculateStatusFromGaps(report.Requirements, report.Controls)

        // Get remediation recommendations
        if s.recommendations != nil </span><span class="cov0" title="0">{
                recommendations, err := s.recommendations.GenerateRecommendations(ctx, request.BusinessID, frameworks)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to generate recommendations", "error", err.Error())
                }</span> else<span class="cov0" title="0"> {
                        report.Recommendations = recommendations
                }</span>
        }

        <span class="cov0" title="0">return report, nil</span>
}

// generateRemediationReport generates a remediation-focused report
func (s *ReportGenerationService) generateRemediationReport(ctx context.Context, request ReportRequest, frameworks []string) (*ComplianceReport, error) <span class="cov0" title="0">{
        report := &amp;ComplianceReport{
                ID:          fmt.Sprintf("remediation_report_%s_%d", request.BusinessID, time.Now().Unix()),
                BusinessID:  request.BusinessID,
                ReportType:  ReportTypeRemediation,
                Title:       "Compliance Remediation Report",
                Description: "Comprehensive remediation plans and progress tracking",
                GeneratedAt: time.Now(),
                Period:      "current",
        }

        // Get tracking data for remediation information
        for _, framework := range frameworks </span><span class="cov0" title="0">{
                tracking, err := s.tracking.GetComplianceTracking(ctx, request.BusinessID, framework)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to get tracking for framework", "framework", framework, "error", err.Error())
                        continue</span>
                }

                // Extract remediation plans and exceptions
                <span class="cov0" title="0">requirements, remediationPlans, exceptions := s.extractRemediationData(ctx, tracking)
                report.Requirements = append(report.Requirements, requirements...)
                report.RemediationPlans = append(report.RemediationPlans, remediationPlans...)
                report.Exceptions = append(report.Exceptions, exceptions...)</span>
        }

        // Calculate overall status
        <span class="cov0" title="0">report.OverallStatus, report.ComplianceScore = s.calculateStatusFromRemediation(report.Requirements, report.RemediationPlans)

        return report, nil</span>
}

// generateAuditReport generates an audit-focused report
func (s *ReportGenerationService) generateAuditReport(ctx context.Context, request ReportRequest, frameworks []string) (*ComplianceReport, error) <span class="cov0" title="0">{
        report := &amp;ComplianceReport{
                ID:          fmt.Sprintf("audit_report_%s_%d", request.BusinessID, time.Now().Unix()),
                BusinessID:  request.BusinessID,
                ReportType:  ReportTypeAudit,
                Title:       "Compliance Audit Report",
                Description: "Audit-focused compliance report with evidence and testing results",
                GeneratedAt: time.Now(),
                Period:      "current",
        }

        // Get tracking data for audit information
        for _, framework := range frameworks </span><span class="cov0" title="0">{
                tracking, err := s.tracking.GetComplianceTracking(ctx, request.BusinessID, framework)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to get tracking for framework", "framework", framework, "error", err.Error())
                        continue</span>
                }

                // Extract audit-related data
                <span class="cov0" title="0">requirements, controls := s.extractAuditData(ctx, tracking)
                report.Requirements = append(report.Requirements, requirements...)
                report.Controls = append(report.Controls, controls...)</span>
        }

        // Calculate overall status
        <span class="cov0" title="0">report.OverallStatus, report.ComplianceScore = s.calculateStatusFromAudit(report.Requirements, report.Controls)

        return report, nil</span>
}

// generateExecutiveReport generates an executive summary report
func (s *ReportGenerationService) generateExecutiveReport(ctx context.Context, request ReportRequest, frameworks []string) (*ComplianceReport, error) <span class="cov0" title="0">{
        report := &amp;ComplianceReport{
                ID:          fmt.Sprintf("executive_report_%s_%d", request.BusinessID, time.Now().Unix()),
                BusinessID:  request.BusinessID,
                ReportType:  ReportTypeExecutive,
                Title:       "Executive Compliance Summary",
                Description: "High-level compliance summary for executive review",
                GeneratedAt: time.Now(),
                Period:      "current",
        }

        // Get compliance check results
        checkReq := CheckRequest{
                BusinessID: request.BusinessID,
                Frameworks: frameworks,
                Options:    EvaluationOptions{},
        }

        checkResp, err := s.checkEngine.Check(ctx, checkReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to run compliance check: %w", err)
        }</span>

        // Calculate overall status and score
        <span class="cov0" title="0">report.OverallStatus, report.ComplianceScore = s.calculateOverallStatus(checkResp)

        // Build high-level requirements summary
        report.Requirements = s.buildExecutiveRequirements(ctx, checkResp)

        // Get high-level recommendations
        if s.recommendations != nil </span><span class="cov0" title="0">{
                recommendations, err := s.recommendations.GenerateRecommendations(ctx, request.BusinessID, frameworks)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to generate recommendations", "error", err.Error())
                }</span> else<span class="cov0" title="0"> {
                        // Filter to high-priority recommendations only
                        report.Recommendations = s.filterHighPriorityRecommendations(recommendations)
                }</span>
        }

        <span class="cov0" title="0">return report, nil</span>
}

// Helper methods

func (s *ReportGenerationService) getFrameworksToInclude(ctx context.Context, businessID, specificFramework string) ([]string, error) <span class="cov8" title="1">{
        if specificFramework != "" </span><span class="cov8" title="1">{
                return []string{specificFramework}, nil
        }</span>

        // Check if tracking system is available
        <span class="cov8" title="1">if s.tracking == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("tracking system not initialized")
        }</span>

        // Get all frameworks for the business
        <span class="cov0" title="0">summary, err := s.tracking.GetBusinessComplianceSummary(ctx, businessID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get business compliance summary: %w", err)
        }</span>

        <span class="cov0" title="0">frameworks := make([]string, 0, len(summary))
        for framework := range summary </span><span class="cov0" title="0">{
                frameworks = append(frameworks, framework)
        }</span>

        <span class="cov0" title="0">return frameworks, nil</span>
}

func (s *ReportGenerationService) calculateOverallStatus(checkResp *CheckResponse) (ComplianceStatus, float64) <span class="cov8" title="1">{
        if len(checkResp.Results) == 0 </span><span class="cov8" title="1">{
                return ComplianceStatusNotStarted, 0.0
        }</span>

        <span class="cov8" title="1">totalPassed := checkResp.Passed
        totalFailed := checkResp.Failed
        total := totalPassed + totalFailed

        if total == 0 </span><span class="cov0" title="0">{
                return ComplianceStatusNotStarted, 0.0
        }</span>

        <span class="cov8" title="1">score := float64(totalPassed) / float64(total) * 100.0

        // Determine status based on score
        if score &gt;= 90.0 </span><span class="cov0" title="0">{
                return ComplianceStatusVerified, score
        }</span> else<span class="cov8" title="1"> if score &gt;= 70.0 </span><span class="cov8" title="1">{
                return ComplianceStatusImplemented, score
        }</span> else<span class="cov0" title="0"> if score &gt;= 30.0 </span><span class="cov0" title="0">{
                return ComplianceStatusInProgress, score
        }</span> else<span class="cov0" title="0"> {
                return ComplianceStatusNotStarted, score
        }</span>
}

func (s *ReportGenerationService) buildRequirementsAndControls(ctx context.Context, checkResp *CheckResponse, includeDetails bool) ([]RequirementReport, []ControlReport) <span class="cov8" title="1">{
        var requirements []RequirementReport
        var controls []ControlReport

        for _, result := range checkResp.Results </span><span class="cov8" title="1">{
                // Convert framework check result to requirement reports
                reqReports := s.convertCheckResultToRequirements(ctx, result, includeDetails)
                requirements = append(requirements, reqReports...)

                // Extract controls from requirements
                for _, req := range reqReports </span><span class="cov8" title="1">{
                        controls = append(controls, req.Controls...)
                }</span>
        }

        <span class="cov8" title="1">return requirements, controls</span>
}

func (s *ReportGenerationService) convertCheckResultToRequirements(ctx context.Context, result FrameworkCheckResult, includeDetails bool) []RequirementReport <span class="cov8" title="1">{
        // This is a simplified conversion - in a real implementation,
        // you would map the check results to actual requirement data
        var requirements []RequirementReport

        // Create a summary requirement for the framework
        requirement := RequirementReport{
                RequirementID:        result.FrameworkID,
                Title:                fmt.Sprintf("%s Framework Compliance", result.FrameworkID),
                Status:               ComplianceStatusImplemented, // Default status since ComplianceCheckResult doesn't have OverallStatus
                ImplementationStatus: ImplementationStatusImplemented,
                ComplianceScore:      float64(result.Summary.Passed) / float64(result.Summary.Passed+result.Summary.Failed) * 100.0,
                RiskLevel:            ComplianceRiskLevelMedium,
                Priority:             CompliancePriorityHigh,
                LastReviewed:         time.Now(),
                NextReview:           time.Now().Add(30 * 24 * time.Hour),
        }

        if includeDetails </span><span class="cov8" title="1">{
                // Add detailed control information
                requirement.Controls = s.buildDetailedControls(ctx, result)
        }</span>

        <span class="cov8" title="1">requirements = append(requirements, requirement)
        return requirements</span>
}

func (s *ReportGenerationService) buildDetailedControls(ctx context.Context, result FrameworkCheckResult) []ControlReport <span class="cov8" title="1">{
        // This would be populated with actual control data from the check results
        var controls []ControlReport

        // Create a summary control
        control := ControlReport{
                ControlID:            fmt.Sprintf("%s_summary", result.FrameworkID),
                Title:                fmt.Sprintf("%s Framework Summary Control", result.FrameworkID),
                Status:               ComplianceStatusImplemented, // Default status since ComplianceCheckResult doesn't have OverallStatus
                ImplementationStatus: ImplementationStatusImplemented,
                Effectiveness:        ControlEffectivenessEffective,
                LastTested:           &amp;time.Time{},
                NextTestDate:         &amp;time.Time{},
        }

        controls = append(controls, control)
        return controls
}</span>

func (s *ReportGenerationService) convertGapAnalysisToReport(ctx context.Context, gapReport *GapAnalysisReport) ([]RequirementReport, []ControlReport) <span class="cov8" title="1">{
        var requirements []RequirementReport
        var controls []ControlReport

        // Convert requirement gaps to requirement reports
        for _, gap := range gapReport.RequirementGaps </span><span class="cov8" title="1">{
                requirement := RequirementReport{
                        RequirementID:        gap.RequirementID,
                        Title:                gap.Title,
                        Status:               ComplianceStatusNonCompliant,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        ComplianceScore:      0.0,
                        RiskLevel:            ComplianceRiskLevelMedium, // Default since RequirementGap doesn't have RiskLevel
                        Priority:             CompliancePriorityMedium,  // Default since RequirementGap doesn't have Priority
                        LastReviewed:         time.Now(),
                        NextReview:           time.Now().Add(7 * 24 * time.Hour),
                }
                requirements = append(requirements, requirement)
        }</span>

        // Convert control gaps to control reports
        <span class="cov8" title="1">for _, gap := range gapReport.ControlGaps </span><span class="cov8" title="1">{
                control := ControlReport{
                        ControlID:            gap.ControlID,
                        Title:                gap.Title,
                        Status:               ComplianceStatusNonCompliant,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        Effectiveness:        ControlEffectivenessIneffective,
                        LastTested:           &amp;time.Time{},
                        NextTestDate:         &amp;time.Time{},
                }
                controls = append(controls, control)
        }</span>

        <span class="cov8" title="1">return requirements, controls</span>
}

func (s *ReportGenerationService) calculateStatusFromGaps(requirements []RequirementReport, controls []ControlReport) (ComplianceStatus, float64) <span class="cov8" title="1">{
        if len(requirements) == 0 &amp;&amp; len(controls) == 0 </span><span class="cov8" title="1">{
                return ComplianceStatusVerified, 100.0
        }</span>

        <span class="cov8" title="1">totalGaps := len(requirements) + len(controls)
        if totalGaps == 0 </span><span class="cov0" title="0">{
                return ComplianceStatusVerified, 100.0
        }</span>

        // Calculate score based on gap severity
        <span class="cov8" title="1">score := 100.0 - float64(totalGaps)*10.0 // Simple scoring - each gap reduces score by 10%
        if score &lt; 0 </span><span class="cov0" title="0">{
                score = 0.0
        }</span>

        <span class="cov8" title="1">if score &gt;= 90.0 </span><span class="cov0" title="0">{
                return ComplianceStatusVerified, score
        }</span> else<span class="cov8" title="1"> if score &gt;= 70.0 </span><span class="cov8" title="1">{
                return ComplianceStatusImplemented, score
        }</span> else<span class="cov0" title="0"> if score &gt;= 30.0 </span><span class="cov0" title="0">{
                return ComplianceStatusInProgress, score
        }</span> else<span class="cov0" title="0"> {
                return ComplianceStatusNotStarted, score
        }</span>
}

func (s *ReportGenerationService) extractRemediationData(ctx context.Context, tracking *ComplianceTracking) ([]RequirementReport, []RemediationReport, []ExceptionReport) <span class="cov0" title="0">{
        var requirements []RequirementReport
        var remediationPlans []RemediationReport
        var exceptions []ExceptionReport

        for _, req := range tracking.Requirements </span><span class="cov0" title="0">{
                requirement := RequirementReport{
                        RequirementID:        req.RequirementID,
                        Status:               req.Status,
                        ImplementationStatus: req.ImplementationStatus,
                        ComplianceScore:      req.ComplianceScore,
                        LastReviewed:         req.LastReviewed,
                        NextReview:           req.NextReview,
                }

                // Add remediation plan if exists
                if req.RemediationPlan != nil </span><span class="cov0" title="0">{
                        remediationPlan := RemediationReport{
                                PlanID:     req.RemediationPlan.ID,
                                Title:      req.RemediationPlan.Title,
                                Status:     req.RemediationPlan.Status,
                                Priority:   req.RemediationPlan.Priority,
                                TargetDate: req.RemediationPlan.TargetDate,
                                Progress:   req.RemediationPlan.Progress,
                                AssignedTo: req.RemediationPlan.AssignedTo,
                        }
                        remediationPlans = append(remediationPlans, remediationPlan)
                }</span>

                // Add exceptions
                <span class="cov0" title="0">for _, exception := range req.Exceptions </span><span class="cov0" title="0">{
                        exceptionReport := ExceptionReport{
                                ExceptionID:   exception.ID,
                                RequirementID: exception.RequirementID,
                                Type:          exception.Type,
                                Reason:        exception.Reason,
                                Status:        exception.Status,
                                ApprovedBy:    exception.ApprovedBy,
                                ApprovedAt:    exception.ApprovedAt,
                                ExpiresAt:     exception.ExpiresAt,
                        }
                        exceptions = append(exceptions, exceptionReport)
                }</span>

                <span class="cov0" title="0">requirements = append(requirements, requirement)</span>
        }

        <span class="cov0" title="0">return requirements, remediationPlans, exceptions</span>
}

func (s *ReportGenerationService) calculateStatusFromRemediation(requirements []RequirementReport, remediationPlans []RemediationReport) (ComplianceStatus, float64) <span class="cov8" title="1">{
        if len(requirements) == 0 </span><span class="cov8" title="1">{
                return ComplianceStatusVerified, 100.0
        }</span>

        <span class="cov8" title="1">totalRequirements := len(requirements)
        compliantRequirements := 0
        activeRemediationPlans := 0

        for _, req := range requirements </span><span class="cov8" title="1">{
                if req.Status == ComplianceStatusVerified || req.Status == ComplianceStatusImplemented </span><span class="cov8" title="1">{
                        compliantRequirements++
                }</span>
        }

        <span class="cov8" title="1">for _, plan := range remediationPlans </span><span class="cov0" title="0">{
                if plan.Status == RemediationStatusInProgress || plan.Status == RemediationStatusNotStarted </span><span class="cov0" title="0">{
                        activeRemediationPlans++
                }</span>
        }

        <span class="cov8" title="1">score := float64(compliantRequirements) / float64(totalRequirements) * 100.0

        if score &gt;= 90.0 </span><span class="cov0" title="0">{
                return ComplianceStatusVerified, score
        }</span> else<span class="cov8" title="1"> if score &gt;= 70.0 </span><span class="cov0" title="0">{
                return ComplianceStatusImplemented, score
        }</span> else<span class="cov8" title="1"> if score &gt;= 30.0 </span><span class="cov8" title="1">{
                return ComplianceStatusInProgress, score
        }</span> else<span class="cov0" title="0"> {
                return ComplianceStatusNotStarted, score
        }</span>
}

func (s *ReportGenerationService) extractAuditData(ctx context.Context, tracking *ComplianceTracking) ([]RequirementReport, []ControlReport) <span class="cov0" title="0">{
        var requirements []RequirementReport
        var controls []ControlReport

        for _, req := range tracking.Requirements </span><span class="cov0" title="0">{
                requirement := RequirementReport{
                        RequirementID:        req.RequirementID,
                        Status:               req.Status,
                        ImplementationStatus: req.ImplementationStatus,
                        ComplianceScore:      req.ComplianceScore,
                        LastReviewed:         req.LastReviewed,
                        NextReview:           req.NextReview,
                }

                // Add controls with audit information
                for _, ctrl := range req.Controls </span><span class="cov0" title="0">{
                        control := ControlReport{
                                ControlID:            ctrl.ControlID,
                                Status:               ctrl.Status,
                                ImplementationStatus: ctrl.ImplementationStatus,
                                Effectiveness:        ctrl.Effectiveness,
                                LastTested:           ctrl.LastTested,
                                NextTestDate:         ctrl.NextTestDate,
                                TestResults:          ctrl.TestResults,
                                Evidence:             ctrl.Evidence,
                        }
                        controls = append(controls, control)
                }</span>

                <span class="cov0" title="0">requirements = append(requirements, requirement)</span>
        }

        <span class="cov0" title="0">return requirements, controls</span>
}

func (s *ReportGenerationService) calculateStatusFromAudit(requirements []RequirementReport, controls []ControlReport) (ComplianceStatus, float64) <span class="cov8" title="1">{
        if len(requirements) == 0 </span><span class="cov8" title="1">{
                return ComplianceStatusVerified, 100.0
        }</span>

        <span class="cov8" title="1">totalRequirements := len(requirements)
        compliantRequirements := 0

        for _, req := range requirements </span><span class="cov8" title="1">{
                if req.Status == ComplianceStatusVerified || req.Status == ComplianceStatusImplemented </span><span class="cov8" title="1">{
                        compliantRequirements++
                }</span>
        }

        <span class="cov8" title="1">score := float64(compliantRequirements) / float64(totalRequirements) * 100.0

        if score &gt;= 90.0 </span><span class="cov0" title="0">{
                return ComplianceStatusVerified, score
        }</span> else<span class="cov8" title="1"> if score &gt;= 70.0 </span><span class="cov0" title="0">{
                return ComplianceStatusImplemented, score
        }</span> else<span class="cov8" title="1"> if score &gt;= 30.0 </span><span class="cov8" title="1">{
                return ComplianceStatusInProgress, score
        }</span> else<span class="cov0" title="0"> {
                return ComplianceStatusNotStarted, score
        }</span>
}

func (s *ReportGenerationService) buildExecutiveRequirements(ctx context.Context, checkResp *CheckResponse) []RequirementReport <span class="cov0" title="0">{
        var requirements []RequirementReport

        // Create high-level summary requirements for each framework
        for _, result := range checkResp.Results </span><span class="cov0" title="0">{
                requirement := RequirementReport{
                        RequirementID:        result.FrameworkID,
                        Title:                fmt.Sprintf("%s Framework", result.FrameworkID),
                        Status:               ComplianceStatusImplemented, // Default status since ComplianceCheckResult doesn't have OverallStatus
                        ImplementationStatus: ImplementationStatusImplemented,
                        ComplianceScore:      float64(result.Summary.Passed) / float64(result.Summary.Passed+result.Summary.Failed) * 100.0,
                        RiskLevel:            ComplianceRiskLevelMedium,
                        Priority:             CompliancePriorityHigh,
                        LastReviewed:         time.Now(),
                        NextReview:           time.Now().Add(30 * 24 * time.Hour),
                }
                requirements = append(requirements, requirement)
        }</span>

        <span class="cov0" title="0">return requirements</span>
}

func (s *ReportGenerationService) filterHighPriorityRecommendations(recommendations []ComplianceRecommendation) []ComplianceRecommendation <span class="cov8" title="1">{
        var highPriority []ComplianceRecommendation

        for _, rec := range recommendations </span><span class="cov8" title="1">{
                if rec.Priority == CompliancePriorityCritical || rec.Priority == CompliancePriorityHigh </span><span class="cov8" title="1">{
                        highPriority = append(highPriority, rec)
                }</span>
        }

        <span class="cov8" title="1">return highPriority</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package compliance

import (
        "context"
        "fmt"
        "regexp"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// EntityType enumerates rule targets
// Allowed: "overall", "framework", "requirement", "control"
type EntityType string

const (
        EntityTypeOverall     EntityType = "overall"
        EntityTypeFramework   EntityType = "framework"
        EntityTypeRequirement EntityType = "requirement"
        EntityTypeControl     EntityType = "control"
)

// Operator represents predicate operators for conditions
type Operator string

const (
        OpEq         Operator = "eq"
        OpNe         Operator = "ne"
        OpGt         Operator = "gt"
        OpGte        Operator = "gte"
        OpLt         Operator = "lt"
        OpLte        Operator = "lte"
        OpContains   Operator = "contains"
        OpIn         Operator = "in"
        OpExists     Operator = "exists"
        OpNotExists  Operator = "not_exists"
        OpRegexMatch Operator = "regex"
)

// Predicate describes a single boolean check
type Predicate struct {
        Attribute string      `json:"attribute"`
        Operator  Operator    `json:"operator"`
        Value     interface{} `json:"value,omitempty"`
}

// Condition represents a boolean expression tree
// Only one of All/Any/Not/Predicate is set
// - All: AND over children
// - Any: OR over children
// - Not: negation of the nested condition
// - Predicate: leaf predicate
// An empty condition evaluates to true
// This flexible structure avoids deep nesting complexity in callers
// and keeps evaluation concise.
type Condition struct {
        All       []Condition `json:"all,omitempty"`
        Any       []Condition `json:"any,omitempty"`
        Not       *Condition  `json:"not,omitempty"`
        Predicate *Predicate  `json:"predicate,omitempty"`
}

// RuleEffect defines optional side effects if a rule fails
// Effects are only applied when ApplyEffects is true in evaluation options.
type RuleEffect struct {
        SetStatus       *ComplianceStatus         `json:"set_status,omitempty"`
        ScoreAdjustment *float64                  `json:"score_adjustment,omitempty"` // positive or negative delta 0..100
        RequireEvidence bool                      `json:"require_evidence,omitempty"`
        Recommendation  *ComplianceRecommendation `json:"recommendation,omitempty"`
}

// Rule defines a compliance rule
// A rule passes if its condition evaluates to true for a given entity.
// If a rule fails, its effect MAY be applied (optional).
type Rule struct {
        ID          string     `json:"id"`
        Name        string     `json:"name"`
        Description string     `json:"description"`
        EntityType  EntityType `json:"entity_type"`
        TargetIDs   []string   `json:"target_ids,omitempty"` // optional filter to specific requirement/control IDs
        Condition   Condition  `json:"condition"`
        Severity    string     `json:"severity"` // "low","medium","high","critical"
        Effect      RuleEffect `json:"effect"`
        Enabled     bool       `json:"enabled"`
}

// RuleSet groups rules for a framework
// Example: SOC2 Common Controls v1
// Rule order is preserved for deterministic evaluation
// and results are sorted by severity then name in reports.
type RuleSet struct {
        ID        string    `json:"id"`
        Name      string    `json:"name"`
        Framework string    `json:"framework"`
        Version   string    `json:"version"`
        Rules     []Rule    `json:"rules"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// RuleOutcome captures the evaluation of a single rule against a single entity
type RuleOutcome struct {
        RuleID     string     `json:"rule_id"`
        RuleName   string     `json:"rule_name"`
        EntityType EntityType `json:"entity_type"`
        EntityID   string     `json:"entity_id"`
        Passed     bool       `json:"passed"`
        Severity   string     `json:"severity"`
        Details    string     `json:"details"`
}

// ComplianceCheckResult aggregates outcomes for a framework evaluation
type ComplianceCheckResult struct {
        BusinessID string        `json:"business_id"`
        Framework  string        `json:"framework"`
        Evaluated  time.Time     `json:"evaluated"`
        Passed     int           `json:"passed"`
        Failed     int           `json:"failed"`
        Outcomes   []RuleOutcome `json:"outcomes"`
}

// EvaluationOptions controls evaluation behavior
type EvaluationOptions struct {
        ApplyEffects bool `json:"apply_effects"`
}

// RuleEngine evaluates rule sets for compliance checks
// Thread-safe registration and evaluation.
type RuleEngine struct {
        logger   *observability.Logger
        mu       sync.RWMutex
        ruleSets map[string][]*RuleSet // framework -&gt; rule sets
}

// NewRuleEngine constructs a RuleEngine
func NewRuleEngine(logger *observability.Logger) *RuleEngine <span class="cov0" title="0">{
        return &amp;RuleEngine{
                logger:   logger,
                ruleSets: make(map[string][]*RuleSet),
        }
}</span>

// RegisterRuleSet registers or replaces a rule set for a framework
func (e *RuleEngine) RegisterRuleSet(ctx context.Context, set *RuleSet) error <span class="cov0" title="0">{
        if set == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("nil rule set")
        }</span>
        <span class="cov0" title="0">if set.Framework == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("rule set framework is required")
        }</span>
        <span class="cov0" title="0">if set.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("rule set ID is required")
        }</span>

        <span class="cov0" title="0">e.mu.Lock()
        defer e.mu.Unlock()

        // replace by ID if exists; else append
        list := e.ruleSets[set.Framework]
        replaced := false
        for i := range list </span><span class="cov0" title="0">{
                if list[i].ID == set.ID </span><span class="cov0" title="0">{
                        set.UpdatedAt = time.Now()
                        list[i] = set
                        replaced = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !replaced </span><span class="cov0" title="0">{
                set.CreatedAt = time.Now()
                set.UpdatedAt = set.CreatedAt
                list = append(list, set)
        }</span>
        <span class="cov0" title="0">e.ruleSets[set.Framework] = list

        return nil</span>
}

// GetRuleSets returns rule sets for a framework (copy)
func (e *RuleEngine) GetRuleSets(framework string) []*RuleSet <span class="cov0" title="0">{
        e.mu.RLock()
        defer e.mu.RUnlock()
        list := e.ruleSets[framework]
        out := make([]*RuleSet, len(list))
        copy(out, list)
        return out
}</span>

// EvaluateFramework evaluates all registered rules for a framework against tracking data
func (e *RuleEngine) EvaluateFramework(
        ctx context.Context,
        tracking *ComplianceTracking,
        frameworkDef *RegulatoryFramework,
        options EvaluationOptions,
) (*ComplianceCheckResult, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        if tracking == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tracking is required")
        }</span>

        <span class="cov0" title="0">e.mu.RLock()
        sets := e.ruleSets[tracking.Framework]
        e.mu.RUnlock()

        result := &amp;ComplianceCheckResult{
                BusinessID: tracking.BusinessID,
                Framework:  tracking.Framework,
                Evaluated:  time.Now(),
                Outcomes:   make([]RuleOutcome, 0),
        }

        // Build quick lookup maps for current tracking snapshot
        reqMap := make(map[string]*RequirementTracking, len(tracking.Requirements))
        for i := range tracking.Requirements </span><span class="cov0" title="0">{
                req := &amp;tracking.Requirements[i]
                reqMap[req.RequirementID] = req
        }</span>

        <span class="cov0" title="0">controlMap := make(map[string]*ControlTracking)
        for i := range tracking.Requirements </span><span class="cov0" title="0">{
                for j := range tracking.Requirements[i].Controls </span><span class="cov0" title="0">{
                        ctrl := &amp;tracking.Requirements[i].Controls[j]
                        controlMap[ctrl.ControlID] = ctrl
                }</span>
        }

        // Iterate rule sets and rules
        <span class="cov0" title="0">for _, set := range sets </span><span class="cov0" title="0">{
                for _, rule := range set.Rules </span><span class="cov0" title="0">{
                        if !rule.Enabled </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">switch rule.EntityType </span>{
                        case EntityTypeRequirement:<span class="cov0" title="0">
                                // Targets: all requirements or filtered
                                candidateIDs := filterTargetRequirementIDs(rule.TargetIDs, reqMap)
                                for _, rid := range candidateIDs </span><span class="cov0" title="0">{
                                        req := reqMap[rid]
                                        passed := e.evaluateConditionRequirement(&amp;rule.Condition, req)
                                        details := e.buildDetails(passed)
                                        out := RuleOutcome{RuleID: rule.ID, RuleName: rule.Name, EntityType: rule.EntityType, EntityID: rid, Passed: passed, Severity: rule.Severity, Details: details}
                                        result.Outcomes = append(result.Outcomes, out)

                                        if !passed &amp;&amp; options.ApplyEffects </span><span class="cov0" title="0">{
                                                e.applyRequirementEffect(rule.Effect, req)
                                        }</span>
                                }

                        case EntityTypeControl:<span class="cov0" title="0">
                                candidateIDs := filterTargetControlIDs(rule.TargetIDs, controlMap)
                                for _, cid := range candidateIDs </span><span class="cov0" title="0">{
                                        ctrl := controlMap[cid]
                                        passed := e.evaluateConditionControl(&amp;rule.Condition, ctrl)
                                        details := e.buildDetails(passed)
                                        out := RuleOutcome{RuleID: rule.ID, RuleName: rule.Name, EntityType: rule.EntityType, EntityID: cid, Passed: passed, Severity: rule.Severity, Details: details}
                                        result.Outcomes = append(result.Outcomes, out)

                                        if !passed &amp;&amp; options.ApplyEffects </span><span class="cov0" title="0">{
                                                e.applyControlEffect(rule.Effect, ctrl)
                                        }</span>
                                }

                        case EntityTypeFramework, EntityTypeOverall:<span class="cov0" title="0">
                                // Simple framework-level evaluation using tracking fields
                                passed := e.evaluateConditionFramework(&amp;rule.Condition, tracking)
                                details := e.buildDetails(passed)
                                entityID := tracking.Framework
                                out := RuleOutcome{RuleID: rule.ID, RuleName: rule.Name, EntityType: rule.EntityType, EntityID: entityID, Passed: passed, Severity: rule.Severity, Details: details}
                                result.Outcomes = append(result.Outcomes, out)</span>
                        }
                }
        }

        // Tally
        <span class="cov0" title="0">for _, o := range result.Outcomes </span><span class="cov0" title="0">{
                if o.Passed </span><span class="cov0" title="0">{
                        result.Passed++
                }</span> else<span class="cov0" title="0"> {
                        result.Failed++
                }</span>
        }

        // Sort outcomes by severity, then name for readability
        <span class="cov0" title="0">sort.SliceStable(result.Outcomes, func(i, j int) bool </span><span class="cov0" title="0">{
                if result.Outcomes[i].Severity == result.Outcomes[j].Severity </span><span class="cov0" title="0">{
                        return result.Outcomes[i].RuleName &lt; result.Outcomes[j].RuleName
                }</span>
                <span class="cov0" title="0">return severityRank(result.Outcomes[i].Severity) &gt; severityRank(result.Outcomes[j].Severity)</span>
        })

        <span class="cov0" title="0">e.logger.Info("Compliance rules evaluated",
                "request_id", requestID,
                "business_id", tracking.BusinessID,
                "framework", tracking.Framework,
                "rule_sets", len(sets),
                "passed", result.Passed,
                "failed", result.Failed,
        )

        return result, nil</span>
}

// Helpers

func (e *RuleEngine) buildDetails(passed bool) string <span class="cov0" title="0">{
        if passed </span><span class="cov0" title="0">{
                return "condition satisfied"
        }</span>
        <span class="cov0" title="0">return "condition failed"</span>
}

func severityRank(s string) int <span class="cov0" title="0">{
        s = strings.ToLower(s)
        switch s </span>{
        case "critical":<span class="cov0" title="0">
                return 4</span>
        case "high":<span class="cov0" title="0">
                return 3</span>
        case "medium":<span class="cov0" title="0">
                return 2</span>
        case "low":<span class="cov0" title="0">
                return 1</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

// Condition evaluation

func (e *RuleEngine) evaluateConditionRequirement(cond *Condition, req *RequirementTracking) bool <span class="cov0" title="0">{
        if cond == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        // All
        <span class="cov0" title="0">if len(cond.All) &gt; 0 </span><span class="cov0" title="0">{
                for i := range cond.All </span><span class="cov0" title="0">{
                        if !e.evaluateConditionRequirement(&amp;cond.All[i], req) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
        // Any
        <span class="cov0" title="0">if len(cond.Any) &gt; 0 </span><span class="cov0" title="0">{
                for i := range cond.Any </span><span class="cov0" title="0">{
                        if e.evaluateConditionRequirement(&amp;cond.Any[i], req) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }
        // Not
        <span class="cov0" title="0">if cond.Not != nil </span><span class="cov0" title="0">{
                return !e.evaluateConditionRequirement(cond.Not, req)
        }</span>
        // Predicate
        <span class="cov0" title="0">if cond.Predicate != nil </span><span class="cov0" title="0">{
                attr := strings.ToLower(cond.Predicate.Attribute)
                return evalPredicate(cond.Predicate.Operator, e.reqAttrValue(attr, req), cond.Predicate.Value)
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (e *RuleEngine) evaluateConditionControl(cond *Condition, ctrl *ControlTracking) bool <span class="cov0" title="0">{
        if cond == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if len(cond.All) &gt; 0 </span><span class="cov0" title="0">{
                for i := range cond.All </span><span class="cov0" title="0">{
                        if !e.evaluateConditionControl(&amp;cond.All[i], ctrl) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
        <span class="cov0" title="0">if len(cond.Any) &gt; 0 </span><span class="cov0" title="0">{
                for i := range cond.Any </span><span class="cov0" title="0">{
                        if e.evaluateConditionControl(&amp;cond.Any[i], ctrl) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov0" title="0">if cond.Not != nil </span><span class="cov0" title="0">{
                return !e.evaluateConditionControl(cond.Not, ctrl)
        }</span>
        <span class="cov0" title="0">if cond.Predicate != nil </span><span class="cov0" title="0">{
                attr := strings.ToLower(cond.Predicate.Attribute)
                return evalPredicate(cond.Predicate.Operator, e.ctrlAttrValue(attr, ctrl), cond.Predicate.Value)
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (e *RuleEngine) evaluateConditionFramework(cond *Condition, tracking *ComplianceTracking) bool <span class="cov0" title="0">{
        if cond == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if len(cond.All) &gt; 0 </span><span class="cov0" title="0">{
                for i := range cond.All </span><span class="cov0" title="0">{
                        if !e.evaluateConditionFramework(&amp;cond.All[i], tracking) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
        <span class="cov0" title="0">if len(cond.Any) &gt; 0 </span><span class="cov0" title="0">{
                for i := range cond.Any </span><span class="cov0" title="0">{
                        if e.evaluateConditionFramework(&amp;cond.Any[i], tracking) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov0" title="0">if cond.Not != nil </span><span class="cov0" title="0">{
                return !e.evaluateConditionFramework(cond.Not, tracking)
        }</span>
        <span class="cov0" title="0">if cond.Predicate != nil </span><span class="cov0" title="0">{
                attr := strings.ToLower(cond.Predicate.Attribute)
                return evalPredicate(cond.Predicate.Operator, e.frameworkAttrValue(attr, tracking), cond.Predicate.Value)
        }</span>
        <span class="cov0" title="0">return true</span>
}

// Attribute retrieval helpers

// filterTargetRequirementIDs returns requirement IDs filtered by targets (or all if empty)
func filterTargetRequirementIDs(targets []string, source map[string]*RequirementTracking) []string <span class="cov0" title="0">{
        if len(targets) == 0 </span><span class="cov0" title="0">{
                ids := make([]string, 0, len(source))
                for id := range source </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        }
        <span class="cov0" title="0">var ids []string
        for _, id := range targets </span><span class="cov0" title="0">{
                if _, ok := source[id]; ok </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
        }
        <span class="cov0" title="0">return ids</span>
}

// filterTargetControlIDs returns control IDs filtered by targets (or all if empty)
func filterTargetControlIDs(targets []string, source map[string]*ControlTracking) []string <span class="cov0" title="0">{
        if len(targets) == 0 </span><span class="cov0" title="0">{
                ids := make([]string, 0, len(source))
                for id := range source </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        }
        <span class="cov0" title="0">var ids []string
        for _, id := range targets </span><span class="cov0" title="0">{
                if _, ok := source[id]; ok </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
        }
        <span class="cov0" title="0">return ids</span>
}

func (e *RuleEngine) reqAttrValue(attr string, req *RequirementTracking) interface{} <span class="cov0" title="0">{
        switch attr </span>{
        case "status":<span class="cov0" title="0">
                return string(req.Status)</span>
        case "implementation_status":<span class="cov0" title="0">
                return string(req.ImplementationStatus)</span>
        case "score", "compliance_score":<span class="cov0" title="0">
                return req.ComplianceScore</span>
        case "evidence_count":<span class="cov0" title="0">
                return len(req.Evidence)</span>
        case "exception_count":<span class="cov0" title="0">
                return len(req.Exceptions)</span>
        case "control_count":<span class="cov0" title="0">
                return len(req.Controls)</span>
        case "last_reviewed_ts":<span class="cov0" title="0">
                return req.LastReviewed.Unix()</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func (e *RuleEngine) ctrlAttrValue(attr string, ctrl *ControlTracking) interface{} <span class="cov0" title="0">{
        switch attr </span>{
        case "status":<span class="cov0" title="0">
                return string(ctrl.Status)</span>
        case "implementation_status":<span class="cov0" title="0">
                return string(ctrl.ImplementationStatus)</span>
        case "effectiveness":<span class="cov0" title="0">
                return string(ctrl.Effectiveness)</span>
        case "test_count":<span class="cov0" title="0">
                return len(ctrl.TestResults)</span>
        case "evidence_count":<span class="cov0" title="0">
                return len(ctrl.Evidence)</span>
        case "pass_rate":<span class="cov0" title="0">
                return e.computeControlPassRate(ctrl)</span>
        case "last_tested_ts":<span class="cov0" title="0">
                if ctrl.LastTested != nil </span><span class="cov0" title="0">{
                        return ctrl.LastTested.Unix()
                }</span>
                <span class="cov0" title="0">return int64(0)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func (e *RuleEngine) frameworkAttrValue(attr string, tracking *ComplianceTracking) interface{} <span class="cov0" title="0">{
        switch attr </span>{
        case "overall_status":<span class="cov0" title="0">
                return string(tracking.OverallStatus)</span>
        case "compliance_score":<span class="cov0" title="0">
                return tracking.ComplianceScore</span>
        case "requirement_count":<span class="cov0" title="0">
                return len(tracking.Requirements)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func (e *RuleEngine) computeControlPassRate(ctrl *ControlTracking) float64 <span class="cov0" title="0">{
        if len(ctrl.TestResults) == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov0" title="0">passes := 0
        for i := range ctrl.TestResults </span><span class="cov0" title="0">{
                if ctrl.TestResults[i].Result == TestResultPass </span><span class="cov0" title="0">{
                        passes++
                }</span>
        }
        <span class="cov0" title="0">return float64(passes) / float64(len(ctrl.TestResults)) * 100.0</span>
}

// Effects application (only if ApplyEffects)

func (e *RuleEngine) applyRequirementEffect(effect RuleEffect, req *RequirementTracking) <span class="cov0" title="0">{
        if effect.ScoreAdjustment != nil </span><span class="cov0" title="0">{
                req.ComplianceScore = clamp01(req.ComplianceScore + *effect.ScoreAdjustment)
        }</span>
        <span class="cov0" title="0">if effect.SetStatus != nil </span><span class="cov0" title="0">{
                req.Status = *effect.SetStatus
        }</span>
        // RequireEvidence is a policy flag; concrete enforcement would occur elsewhere
}

func (e *RuleEngine) applyControlEffect(effect RuleEffect, ctrl *ControlTracking) <span class="cov0" title="0">{
        if effect.SetStatus != nil </span><span class="cov0" title="0">{
                ctrl.Status = *effect.SetStatus
        }</span>
}

func clamp01(v float64) float64 <span class="cov0" title="0">{
        if v &lt; 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if v &gt; 100 </span><span class="cov0" title="0">{
                return 100
        }</span>
        <span class="cov0" title="0">return v</span>
}

// Predicate evaluation core

func evalPredicate(op Operator, left interface{}, right interface{}) bool <span class="cov0" title="0">{
        switch op </span>{
        case OpExists:<span class="cov0" title="0">
                return left != nil</span>
        case OpNotExists:<span class="cov0" title="0">
                return left == nil</span>
        case OpEq:<span class="cov0" title="0">
                return compareEq(left, right)</span>
        case OpNe:<span class="cov0" title="0">
                return !compareEq(left, right)</span>
        case OpGt:<span class="cov0" title="0">
                return compareOrd(left, right) &gt; 0</span>
        case OpGte:<span class="cov0" title="0">
                return compareOrd(left, right) &gt;= 0</span>
        case OpLt:<span class="cov0" title="0">
                return compareOrd(left, right) &lt; 0</span>
        case OpLte:<span class="cov0" title="0">
                return compareOrd(left, right) &lt;= 0</span>
        case OpContains:<span class="cov0" title="0">
                return contains(left, right)</span>
        case OpIn:<span class="cov0" title="0">
                return inSet(left, right)</span>
        case OpRegexMatch:<span class="cov0" title="0">
                return regexMatch(left, right)</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func compareEq(a, b interface{}) bool <span class="cov0" title="0">{
        switch av := a.(type) </span>{
        case string:<span class="cov0" title="0">
                bv := toString(b)
                return strings.EqualFold(av, bv)</span>
        case float64:<span class="cov0" title="0">
                bf := toFloat(b)
                return av == bf</span>
        case int:<span class="cov0" title="0">
                bf := toFloat(b)
                return float64(av) == bf</span>
        case int64:<span class="cov0" title="0">
                bf := toFloat(b)
                return float64(av) == bf</span>
        case nil:<span class="cov0" title="0">
                return b == nil</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", a) == fmt.Sprintf("%v", b)</span>
        }
}

// compareOrd returns 1 if a&gt;b, 0 if a==b, -1 if a&lt;b for numeric/string
func compareOrd(a, b interface{}) int <span class="cov0" title="0">{
        // numeric first
        af := toFloat(a)
        bf := toFloat(b)
        if !isNaN(af) &amp;&amp; !isNaN(bf) </span><span class="cov0" title="0">{
                if af &gt; bf </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">if af &lt; bf </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">return 0</span>
        }
        // string fallback
        <span class="cov0" title="0">sa := strings.ToLower(toString(a))
        sb := strings.ToLower(toString(b))
        if sa &gt; sb </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">if sa &lt; sb </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func contains(a, b interface{}) bool <span class="cov0" title="0">{
        sa := strings.ToLower(toString(a))
        sb := strings.ToLower(toString(b))
        return strings.Contains(sa, sb)
}</span>

func inSet(a, b interface{}) bool <span class="cov0" title="0">{
        sa := strings.ToLower(toString(a))
        switch bv := b.(type) </span>{
        case []string:<span class="cov0" title="0">
                for _, s := range bv </span><span class="cov0" title="0">{
                        if strings.ToLower(s) == sa </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        case []interface{}:<span class="cov0" title="0">
                for _, s := range bv </span><span class="cov0" title="0">{
                        if strings.ToLower(toString(s)) == sa </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func regexMatch(a, b interface{}) bool <span class="cov0" title="0">{
        pattern := toString(b)
        if pattern == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">re, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return re.MatchString(toString(a))</span>
}

func toString(v interface{}) string <span class="cov0" title="0">{
        switch t := v.(type) </span>{
        case string:<span class="cov0" title="0">
                return t</span>
        case fmt.Stringer:<span class="cov0" title="0">
                return t.String()</span>
        case float64:<span class="cov0" title="0">
                return fmt.Sprintf("%g", t)</span>
        case int:<span class="cov0" title="0">
                return fmt.Sprintf("%d", t)</span>
        case int64:<span class="cov0" title="0">
                return fmt.Sprintf("%d", t)</span>
        case nil:<span class="cov0" title="0">
                return ""</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", t)</span>
        }
}

func toFloat(v interface{}) float64 <span class="cov0" title="0">{
        switch t := v.(type) </span>{
        case float64:<span class="cov0" title="0">
                return t</span>
        case int:<span class="cov0" title="0">
                return float64(t)</span>
        case int64:<span class="cov0" title="0">
                return float64(t)</span>
        case string:<span class="cov0" title="0">
                // best-effort parse
                var f float64
                _, _ = fmt.Sscan(t, &amp;f)
                return f</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

func isNaN(f float64) bool <span class="cov0" title="0">{ return f != f }</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package compliance

import (
        "context"
        "math"
        "sort"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// ScoreWeights defines configurable weights for scoring
type ScoreWeights struct {
        // Requirement-level weights
        StatusWeight         float64 // weight for requirement status
        ImplementationWeight float64 // weight for implementation status
        ControlsWeight       float64 // weight for control effectiveness aggregation
        EvidenceWeight       float64 // weight for evidence presence
        RecencyWeight        float64 // weight for freshness of review/tests
        ExceptionPenalty     float64 // penalty per active exception

        // Framework aggregation
        HighPriorityWeight     float64 // multiplier for high priority requirements
        CriticalPriorityWeight float64 // multiplier for critical priority requirements

        // Global clamps
        MinScore float64
        MaxScore float64
}

// DefaultScoreWeights returns sane defaults
func DefaultScoreWeights() ScoreWeights <span class="cov0" title="0">{
        return ScoreWeights{
                StatusWeight:           0.25,
                ImplementationWeight:   0.20,
                ControlsWeight:         0.45,
                EvidenceWeight:         0.05,
                RecencyWeight:          0.05,
                ExceptionPenalty:       5.0,
                HighPriorityWeight:     1.25,
                CriticalPriorityWeight: 1.5,
                MinScore:               0.0,
                MaxScore:               100.0,
        }
}</span>

// ScoringEngine calculates compliance scores
type ScoringEngine struct {
        logger  *observability.Logger
        weights ScoreWeights
}

func NewScoringEngine(logger *observability.Logger, weights ScoreWeights) *ScoringEngine <span class="cov0" title="0">{
        return &amp;ScoringEngine{logger: logger, weights: weights}
}</span>

// RequirementScore computes a score (0-100) for a requirement
func (e *ScoringEngine) RequirementScore(req *RequirementTracking) float64 <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">statusScore := e.scoreByRequirementStatus(req.Status)
        implScore := e.scoreByImplementationStatus(req.ImplementationStatus)
        controlsScore := e.controlsAggregateScore(req.Controls)
        evidenceScore := e.evidenceScore(len(req.Evidence))
        recencyScore := e.recencyScore(req.LastReviewed, 30*24*time.Hour) // monthly target

        weighted := statusScore*e.weights.StatusWeight +
                implScore*e.weights.ImplementationWeight +
                controlsScore*e.weights.ControlsWeight +
                evidenceScore*e.weights.EvidenceWeight +
                recencyScore*e.weights.RecencyWeight

        // Exception penalties
        penalty := float64(len(req.Exceptions)) * e.weights.ExceptionPenalty
        score := clamp(weighted-penalty, e.weights.MinScore, e.weights.MaxScore)
        return score</span>
}

// FrameworkScore computes average weighted score across requirements
func (e *ScoringEngine) FrameworkScore(tracking *ComplianceTracking, requirements map[string]*ComplianceRequirement) float64 <span class="cov0" title="0">{
        if tracking == nil || len(tracking.Requirements) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">total := 0.0
        weightSum := 0.0
        for i := range tracking.Requirements </span><span class="cov0" title="0">{
                reqTrack := &amp;tracking.Requirements[i]
                reqScore := e.RequirementScore(reqTrack)
                w := 1.0
                // apply priority multiplier when available
                if requirements != nil </span><span class="cov0" title="0">{
                        if reqDef, ok := requirements[reqTrack.RequirementID]; ok </span><span class="cov0" title="0">{
                                switch reqDef.Priority </span>{
                                case CompliancePriorityHigh:<span class="cov0" title="0">
                                        w = e.weights.HighPriorityWeight</span>
                                case CompliancePriorityCritical:<span class="cov0" title="0">
                                        w = e.weights.CriticalPriorityWeight</span>
                                }
                        }
                }
                <span class="cov0" title="0">total += reqScore * w
                weightSum += w</span>
        }
        <span class="cov0" title="0">if weightSum == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return clamp(total/weightSum, e.weights.MinScore, e.weights.MaxScore)</span>
}

// BusinessScore aggregates across frameworks present in summary
func (e *ScoringEngine) BusinessScore(ctx context.Context, trackingSummary map[string]*ComplianceTracking, frameworkDefs *FrameworkMappingSystem) float64 <span class="cov0" title="0">{
        if len(trackingSummary) == 0 || frameworkDefs == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        // stabilize ordering
        <span class="cov0" title="0">keys := make([]string, 0, len(trackingSummary))
        for k := range trackingSummary </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)

        total := 0.0
        for _, fw := range keys </span><span class="cov0" title="0">{
                tr := trackingSummary[fw]
                // build requirement definition map for priority weighting
                reqDefs := make(map[string]*ComplianceRequirement)
                if fwDef, ok := frameworkDefs.frameworks[fw]; ok &amp;&amp; fwDef != nil </span><span class="cov0" title="0">{
                        for i := range fwDef.Requirements </span><span class="cov0" title="0">{
                                req := fwDef.Requirements[i]
                                reqCopy := req // capture
                                reqDefs[req.RequirementID] = &amp;reqCopy
                        }</span>
                }
                <span class="cov0" title="0">fwScore := e.FrameworkScore(tr, reqDefs)
                total += fwScore</span>
        }
        <span class="cov0" title="0">return clamp(total/float64(len(keys)), e.weights.MinScore, e.weights.MaxScore)</span>
}

// scoring primitives

func (e *ScoringEngine) scoreByRequirementStatus(s ComplianceStatus) float64 <span class="cov0" title="0">{
        switch s </span>{
        case ComplianceStatusVerified:<span class="cov0" title="0">
                return 100</span>
        case ComplianceStatusImplemented:<span class="cov0" title="0">
                return 80</span>
        case ComplianceStatusInProgress:<span class="cov0" title="0">
                return 50</span>
        case ComplianceStatusNotStarted:<span class="cov0" title="0">
                return 10</span>
        case ComplianceStatusNonCompliant:<span class="cov0" title="0">
                return 0</span>
        case ComplianceStatusExempt:<span class="cov0" title="0">
                return 70</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

func (e *ScoringEngine) scoreByImplementationStatus(s ImplementationStatus) float64 <span class="cov0" title="0">{
        switch s </span>{
        case ImplementationStatusDeployed:<span class="cov0" title="0">
                return 100</span>
        case ImplementationStatusTested:<span class="cov0" title="0">
                return 85</span>
        case ImplementationStatusImplemented:<span class="cov0" title="0">
                return 75</span>
        case ImplementationStatusInProgress:<span class="cov0" title="0">
                return 50</span>
        case ImplementationStatusPlanned:<span class="cov0" title="0">
                return 25</span>
        case ImplementationStatusNotImplemented:<span class="cov0" title="0">
                return 0</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

func (e *ScoringEngine) controlsAggregateScore(controls []ControlTracking) float64 <span class="cov0" title="0">{
        if len(controls) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">sum := 0.0
        for i := range controls </span><span class="cov0" title="0">{
                sum += e.controlScore(&amp;controls[i])
        }</span>
        <span class="cov0" title="0">return sum / float64(len(controls))</span>
}

func (e *ScoringEngine) controlScore(ctrl *ControlTracking) float64 <span class="cov0" title="0">{
        if ctrl == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">base := 0.0
        switch ctrl.Effectiveness </span>{
        case ControlEffectivenessHighlyEffective:<span class="cov0" title="0">
                base = 100</span>
        case ControlEffectivenessEffective:<span class="cov0" title="0">
                base = 80</span>
        case ControlEffectivenessPartiallyEffective:<span class="cov0" title="0">
                base = 50</span>
        case ControlEffectivenessIneffective:<span class="cov0" title="0">
                base = 10</span>
        }
        // recency: tests within 30 days preferred
        <span class="cov0" title="0">recency := e.recencyScore(ptrTimeOrZero(ctrl.LastTested), 30*24*time.Hour)
        // evidence presence bonus (capped small)
        evidence := e.evidenceScore(len(ctrl.Evidence))
        // combine with small weights to avoid dominance
        score := base*0.85 + recency*0.10 + evidence*0.05
        return clamp(score, e.weights.MinScore, e.weights.MaxScore)</span>
}

func (e *ScoringEngine) evidenceScore(count int) float64 <span class="cov0" title="0">{
        if count &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if count &gt;= 5 </span><span class="cov0" title="0">{
                return 100
        }</span>
        <span class="cov0" title="0">return (float64(count) / 5.0) * 100.0</span>
}

// recencyScore returns 100 if within targetAge; declines to 0 as age approaches 4x target
func (e *ScoringEngine) recencyScore(last time.Time, targetAge time.Duration) float64 <span class="cov0" title="0">{
        if last.IsZero() </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">age := time.Since(last)
        if age &lt;= targetAge </span><span class="cov0" title="0">{
                return 100
        }</span>
        // linear decay to 0 at 4x target
        <span class="cov0" title="0">maxAge := 4 * targetAge
        if age &gt;= maxAge </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">ratio := 1.0 - (float64(age) / float64(maxAge))
        return clamp(ratio*100.0, 0, 100)</span>
}

func clamp(v, min, max float64) float64 <span class="cov0" title="0">{
        return math.Max(min, math.Min(max, v))
}</span>

func ptrTimeOrZero(t *time.Time) time.Time <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>
        <span class="cov0" title="0">return *t</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package compliance

import (
        "time"
)

// SOC2Framework defines the SOC 2 compliance framework
const (
        FrameworkSOC2 = "SOC2"

        // SOC 2 Trust Service Criteria
        SOC2CriteriaCC = "CC" // Common Criteria
        SOC2CriteriaA  = "A"  // Availability
        SOC2CriteriaC  = "C"  // Confidentiality
        SOC2CriteriaP  = "P"  // Privacy
        SOC2CriteriaI  = "I"  // Integrity

        // SOC 2 Report Types
        SOC2ReportType1 = "Type 1" // Point in time
        SOC2ReportType2 = "Type 2" // Period of time
)

// SOC2Requirement represents a SOC 2 requirement
type SOC2Requirement struct {
        ID                   string                 `json:"id"`
        Criteria             string                 `json:"criteria"`       // CC, A, C, P, I
        Category             string                 `json:"category"`       // Control Environment, Communication, Risk Assessment, etc.
        Principle            string                 `json:"principle"`      // COSO Principle number
        RequirementID        string                 `json:"requirement_id"` // e.g., CC1.1, CC2.1
        Title                string                 `json:"title"`
        Description          string                 `json:"description"`
        DetailedDescription  string                 `json:"detailed_description"`
        RiskLevel            ComplianceRiskLevel    `json:"risk_level"`
        Priority             CompliancePriority     `json:"priority"`
        ImplementationStatus ImplementationStatus   `json:"implementation_status"`
        EvidenceRequired     bool                   `json:"evidence_required"`
        EvidenceDescription  string                 `json:"evidence_description"`
        TestingProcedures    []string               `json:"testing_procedures"`
        KeyControls          []string               `json:"key_controls"`
        SubRequirements      []SOC2Requirement      `json:"sub_requirements,omitempty"`
        ParentRequirementID  *string                `json:"parent_requirement_id,omitempty"`
        EffectiveDate        time.Time              `json:"effective_date"`
        LastUpdated          time.Time              `json:"last_updated"`
        NextReviewDate       time.Time              `json:"next_review_date"`
        ReviewFrequency      string                 `json:"review_frequency"`
        ComplianceOfficer    string                 `json:"compliance_officer"`
        Tags                 []string               `json:"tags"`
        Metadata             map[string]interface{} `json:"metadata,omitempty"`
}

// SOC2FrameworkDefinition represents the complete SOC 2 framework
type SOC2FrameworkDefinition struct {
        ID              string                 `json:"id"`
        Name            string                 `json:"name"`
        Version         string                 `json:"version"`
        Description     string                 `json:"description"`
        Type            FrameworkType          `json:"type"`
        Jurisdiction    string                 `json:"jurisdiction"`
        GeographicScope []string               `json:"geographic_scope"`
        IndustryScope   []string               `json:"industry_scope"`
        EffectiveDate   time.Time              `json:"effective_date"`
        LastUpdated     time.Time              `json:"last_updated"`
        NextReviewDate  time.Time              `json:"next_review_date"`
        Requirements    []SOC2Requirement      `json:"requirements"`
        Criteria        []SOC2Criteria         `json:"criteria"`
        MappingRules    []FrameworkMapping     `json:"mapping_rules"`
        Metadata        map[string]interface{} `json:"metadata,omitempty"`
}

// SOC2Criteria represents a SOC 2 Trust Service Criteria
type SOC2Criteria struct {
        ID            string                 `json:"id"`
        Name          string                 `json:"name"`
        Code          string                 `json:"code"` // CC, A, C, P, I
        Description   string                 `json:"description"`
        Requirements  []string               `json:"requirements"` // Requirement IDs
        Categories    []string               `json:"categories"`
        Principles    []string               `json:"principles"`
        RiskLevel     ComplianceRiskLevel    `json:"risk_level"`
        Priority      CompliancePriority     `json:"priority"`
        EffectiveDate time.Time              `json:"effective_date"`
        LastUpdated   time.Time              `json:"last_updated"`
        Metadata      map[string]interface{} `json:"metadata,omitempty"`
}

// SOC2ComplianceStatus represents SOC 2 specific compliance status
type SOC2ComplianceStatus struct {
        BusinessID          string                           `json:"business_id"`
        Framework           string                           `json:"framework"`
        ReportType          string                           `json:"report_type"` // Type 1 or Type 2
        AssessmentPeriod    string                           `json:"assessment_period"`
        OverallStatus       ComplianceStatus                 `json:"overall_status"`
        ComplianceScore     float64                          `json:"compliance_score"`
        CriteriaStatus      map[string]CriteriaStatus        `json:"criteria_status"`
        RequirementsStatus  map[string]SOC2RequirementStatus `json:"requirements_status"`
        LastAssessment      time.Time                        `json:"last_assessment"`
        NextAssessment      time.Time                        `json:"next_assessment"`
        AssessmentFrequency string                           `json:"assessment_frequency"`
        ComplianceOfficer   string                           `json:"compliance_officer"`
        Auditor             string                           `json:"auditor,omitempty"`
        CertificationDate   *time.Time                       `json:"certification_date,omitempty"`
        CertificationExpiry *time.Time                       `json:"certification_expiry,omitempty"`
        CertificationBody   string                           `json:"certification_body,omitempty"`
        CertificationNumber string                           `json:"certification_number,omitempty"`
        Notes               string                           `json:"notes"`
        Metadata            map[string]interface{}           `json:"metadata,omitempty"`
}

// CriteriaStatus represents status for a specific SOC 2 criteria
type CriteriaStatus struct {
        CriteriaID        string           `json:"criteria_id"`
        CriteriaName      string           `json:"criteria_name"`
        Status            ComplianceStatus `json:"status"`
        Score             float64          `json:"score"`
        RequirementCount  int              `json:"requirement_count"`
        ImplementedCount  int              `json:"implemented_count"`
        VerifiedCount     int              `json:"verified_count"`
        NonCompliantCount int              `json:"non_compliant_count"`
        ExemptCount       int              `json:"exempt_count"`
        LastReviewed      time.Time        `json:"last_reviewed"`
        NextReview        time.Time        `json:"next_review"`
        Reviewer          string           `json:"reviewer"`
        Notes             string           `json:"notes"`
}

// SOC2RequirementStatus represents status for a specific SOC 2 requirement
type SOC2RequirementStatus struct {
        RequirementID        string               `json:"requirement_id"`
        CriteriaID           string               `json:"criteria_id"`
        Title                string               `json:"title"`
        Status               ComplianceStatus     `json:"status"`
        ImplementationStatus ImplementationStatus `json:"implementation_status"`
        ComplianceScore      float64              `json:"compliance_score"`
        RiskLevel            ComplianceRiskLevel  `json:"risk_level"`
        Priority             CompliancePriority   `json:"priority"`
        LastReviewed         time.Time            `json:"last_reviewed"`
        NextReview           time.Time            `json:"next_review"`
        Reviewer             string               `json:"reviewer"`
        EvidenceCount        int                  `json:"evidence_count"`
        ExceptionCount       int                  `json:"exception_count"`
        RemediationPlanCount int                  `json:"remediation_plan_count"`
        Trend                string               `json:"trend"`
        TrendStrength        string               `json:"trend_strength"`
        Notes                string               `json:"notes"`
}

// NewSOC2Framework creates a new SOC 2 framework definition
func NewSOC2Framework() *SOC2FrameworkDefinition <span class="cov0" title="0">{
        return &amp;SOC2FrameworkDefinition{
                ID:              FrameworkSOC2,
                Name:            "SOC 2 Trust Services Criteria",
                Version:         "2017",
                Description:     "AICPA Trust Services Criteria for Security, Availability, Processing Integrity, Confidentiality, and Privacy",
                Type:            FrameworkTypeSecurity,
                Jurisdiction:    "United States",
                GeographicScope: []string{"United States", "Canada"},
                IndustryScope:   []string{"Technology", "Financial Services", "Healthcare", "Retail"},
                EffectiveDate:   time.Date(2017, 1, 1, 0, 0, 0, 0, time.UTC),
                LastUpdated:     time.Now(),
                NextReviewDate:  time.Now().AddDate(1, 0, 0),
                Requirements:    getSOC2Requirements(),
                Criteria:        getSOC2Criteria(),
                Metadata:        make(map[string]interface{}),
        }
}</span>

// getSOC2Criteria returns the SOC 2 Trust Service Criteria
func getSOC2Criteria() []SOC2Criteria <span class="cov0" title="0">{
        return []SOC2Criteria{
                {
                        ID:          SOC2CriteriaCC,
                        Name:        "Common Criteria",
                        Code:        SOC2CriteriaCC,
                        Description: "Security, availability, and processing integrity criteria that apply to all services",
                        RiskLevel:   ComplianceRiskLevelHigh,
                        Priority:    CompliancePriorityHigh,
                        Categories:  []string{"Control Environment", "Communication", "Risk Assessment", "Monitoring Activities", "Control Activities", "Information and Communication", "Logical and Physical Access Controls", "System Operations", "Change Management", "Risk Mitigation"},
                        Principles:  []string{"CC1", "CC2", "CC3", "CC4", "CC5", "CC6", "CC7", "CC8", "CC9"},
                },
                {
                        ID:          SOC2CriteriaA,
                        Name:        "Availability",
                        Code:        SOC2CriteriaA,
                        Description: "The system is available for operation and use as committed or agreed",
                        RiskLevel:   ComplianceRiskLevelMedium,
                        Priority:    CompliancePriorityMedium,
                        Categories:  []string{"Availability", "System Operations", "Change Management"},
                        Principles:  []string{"A1"},
                },
                {
                        ID:          SOC2CriteriaC,
                        Name:        "Confidentiality",
                        Code:        SOC2CriteriaC,
                        Description: "Information designated as confidential is protected as committed or agreed",
                        RiskLevel:   ComplianceRiskLevelHigh,
                        Priority:    CompliancePriorityHigh,
                        Categories:  []string{"Confidentiality", "Logical and Physical Access Controls", "System Operations"},
                        Principles:  []string{"C1"},
                },
                {
                        ID:          SOC2CriteriaP,
                        Name:        "Privacy",
                        Code:        SOC2CriteriaP,
                        Description: "Personal information is collected, used, retained, disclosed, and disposed of in conformity with the commitments in the entity's privacy notice",
                        RiskLevel:   ComplianceRiskLevelHigh,
                        Priority:    CompliancePriorityHigh,
                        Categories:  []string{"Privacy", "Notice and Communication", "Choice and Consent", "Collection", "Use, Retention, and Disposal", "Access", "Disclosure to Third Parties", "Quality", "Monitoring and Enforcement"},
                        Principles:  []string{"P1", "P2", "P3", "P4", "P5", "P6", "P7", "P8"},
                },
                {
                        ID:          SOC2CriteriaI,
                        Name:        "Processing Integrity",
                        Code:        SOC2CriteriaI,
                        Description: "System processing is complete, accurate, timely, and authorized",
                        RiskLevel:   ComplianceRiskLevelMedium,
                        Priority:    CompliancePriorityMedium,
                        Categories:  []string{"Processing Integrity", "System Operations", "Change Management"},
                        Principles:  []string{"PI1"},
                },
        }
}</span>

// getSOC2Requirements returns the SOC 2 requirements
func getSOC2Requirements() []SOC2Requirement <span class="cov0" title="0">{
        return []SOC2Requirement{
                // Common Criteria (CC) Requirements
                {
                        ID:                   "CC1.1",
                        Criteria:             SOC2CriteriaCC,
                        Category:             "Control Environment",
                        Principle:            "CC1",
                        RequirementID:        "CC1.1",
                        Title:                "Commitment to Integrity and Ethical Values",
                        Description:          "The entity demonstrates a commitment to integrity and ethical values",
                        DetailedDescription:  "The entity demonstrates a commitment to integrity and ethical values through the development and use of entity standards, policies, and procedures that support the entity's culture and guide the conduct of the entity's personnel in performing their assigned functions and in relationships with customers, suppliers, and other parties.",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Entity standards, policies, and procedures; training materials; communication records; disciplinary actions",
                        TestingProcedures:    []string{"Review entity standards and policies", "Interview management and personnel", "Review training records", "Review disciplinary actions"},
                        KeyControls:          []string{"Code of Conduct", "Ethics Policy", "Training Program", "Disciplinary Procedures"},
                        EffectiveDate:        time.Date(2017, 1, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"control-environment", "ethics", "integrity"},
                },
                {
                        ID:                   "CC2.1",
                        Criteria:             SOC2CriteriaCC,
                        Category:             "Communication and Information",
                        Principle:            "CC2",
                        RequirementID:        "CC2.1",
                        Title:                "Information Quality",
                        Description:          "The entity obtains or generates and uses relevant, quality information to support the functioning of internal control",
                        DetailedDescription:  "The entity obtains or generates and uses relevant, quality information to support the functioning of internal control. Information is quality information if it is appropriate, current, complete, accurate, accessible, and provided on a timely basis.",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Information quality standards; data validation procedures; information system controls",
                        TestingProcedures:    []string{"Review information quality standards", "Test data validation procedures", "Review information system controls"},
                        KeyControls:          []string{"Data Quality Standards", "Validation Procedures", "Information System Controls"},
                        EffectiveDate:        time.Date(2017, 1, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"information-quality", "data-validation", "system-controls"},
                },
                {
                        ID:                   "CC3.1",
                        Criteria:             SOC2CriteriaCC,
                        Category:             "Risk Assessment",
                        Principle:            "CC3",
                        RequirementID:        "CC3.1",
                        Title:                "Risk Identification",
                        Description:          "The entity identifies risks to the achievement of its objectives across the entity and analyzes risks as a basis for determining how the risks should be managed",
                        DetailedDescription:  "The entity identifies risks to the achievement of its objectives across the entity and analyzes risks as a basis for determining how the risks should be managed. Risk identification includes the identification of risks from external sources, including those related to technology, economic, political, and social conditions, and natural catastrophes.",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Risk assessment procedures; risk registers; risk analysis reports",
                        TestingProcedures:    []string{"Review risk assessment procedures", "Review risk registers", "Review risk analysis reports"},
                        KeyControls:          []string{"Risk Assessment Procedures", "Risk Register", "Risk Analysis Reports"},
                        EffectiveDate:        time.Date(2017, 1, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"risk-assessment", "risk-identification", "risk-analysis"},
                },
                // Add more CC requirements as needed...

                // Availability (A) Requirements
                {
                        ID:                   "A1.1",
                        Criteria:             SOC2CriteriaA,
                        Category:             "Availability",
                        Principle:            "A1",
                        RequirementID:        "A1.1",
                        Title:                "Availability",
                        Description:          "The entity maintains, monitors, and evaluates current processing capacity and projected processing needs",
                        DetailedDescription:  "The entity maintains, monitors, and evaluates current processing capacity and projected processing needs, including the following: a) Current and projected processing capacity and availability, b) Current and projected processing needs, c) Current and projected processing capacity and availability compared to current and projected processing needs, d) Current and projected processing capacity and availability compared to current and projected processing needs, and e) Current and projected processing capacity and availability compared to current and projected processing needs.",
                        RiskLevel:            ComplianceRiskLevelMedium,
                        Priority:             CompliancePriorityMedium,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Capacity planning procedures; monitoring reports; evaluation results",
                        TestingProcedures:    []string{"Review capacity planning procedures", "Review monitoring reports", "Review evaluation results"},
                        KeyControls:          []string{"Capacity Planning", "Monitoring Procedures", "Evaluation Procedures"},
                        EffectiveDate:        time.Date(2017, 1, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"availability", "capacity-planning", "monitoring"},
                },

                // Confidentiality (C) Requirements
                {
                        ID:                   "C1.1",
                        Criteria:             SOC2CriteriaC,
                        Category:             "Confidentiality",
                        Principle:            "C1",
                        RequirementID:        "C1.1",
                        Title:                "Confidentiality",
                        Description:          "The entity identifies and maintains confidential information to meet the entity's objectives related to confidentiality",
                        DetailedDescription:  "The entity identifies and maintains confidential information to meet the entity's objectives related to confidentiality. Confidential information is information that is designated as confidential and that meets the entity's criteria for classification as confidential information.",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Confidentiality classification procedures; access controls; encryption procedures",
                        TestingProcedures:    []string{"Review confidentiality classification procedures", "Test access controls", "Review encryption procedures"},
                        KeyControls:          []string{"Classification Procedures", "Access Controls", "Encryption Procedures"},
                        EffectiveDate:        time.Date(2017, 1, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"confidentiality", "classification", "access-controls"},
                },

                // Privacy (P) Requirements
                {
                        ID:                   "P1.1",
                        Criteria:             SOC2CriteriaP,
                        Category:             "Notice and Communication",
                        Principle:            "P1",
                        RequirementID:        "P1.1",
                        Title:                "Notice and Communication of Objectives",
                        Description:          "The entity provides notice to data subjects about its privacy practices",
                        DetailedDescription:  "The entity provides notice to data subjects about its privacy practices. The notice is provided to data subjects at or before the time personal information is collected or as soon as practicable thereafter.",
                        RiskLevel:            ComplianceRiskLevelHigh,
                        Priority:             CompliancePriorityHigh,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Privacy notices; communication procedures; consent mechanisms",
                        TestingProcedures:    []string{"Review privacy notices", "Review communication procedures", "Test consent mechanisms"},
                        KeyControls:          []string{"Privacy Notices", "Communication Procedures", "Consent Mechanisms"},
                        EffectiveDate:        time.Date(2017, 1, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"privacy", "notice", "communication"},
                },

                // Processing Integrity (PI) Requirements
                {
                        ID:                   "PI1.1",
                        Criteria:             SOC2CriteriaI,
                        Category:             "Processing Integrity",
                        Principle:            "PI1",
                        RequirementID:        "PI1.1",
                        Title:                "Processing Integrity",
                        Description:          "The entity implements policies and procedures to provide reasonable assurance that system processing is complete, accurate, timely, and authorized",
                        DetailedDescription:  "The entity implements policies and procedures to provide reasonable assurance that system processing is complete, accurate, timely, and authorized. System processing includes the following: a) Input, b) Processing, c) Output, and d) Storage.",
                        RiskLevel:            ComplianceRiskLevelMedium,
                        Priority:             CompliancePriorityMedium,
                        ImplementationStatus: ImplementationStatusNotImplemented,
                        EvidenceRequired:     true,
                        EvidenceDescription:  "Processing integrity policies; validation procedures; error handling procedures",
                        TestingProcedures:    []string{"Review processing integrity policies", "Test validation procedures", "Review error handling procedures"},
                        KeyControls:          []string{"Processing Policies", "Validation Procedures", "Error Handling"},
                        EffectiveDate:        time.Date(2017, 1, 1, 0, 0, 0, 0, time.UTC),
                        LastUpdated:          time.Now(),
                        NextReviewDate:       time.Now().AddDate(0, 6, 0),
                        ReviewFrequency:      "semi-annually",
                        Tags:                 []string{"processing-integrity", "validation", "error-handling"},
                },
        }
}</span>

// ConvertSOC2ToRegulatoryFramework converts SOC2FrameworkDefinition to RegulatoryFramework
func (soc2 *SOC2FrameworkDefinition) ConvertSOC2ToRegulatoryFramework() *RegulatoryFramework <span class="cov0" title="0">{
        requirements := make([]ComplianceRequirement, len(soc2.Requirements))
        for i, req := range soc2.Requirements </span><span class="cov0" title="0">{
                requirements[i] = ComplianceRequirement{
                        ID:                   req.ID,
                        Framework:            soc2.ID,
                        Category:             req.Category,
                        RequirementID:        req.RequirementID,
                        Title:                req.Title,
                        Description:          req.Description,
                        DetailedDescription:  req.DetailedDescription,
                        RiskLevel:            req.RiskLevel,
                        Priority:             req.Priority,
                        Status:               ComplianceStatusNotStarted,
                        ImplementationStatus: req.ImplementationStatus,
                        EvidenceRequired:     req.EvidenceRequired,
                        EvidenceDescription:  req.EvidenceDescription,
                        Controls:             []ComplianceControl{},
                        SubRequirements:      []ComplianceRequirement{},
                        ParentRequirementID:  req.ParentRequirementID,
                        ApplicableBusinesses: []string{},
                        GeographicScope:      soc2.GeographicScope,
                        IndustryScope:        soc2.IndustryScope,
                        EffectiveDate:        req.EffectiveDate,
                        LastUpdated:          req.LastUpdated,
                        NextReviewDate:       req.NextReviewDate,
                        ReviewFrequency:      req.ReviewFrequency,
                        ComplianceOfficer:    req.ComplianceOfficer,
                        Tags:                 req.Tags,
                        Metadata:             req.Metadata,
                }
        }</span>

        <span class="cov0" title="0">return &amp;RegulatoryFramework{
                ID:              soc2.ID,
                Name:            soc2.Name,
                Version:         soc2.Version,
                Description:     soc2.Description,
                Type:            soc2.Type,
                Jurisdiction:    soc2.Jurisdiction,
                GeographicScope: soc2.GeographicScope,
                IndustryScope:   soc2.IndustryScope,
                EffectiveDate:   soc2.EffectiveDate,
                LastUpdated:     soc2.LastUpdated,
                NextReviewDate:  soc2.NextReviewDate,
                Requirements:    requirements,
                MappingRules:    soc2.MappingRules,
                Metadata:        soc2.Metadata,
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package compliance

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// SOC2TrackingService provides SOC 2 specific compliance tracking
type SOC2TrackingService struct {
        logger        *observability.Logger
        statusSystem  *ComplianceStatusSystem
        mappingSystem *FrameworkMappingSystem
        mu            sync.RWMutex
        soc2Data      map[string]*SOC2ComplianceStatus // businessID -&gt; SOC2 status
}

// NewSOC2TrackingService creates a new SOC 2 tracking service
func NewSOC2TrackingService(logger *observability.Logger, statusSystem *ComplianceStatusSystem, mappingSystem *FrameworkMappingSystem) *SOC2TrackingService <span class="cov0" title="0">{
        return &amp;SOC2TrackingService{
                logger:        logger,
                statusSystem:  statusSystem,
                mappingSystem: mappingSystem,
                soc2Data:      make(map[string]*SOC2ComplianceStatus),
        }
}</span>

// InitializeSOC2Tracking initializes SOC 2 tracking for a business
func (s *SOC2TrackingService) InitializeSOC2Tracking(ctx context.Context, businessID string, reportType string) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Initializing SOC 2 tracking for business",
                "request_id", requestID,
                "business_id", businessID,
                "report_type", reportType,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        // Check if SOC 2 tracking already exists
        if _, exists := s.soc2Data[businessID]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("SOC 2 tracking already initialized for business %s", businessID)
        }</span>

        // Create new SOC 2 compliance status
        <span class="cov0" title="0">soc2Status := &amp;SOC2ComplianceStatus{
                BusinessID:          businessID,
                Framework:           FrameworkSOC2,
                ReportType:          reportType,
                AssessmentPeriod:    "annual",
                OverallStatus:       ComplianceStatusNotStarted,
                ComplianceScore:     0.0,
                CriteriaStatus:      make(map[string]CriteriaStatus),
                RequirementsStatus:  make(map[string]SOC2RequirementStatus),
                LastAssessment:      time.Now(),
                NextAssessment:      time.Now().AddDate(1, 0, 0),
                AssessmentFrequency: "annually",
                ComplianceOfficer:   "system",
                Metadata:            make(map[string]interface{}),
        }

        // Initialize criteria status
        soc2Framework := NewSOC2Framework()
        for _, criteria := range soc2Framework.Criteria </span><span class="cov0" title="0">{
                soc2Status.CriteriaStatus[criteria.Code] = CriteriaStatus{
                        CriteriaID:       criteria.Code,
                        CriteriaName:     criteria.Name,
                        Status:           ComplianceStatusNotStarted,
                        Score:            0.0,
                        RequirementCount: 0,
                        LastReviewed:     time.Now(),
                        NextReview:       time.Now().AddDate(0, 6, 0),
                        Reviewer:         "system",
                }
        }</span>

        // Initialize requirements status
        <span class="cov0" title="0">for _, requirement := range soc2Framework.Requirements </span><span class="cov0" title="0">{
                soc2Status.RequirementsStatus[requirement.RequirementID] = SOC2RequirementStatus{
                        RequirementID:        requirement.RequirementID,
                        CriteriaID:           requirement.Criteria,
                        Title:                requirement.Title,
                        Status:               ComplianceStatusNotStarted,
                        ImplementationStatus: requirement.ImplementationStatus,
                        ComplianceScore:      0.0,
                        RiskLevel:            requirement.RiskLevel,
                        Priority:             requirement.Priority,
                        LastReviewed:         time.Now(),
                        NextReview:           requirement.NextReviewDate,
                        Reviewer:             "system",
                        EvidenceCount:        0,
                        ExceptionCount:       0,
                        RemediationPlanCount: 0,
                        Trend:                "stable",
                        TrendStrength:        "none",
                }
        }</span>

        // Store the SOC 2 status
        <span class="cov0" title="0">s.soc2Data[businessID] = soc2Status

        // Register SOC 2 framework with mapping system if not already registered
        soc2RegulatoryFramework := soc2Framework.ConvertSOC2ToRegulatoryFramework()
        err := s.mappingSystem.RegisterFramework(ctx, soc2RegulatoryFramework)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to register SOC 2 framework with mapping system",
                        "request_id", requestID,
                        "business_id", businessID,
                        "error", err.Error(),
                )
                // Don't fail the initialization for this
        }</span>

        <span class="cov0" title="0">s.logger.Info("SOC 2 tracking initialized successfully",
                "request_id", requestID,
                "business_id", businessID,
                "report_type", reportType,
                "criteria_count", len(soc2Status.CriteriaStatus),
                "requirements_count", len(soc2Status.RequirementsStatus),
        )

        return nil</span>
}

// GetSOC2Status retrieves SOC 2 compliance status for a business
func (s *SOC2TrackingService) GetSOC2Status(ctx context.Context, businessID string) (*SOC2ComplianceStatus, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.mu.RLock()
        defer s.mu.RUnlock()

        soc2Status, exists := s.soc2Data[businessID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SOC 2 tracking not initialized for business %s", businessID)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Retrieved SOC 2 status",
                "request_id", requestID,
                "business_id", businessID,
                "overall_status", soc2Status.OverallStatus,
                "compliance_score", soc2Status.ComplianceScore,
        )

        return soc2Status, nil</span>
}

// UpdateSOC2RequirementStatus updates the status of a specific SOC 2 requirement
func (s *SOC2TrackingService) UpdateSOC2RequirementStatus(ctx context.Context, businessID, requirementID string, status ComplianceStatus, implementationStatus ImplementationStatus, score float64, reviewer string) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Updating SOC 2 requirement status",
                "request_id", requestID,
                "business_id", businessID,
                "requirement_id", requirementID,
                "status", status,
                "implementation_status", implementationStatus,
                "score", score,
                "reviewer", reviewer,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        soc2Status, exists := s.soc2Data[businessID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("SOC 2 tracking not initialized for business %s", businessID)
        }</span>

        <span class="cov0" title="0">reqStatus, exists := soc2Status.RequirementsStatus[requirementID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("requirement %s not found in SOC 2 framework", requirementID)
        }</span>

        // Update requirement status
        <span class="cov0" title="0">reqStatus.Status = status
        reqStatus.ImplementationStatus = implementationStatus
        reqStatus.ComplianceScore = score
        reqStatus.LastReviewed = time.Now()
        reqStatus.Reviewer = reviewer

        soc2Status.RequirementsStatus[requirementID] = reqStatus

        // Update criteria status
        s.updateCriteriaStatus(soc2Status, reqStatus.CriteriaID)

        // Update overall status
        s.updateOverallStatus(soc2Status)

        s.logger.Info("SOC 2 requirement status updated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "requirement_id", requirementID,
                "new_status", status,
                "new_score", score,
        )

        return nil</span>
}

// UpdateSOC2CriteriaStatus updates the status of a specific SOC 2 criteria
func (s *SOC2TrackingService) UpdateSOC2CriteriaStatus(ctx context.Context, businessID, criteriaID string, status ComplianceStatus, score float64, reviewer string) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Updating SOC 2 criteria status",
                "request_id", requestID,
                "business_id", businessID,
                "criteria_id", criteriaID,
                "status", status,
                "score", score,
                "reviewer", reviewer,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        soc2Status, exists := s.soc2Data[businessID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("SOC 2 tracking not initialized for business %s", businessID)
        }</span>

        <span class="cov0" title="0">criteriaStatus, exists := soc2Status.CriteriaStatus[criteriaID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("criteria %s not found in SOC 2 framework", criteriaID)
        }</span>

        // Update criteria status
        <span class="cov0" title="0">criteriaStatus.Status = status
        criteriaStatus.Score = score
        criteriaStatus.LastReviewed = time.Now()
        criteriaStatus.Reviewer = reviewer

        soc2Status.CriteriaStatus[criteriaID] = criteriaStatus

        // Update overall status
        s.updateOverallStatus(soc2Status)

        s.logger.Info("SOC 2 criteria status updated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "criteria_id", criteriaID,
                "new_status", status,
                "new_score", score,
        )

        return nil</span>
}

// AssessSOC2Compliance performs a comprehensive SOC 2 compliance assessment
func (s *SOC2TrackingService) AssessSOC2Compliance(ctx context.Context, businessID string) (*SOC2ComplianceStatus, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Starting SOC 2 compliance assessment",
                "request_id", requestID,
                "business_id", businessID,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        soc2Status, exists := s.soc2Data[businessID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SOC 2 tracking not initialized for business %s", businessID)
        }</span>

        // Perform assessment for each criteria
        <span class="cov0" title="0">soc2Framework := NewSOC2Framework()
        for _, criteria := range soc2Framework.Criteria </span><span class="cov0" title="0">{
                criteriaScore := s.assessCriteria(ctx, soc2Status, criteria.Code)
                criteriaStatus := soc2Status.CriteriaStatus[criteria.Code]
                criteriaStatus.Score = criteriaScore
                criteriaStatus.LastReviewed = time.Now()
                criteriaStatus.Reviewer = "system"

                // Determine criteria status based on score
                if criteriaScore &gt;= 90.0 </span><span class="cov0" title="0">{
                        criteriaStatus.Status = ComplianceStatusVerified
                }</span> else<span class="cov0" title="0"> if criteriaScore &gt;= 70.0 </span><span class="cov0" title="0">{
                        criteriaStatus.Status = ComplianceStatusImplemented
                }</span> else<span class="cov0" title="0"> if criteriaScore &gt;= 30.0 </span><span class="cov0" title="0">{
                        criteriaStatus.Status = ComplianceStatusInProgress
                }</span> else<span class="cov0" title="0"> {
                        criteriaStatus.Status = ComplianceStatusNotStarted
                }</span>

                <span class="cov0" title="0">soc2Status.CriteriaStatus[criteria.Code] = criteriaStatus</span>
        }

        // Update overall status
        <span class="cov0" title="0">s.updateOverallStatus(soc2Status)

        // Update assessment timestamp
        soc2Status.LastAssessment = time.Now()
        soc2Status.NextAssessment = time.Now().AddDate(1, 0, 0)

        s.logger.Info("SOC 2 compliance assessment completed",
                "request_id", requestID,
                "business_id", businessID,
                "overall_status", soc2Status.OverallStatus,
                "compliance_score", soc2Status.ComplianceScore,
        )

        return soc2Status, nil</span>
}

// GetSOC2Report generates a SOC 2 compliance report
func (s *SOC2TrackingService) GetSOC2Report(ctx context.Context, businessID string, reportType string) (*ComplianceReport, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Generating SOC 2 compliance report",
                "request_id", requestID,
                "business_id", businessID,
                "report_type", reportType,
        )

        soc2Status, err := s.GetSOC2Status(ctx, businessID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert SOC 2 status to compliance report
        <span class="cov0" title="0">report := &amp;ComplianceReport{
                ID:               fmt.Sprintf("soc2_report_%s_%s", businessID, time.Now().Format("20060102")),
                BusinessID:       businessID,
                Framework:        FrameworkSOC2,
                ReportType:       ReportTypeStatus,
                Title:            fmt.Sprintf("SOC 2 Compliance Report - %s", businessID),
                Description:      "SOC 2 Trust Services Criteria compliance assessment report",
                GeneratedAt:      time.Now(),
                GeneratedBy:      "system",
                Period:           "annual",
                OverallStatus:    soc2Status.OverallStatus,
                ComplianceScore:  soc2Status.ComplianceScore,
                Requirements:     []RequirementReport{},
                Controls:         []ControlReport{},
                Exceptions:       []ExceptionReport{},
                RemediationPlans: []RemediationReport{},
                Recommendations:  []ComplianceRecommendation{},
                Metadata:         make(map[string]interface{}),
        }

        // Add SOC 2 specific metadata
        report.Metadata["soc2_report_type"] = soc2Status.ReportType
        report.Metadata["soc2_assessment_period"] = soc2Status.AssessmentPeriod
        report.Metadata["soc2_criteria_count"] = len(soc2Status.CriteriaStatus)
        report.Metadata["soc2_requirements_count"] = len(soc2Status.RequirementsStatus)

        // Convert requirements to report format
        for reqID, reqStatus := range soc2Status.RequirementsStatus </span><span class="cov0" title="0">{
                requirementReport := RequirementReport{
                        RequirementID:        reqID,
                        Title:                reqStatus.Title,
                        Status:               reqStatus.Status,
                        ImplementationStatus: reqStatus.ImplementationStatus,
                        ComplianceScore:      reqStatus.ComplianceScore,
                        RiskLevel:            reqStatus.RiskLevel,
                        Priority:             reqStatus.Priority,
                        LastReviewed:         reqStatus.LastReviewed,
                        NextReview:           reqStatus.NextReview,
                        Controls:             []ControlReport{},
                        Exceptions:           []ExceptionReport{},
                        RemediationPlans:     []RemediationReport{},
                }
                report.Requirements = append(report.Requirements, requirementReport)
        }</span>

        <span class="cov0" title="0">s.logger.Info("SOC 2 compliance report generated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "report_id", report.ID,
                "requirements_count", len(report.Requirements),
        )

        return report, nil</span>
}

// updateCriteriaStatus updates the status of a criteria based on its requirements
func (s *SOC2TrackingService) updateCriteriaStatus(soc2Status *SOC2ComplianceStatus, criteriaID string) <span class="cov0" title="0">{
        criteriaStatus := soc2Status.CriteriaStatus[criteriaID]

        var totalScore float64
        var requirementCount int
        var implementedCount int
        var verifiedCount int
        var nonCompliantCount int
        var exemptCount int

        // Calculate criteria status based on requirements
        for _, reqStatus := range soc2Status.RequirementsStatus </span><span class="cov0" title="0">{
                if reqStatus.CriteriaID == criteriaID </span><span class="cov0" title="0">{
                        requirementCount++
                        totalScore += reqStatus.ComplianceScore

                        switch reqStatus.Status </span>{
                        case ComplianceStatusVerified:<span class="cov0" title="0">
                                verifiedCount++</span>
                        case ComplianceStatusImplemented:<span class="cov0" title="0">
                                implementedCount++</span>
                        case ComplianceStatusNonCompliant:<span class="cov0" title="0">
                                nonCompliantCount++</span>
                        case ComplianceStatusExempt:<span class="cov0" title="0">
                                exemptCount++</span>
                        }
                }
        }

        <span class="cov0" title="0">if requirementCount &gt; 0 </span><span class="cov0" title="0">{
                criteriaStatus.Score = totalScore / float64(requirementCount)
                criteriaStatus.RequirementCount = requirementCount
                criteriaStatus.ImplementedCount = implementedCount
                criteriaStatus.VerifiedCount = verifiedCount
                criteriaStatus.NonCompliantCount = nonCompliantCount
                criteriaStatus.ExemptCount = exemptCount

                // Determine criteria status based on score
                if criteriaStatus.Score &gt;= 90.0 </span><span class="cov0" title="0">{
                        criteriaStatus.Status = ComplianceStatusVerified
                }</span> else<span class="cov0" title="0"> if criteriaStatus.Score &gt;= 70.0 </span><span class="cov0" title="0">{
                        criteriaStatus.Status = ComplianceStatusImplemented
                }</span> else<span class="cov0" title="0"> if criteriaStatus.Score &gt;= 30.0 </span><span class="cov0" title="0">{
                        criteriaStatus.Status = ComplianceStatusInProgress
                }</span> else<span class="cov0" title="0"> {
                        criteriaStatus.Status = ComplianceStatusNotStarted
                }</span>
        }

        <span class="cov0" title="0">soc2Status.CriteriaStatus[criteriaID] = criteriaStatus</span>
}

// updateOverallStatus updates the overall SOC 2 compliance status
func (s *SOC2TrackingService) updateOverallStatus(soc2Status *SOC2ComplianceStatus) <span class="cov0" title="0">{
        var totalScore float64
        var criteriaCount int

        // Calculate overall score based on criteria scores
        for _, criteriaStatus := range soc2Status.CriteriaStatus </span><span class="cov0" title="0">{
                totalScore += criteriaStatus.Score
                criteriaCount++
        }</span>

        <span class="cov0" title="0">if criteriaCount &gt; 0 </span><span class="cov0" title="0">{
                soc2Status.ComplianceScore = totalScore / float64(criteriaCount)
        }</span>

        // Determine overall status based on score
        <span class="cov0" title="0">if soc2Status.ComplianceScore &gt;= 90.0 </span><span class="cov0" title="0">{
                soc2Status.OverallStatus = ComplianceStatusVerified
        }</span> else<span class="cov0" title="0"> if soc2Status.ComplianceScore &gt;= 70.0 </span><span class="cov0" title="0">{
                soc2Status.OverallStatus = ComplianceStatusImplemented
        }</span> else<span class="cov0" title="0"> if soc2Status.ComplianceScore &gt;= 30.0 </span><span class="cov0" title="0">{
                soc2Status.OverallStatus = ComplianceStatusInProgress
        }</span> else<span class="cov0" title="0"> {
                soc2Status.OverallStatus = ComplianceStatusNotStarted
        }</span>
}

// assessCriteria performs assessment for a specific criteria
func (s *SOC2TrackingService) assessCriteria(ctx context.Context, soc2Status *SOC2ComplianceStatus, criteriaID string) float64 <span class="cov0" title="0">{
        var totalScore float64
        var requirementCount int

        // Calculate criteria score based on requirements
        for _, reqStatus := range soc2Status.RequirementsStatus </span><span class="cov0" title="0">{
                if reqStatus.CriteriaID == criteriaID </span><span class="cov0" title="0">{
                        requirementCount++
                        totalScore += reqStatus.ComplianceScore
                }</span>
        }

        <span class="cov0" title="0">if requirementCount &gt; 0 </span><span class="cov0" title="0">{
                return totalScore / float64(requirementCount)
        }</span>

        <span class="cov0" title="0">return 0.0</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package compliance

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// ComplianceStatusSystem provides comprehensive compliance status tracking
type ComplianceStatusSystem struct {
        logger        *observability.Logger
        mu            sync.RWMutex
        statusData    map[string]*BusinessComplianceStatus // businessID -&gt; status
        statusHistory map[string][]StatusChange            // businessID -&gt; history
        statusAlerts  map[string][]StatusAlert             // businessID -&gt; alerts
        statusReports map[string]*StatusReport             // businessID -&gt; report
        statusMetrics map[string]*StatusMetrics            // businessID -&gt; metrics
}

// BusinessComplianceStatus represents the overall compliance status for a business
type BusinessComplianceStatus struct {
        ID                  string                       `json:"id"`
        BusinessID          string                       `json:"business_id"`
        OverallStatus       ComplianceStatus             `json:"overall_status"`
        OverallScore        float64                      `json:"overall_score"` // 0.0 to 100.0
        FrameworkStatuses   map[string]FrameworkStatus   `json:"framework_statuses"`
        RequirementStatuses map[string]RequirementStatus `json:"requirement_statuses"`
        ControlStatuses     map[string]ControlStatus     `json:"control_statuses"`
        LastAssessment      time.Time                    `json:"last_assessment"`
        NextAssessment      time.Time                    `json:"next_assessment"`
        AssessmentFrequency string                       `json:"assessment_frequency"`
        ComplianceOfficer   string                       `json:"compliance_officer"`
        RiskLevel           ComplianceRiskLevel          `json:"risk_level"`
        Trend               string                       `json:"trend"` // "improving", "stable", "declining"
        TrendStrength       float64                      `json:"trend_strength"`
        LastUpdated         time.Time                    `json:"last_updated"`
        Metadata            map[string]interface{}       `json:"metadata,omitempty"`
}

// FrameworkStatus represents the status of a specific framework
type FrameworkStatus struct {
        FrameworkID       string              `json:"framework_id"`
        FrameworkName     string              `json:"framework_name"`
        Status            ComplianceStatus    `json:"status"`
        Score             float64             `json:"score"`
        RequirementCount  int                 `json:"requirement_count"`
        ImplementedCount  int                 `json:"implemented_count"`
        VerifiedCount     int                 `json:"verified_count"`
        NonCompliantCount int                 `json:"non_compliant_count"`
        ExemptCount       int                 `json:"exempt_count"`
        LastAssessment    time.Time           `json:"last_assessment"`
        NextAssessment    time.Time           `json:"next_assessment"`
        RiskLevel         ComplianceRiskLevel `json:"risk_level"`
        Trend             string              `json:"trend"`
        TrendStrength     float64             `json:"trend_strength"`
        LastUpdated       time.Time           `json:"last_updated"`
}

// RequirementStatus represents the status of a specific requirement
type RequirementStatus struct {
        RequirementID        string               `json:"requirement_id"`
        FrameworkID          string               `json:"framework_id"`
        Title                string               `json:"title"`
        Status               ComplianceStatus     `json:"status"`
        ImplementationStatus ImplementationStatus `json:"implementation_status"`
        Score                float64              `json:"score"`
        RiskLevel            ComplianceRiskLevel  `json:"risk_level"`
        Priority             CompliancePriority   `json:"priority"`
        LastReviewed         time.Time            `json:"last_reviewed"`
        NextReview           time.Time            `json:"next_review"`
        Reviewer             string               `json:"reviewer"`
        EvidenceCount        int                  `json:"evidence_count"`
        ExceptionCount       int                  `json:"exception_count"`
        RemediationPlanCount int                  `json:"remediation_plan_count"`
        Trend                string               `json:"trend"`
        TrendStrength        float64              `json:"trend_strength"`
        LastUpdated          time.Time            `json:"last_updated"`
}

// ControlStatus represents the status of a specific control
type ControlStatus struct {
        ControlID            string               `json:"control_id"`
        RequirementID        string               `json:"requirement_id"`
        Title                string               `json:"title"`
        Status               ComplianceStatus     `json:"status"`
        ImplementationStatus ImplementationStatus `json:"implementation_status"`
        Effectiveness        ControlEffectiveness `json:"effectiveness"`
        Score                float64              `json:"score"`
        LastTested           *time.Time           `json:"last_tested,omitempty"`
        NextTestDate         *time.Time           `json:"next_test_date,omitempty"`
        TestResultCount      int                  `json:"test_result_count"`
        PassCount            int                  `json:"pass_count"`
        FailCount            int                  `json:"fail_count"`
        EvidenceCount        int                  `json:"evidence_count"`
        Trend                string               `json:"trend"`
        TrendStrength        float64              `json:"trend_strength"`
        LastUpdated          time.Time            `json:"last_updated"`
}

// StatusChange represents a change in compliance status
type StatusChange struct {
        ID           string           `json:"id"`
        BusinessID   string           `json:"business_id"`
        EntityType   string           `json:"entity_type"` // "overall", "framework", "requirement", "control"
        EntityID     string           `json:"entity_id"`
        OldStatus    ComplianceStatus `json:"old_status"`
        NewStatus    ComplianceStatus `json:"new_status"`
        OldScore     float64          `json:"old_score"`
        NewScore     float64          `json:"new_score"`
        ChangeReason string           `json:"change_reason"`
        ChangedBy    string           `json:"changed_by"`
        ChangedAt    time.Time        `json:"changed_at"`
        Impact       string           `json:"impact"` // "low", "medium", "high", "critical"
        Notes        string           `json:"notes"`
}

// StatusAlert represents a compliance status alert
type StatusAlert struct {
        ID             string      `json:"id"`
        BusinessID     string      `json:"business_id"`
        AlertType      string      `json:"alert_type"` // "status_change", "score_decline", "deadline_missed", "risk_increase"
        Severity       string      `json:"severity"`   // "low", "medium", "high", "critical"
        EntityType     string      `json:"entity_type"`
        EntityID       string      `json:"entity_id"`
        Title          string      `json:"title"`
        Description    string      `json:"description"`
        CurrentValue   interface{} `json:"current_value"`
        ThresholdValue interface{} `json:"threshold_value"`
        TriggeredAt    time.Time   `json:"triggered_at"`
        AcknowledgedAt *time.Time  `json:"acknowledged_at,omitempty"`
        AcknowledgedBy string      `json:"acknowledged_by,omitempty"`
        ResolvedAt     *time.Time  `json:"resolved_at,omitempty"`
        ResolvedBy     string      `json:"resolved_by,omitempty"`
        Status         string      `json:"status"` // "active", "acknowledged", "resolved"
        Notes          string      `json:"notes"`
}

// StatusReport represents a comprehensive compliance status report
type StatusReport struct {
        ID                  string                 `json:"id"`
        BusinessID          string                 `json:"business_id"`
        ReportType          string                 `json:"report_type"` // "summary", "detailed", "framework", "requirement"
        GeneratedAt         time.Time              `json:"generated_at"`
        GeneratedBy         string                 `json:"generated_by"`
        Period              string                 `json:"period"`
        OverallStatus       ComplianceStatus       `json:"overall_status"`
        OverallScore        float64                `json:"overall_score"`
        FrameworkCount      int                    `json:"framework_count"`
        RequirementCount    int                    `json:"requirement_count"`
        ControlCount        int                    `json:"control_count"`
        AlertCount          int                    `json:"alert_count"`
        ChangeCount         int                    `json:"change_count"`
        RiskLevel           ComplianceRiskLevel    `json:"risk_level"`
        Trend               string                 `json:"trend"`
        TrendStrength       float64                `json:"trend_strength"`
        FrameworkStatuses   []FrameworkStatus      `json:"framework_statuses"`
        RequirementStatuses []RequirementStatus    `json:"requirement_statuses"`
        ControlStatuses     []ControlStatus        `json:"control_statuses"`
        StatusChanges       []StatusChange         `json:"status_changes"`
        Alerts              []StatusAlert          `json:"alerts"`
        Recommendations     []StatusRecommendation `json:"recommendations"`
        Metadata            map[string]interface{} `json:"metadata,omitempty"`
}

// StatusMetrics represents compliance status metrics
type StatusMetrics struct {
        BusinessID         string             `json:"business_id"`
        OverallScore       float64            `json:"overall_score"`
        FrameworkScores    map[string]float64 `json:"framework_scores"`
        RequirementScores  map[string]float64 `json:"requirement_scores"`
        ControlScores      map[string]float64 `json:"control_scores"`
        StatusDistribution map[string]int     `json:"status_distribution"`
        RiskDistribution   map[string]int     `json:"risk_distribution"`
        TrendData          []TrendPoint       `json:"trend_data"`
        AlertMetrics       AlertMetrics       `json:"alert_metrics"`
        ChangeMetrics      ChangeMetrics      `json:"change_metrics"`
        LastCalculated     time.Time          `json:"last_calculated"`
}

// TrendPoint represents a point in compliance trend data
type TrendPoint struct {
        Date        time.Time           `json:"date"`
        Score       float64             `json:"score"`
        Status      ComplianceStatus    `json:"status"`
        RiskLevel   ComplianceRiskLevel `json:"risk_level"`
        ChangeCount int                 `json:"change_count"`
        AlertCount  int                 `json:"alert_count"`
}

// AlertMetrics represents alert-related metrics
type AlertMetrics struct {
        TotalAlerts           int           `json:"total_alerts"`
        ActiveAlerts          int           `json:"active_alerts"`
        ResolvedAlerts        int           `json:"resolved_alerts"`
        CriticalAlerts        int           `json:"critical_alerts"`
        HighAlerts            int           `json:"high_alerts"`
        MediumAlerts          int           `json:"medium_alerts"`
        LowAlerts             int           `json:"low_alerts"`
        AverageResolutionTime time.Duration `json:"average_resolution_time"`
}

// ChangeMetrics represents change-related metrics
type ChangeMetrics struct {
        TotalChanges           int     `json:"total_changes"`
        Improvements           int     `json:"improvements"`
        Declines               int     `json:"declines"`
        StatusChanges          int     `json:"status_changes"`
        ScoreChanges           int     `json:"score_changes"`
        AverageChangeMagnitude float64 `json:"average_change_magnitude"`
}

// StatusRecommendation represents a recommendation for compliance status improvement
type StatusRecommendation struct {
        ID                  string    `json:"id"`
        Type                string    `json:"type"`     // "improvement", "remediation", "monitoring", "assessment"
        Priority            string    `json:"priority"` // "low", "medium", "high", "critical"
        Title               string    `json:"title"`
        Description         string    `json:"description"`
        Action              string    `json:"action"`
        Impact              string    `json:"impact"`
        Effort              string    `json:"effort"`
        Timeline            string    `json:"timeline"`
        EntityType          string    `json:"entity_type"`
        EntityID            string    `json:"entity_id"`
        ExpectedImprovement float64   `json:"expected_improvement"`
        AssignedTo          string    `json:"assigned_to"`
        Status              string    `json:"status"` // "open", "in_progress", "completed", "rejected"
        CreatedAt           time.Time `json:"created_at"`
        UpdatedAt           time.Time `json:"updated_at"`
}

// NewComplianceStatusSystem creates a new compliance status tracking system
func NewComplianceStatusSystem(logger *observability.Logger) *ComplianceStatusSystem <span class="cov8" title="1">{
        return &amp;ComplianceStatusSystem{
                logger:        logger,
                statusData:    make(map[string]*BusinessComplianceStatus),
                statusHistory: make(map[string][]StatusChange),
                statusAlerts:  make(map[string][]StatusAlert),
                statusReports: make(map[string]*StatusReport),
                statusMetrics: make(map[string]*StatusMetrics),
        }
}</span>

// InitializeBusinessStatus initializes compliance status tracking for a business
func (s *ComplianceStatusSystem) InitializeBusinessStatus(ctx context.Context, businessID string) error <span class="cov8" title="1">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Initializing compliance status tracking for business",
                "request_id", requestID,
                "business_id", businessID,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        status := &amp;BusinessComplianceStatus{
                ID:                  fmt.Sprintf("status_%s", businessID),
                BusinessID:          businessID,
                OverallStatus:       ComplianceStatusNotStarted,
                OverallScore:        0.0,
                FrameworkStatuses:   make(map[string]FrameworkStatus),
                RequirementStatuses: make(map[string]RequirementStatus),
                ControlStatuses:     make(map[string]ControlStatus),
                LastAssessment:      time.Now(),
                NextAssessment:      time.Now().Add(30 * 24 * time.Hour), // 30 days
                AssessmentFrequency: "monthly",
                ComplianceOfficer:   "system",
                RiskLevel:           ComplianceRiskLevelLow,
                Trend:               "stable",
                TrendStrength:       0.0,
                LastUpdated:         time.Now(),
        }

        s.statusData[businessID] = status
        s.statusHistory[businessID] = make([]StatusChange, 0)
        s.statusAlerts[businessID] = make([]StatusAlert, 0)

        s.logger.Info("Compliance status tracking initialized successfully",
                "request_id", requestID,
                "business_id", businessID,
        )

        return nil
}</span>

// UpdateFrameworkStatus updates the status of a specific framework
func (s *ComplianceStatusSystem) UpdateFrameworkStatus(ctx context.Context, businessID, frameworkID string, status ComplianceStatus, score float64, riskLevel ComplianceRiskLevel, trend string, trendStrength float64) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Updating framework status",
                "request_id", requestID,
                "business_id", businessID,
                "framework_id", frameworkID,
                "status", status,
                "score", score,
                "risk_level", riskLevel,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        businessStatus, exists := s.statusData[businessID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("compliance status not found for business %s", businessID)
        }</span>

        // Get existing framework status
        <span class="cov0" title="0">frameworkStatus, exists := businessStatus.FrameworkStatuses[frameworkID]
        oldStatus := frameworkStatus.Status
        oldScore := frameworkStatus.Score

        // Update framework status
        frameworkStatus.FrameworkID = frameworkID
        frameworkStatus.Status = status
        frameworkStatus.Score = score
        frameworkStatus.RiskLevel = riskLevel
        frameworkStatus.Trend = trend
        frameworkStatus.TrendStrength = trendStrength
        frameworkStatus.LastAssessment = time.Now()
        frameworkStatus.NextAssessment = time.Now().Add(30 * 24 * time.Hour)
        frameworkStatus.LastUpdated = time.Now()

        businessStatus.FrameworkStatuses[frameworkID] = frameworkStatus

        // Update overall status
        s.updateOverallStatus(businessStatus)

        // Record status change
        s.recordStatusChange(ctx, businessID, "framework", frameworkID, oldStatus, status, oldScore, score, "Framework status updated")

        s.logger.Info("Framework status updated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "framework_id", frameworkID,
                "old_status", oldStatus,
                "new_status", status,
                "old_score", oldScore,
                "new_score", score,
        )

        return nil</span>
}

// UpdateRequirementStatus updates the status of a specific requirement
func (s *ComplianceStatusSystem) UpdateRequirementStatus(ctx context.Context, businessID, frameworkID, requirementID string, status ComplianceStatus, implementationStatus ImplementationStatus, score float64, riskLevel ComplianceRiskLevel, priority CompliancePriority, trend string, trendStrength float64) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Updating requirement status",
                "request_id", requestID,
                "business_id", businessID,
                "framework_id", frameworkID,
                "requirement_id", requirementID,
                "status", status,
                "score", score,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        businessStatus, exists := s.statusData[businessID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("compliance status not found for business %s", businessID)
        }</span>

        // Get existing requirement status
        <span class="cov0" title="0">requirementStatus, exists := businessStatus.RequirementStatuses[requirementID]
        oldStatus := requirementStatus.Status
        oldScore := requirementStatus.Score

        // Update requirement status
        requirementStatus.RequirementID = requirementID
        requirementStatus.FrameworkID = frameworkID
        requirementStatus.Status = status
        requirementStatus.ImplementationStatus = implementationStatus
        requirementStatus.Score = score
        requirementStatus.RiskLevel = riskLevel
        requirementStatus.Priority = priority
        requirementStatus.Trend = trend
        requirementStatus.TrendStrength = trendStrength
        requirementStatus.LastReviewed = time.Now()
        requirementStatus.NextReview = time.Now().Add(30 * 24 * time.Hour)
        requirementStatus.LastUpdated = time.Now()

        businessStatus.RequirementStatuses[requirementID] = requirementStatus

        // Update framework status
        s.updateFrameworkStatusFromRequirements(businessStatus, frameworkID)

        // Record status change
        s.recordStatusChange(ctx, businessID, "requirement", requirementID, oldStatus, status, oldScore, score, "Requirement status updated")

        s.logger.Info("Requirement status updated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "requirement_id", requirementID,
                "old_status", oldStatus,
                "new_status", status,
                "old_score", oldScore,
                "new_score", score,
        )

        return nil</span>
}

// UpdateControlStatus updates the status of a specific control
func (s *ComplianceStatusSystem) UpdateControlStatus(ctx context.Context, businessID, frameworkID, requirementID, controlID string, status ComplianceStatus, implementationStatus ImplementationStatus, effectiveness ControlEffectiveness, score float64, trend string, trendStrength float64) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Updating control status",
                "request_id", requestID,
                "business_id", businessID,
                "framework_id", frameworkID,
                "requirement_id", requirementID,
                "control_id", controlID,
                "status", status,
                "score", score,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        businessStatus, exists := s.statusData[businessID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("compliance status not found for business %s", businessID)
        }</span>

        // Get existing control status
        <span class="cov0" title="0">controlStatus, exists := businessStatus.ControlStatuses[controlID]
        oldStatus := controlStatus.Status
        oldScore := controlStatus.Score

        // Update control status
        controlStatus.ControlID = controlID
        controlStatus.RequirementID = requirementID
        controlStatus.Status = status
        controlStatus.ImplementationStatus = implementationStatus
        controlStatus.Effectiveness = effectiveness
        controlStatus.Score = score
        controlStatus.Trend = trend
        controlStatus.TrendStrength = trendStrength
        controlStatus.LastUpdated = time.Now()

        businessStatus.ControlStatuses[controlID] = controlStatus

        // Update requirement status from controls
        s.updateRequirementStatusFromControls(businessStatus, requirementID)

        // Record status change
        s.recordStatusChange(ctx, businessID, "control", controlID, oldStatus, status, oldScore, score, "Control status updated")

        s.logger.Info("Control status updated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "control_id", controlID,
                "old_status", oldStatus,
                "new_status", status,
                "old_score", oldScore,
                "new_score", score,
        )

        return nil</span>
}

// CreateStatusAlert creates a compliance status alert
func (s *ComplianceStatusSystem) CreateStatusAlert(ctx context.Context, businessID, alertType, severity, entityType, entityID, title, description string, currentValue, thresholdValue interface{}) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Creating compliance status alert",
                "request_id", requestID,
                "business_id", businessID,
                "alert_type", alertType,
                "severity", severity,
                "entity_type", entityType,
                "entity_id", entityID,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        alert := StatusAlert{
                ID:             fmt.Sprintf("alert_%s_%d", businessID, time.Now().UnixNano()),
                BusinessID:     businessID,
                AlertType:      alertType,
                Severity:       severity,
                EntityType:     entityType,
                EntityID:       entityID,
                Title:          title,
                Description:    description,
                CurrentValue:   currentValue,
                ThresholdValue: thresholdValue,
                TriggeredAt:    time.Now(),
                Status:         "active",
        }

        s.statusAlerts[businessID] = append(s.statusAlerts[businessID], alert)

        s.logger.Info("Compliance status alert created successfully",
                "request_id", requestID,
                "business_id", businessID,
                "alert_id", alert.ID,
                "alert_type", alertType,
                "severity", severity,
        )

        return nil
}</span>

// AcknowledgeAlert acknowledges a compliance status alert
func (s *ComplianceStatusSystem) AcknowledgeAlert(ctx context.Context, businessID, alertID, acknowledgedBy string) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Acknowledging compliance status alert",
                "request_id", requestID,
                "business_id", businessID,
                "alert_id", alertID,
                "acknowledged_by", acknowledgedBy,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        alerts, exists := s.statusAlerts[businessID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("no alerts found for business %s", businessID)
        }</span>

        <span class="cov0" title="0">for i, alert := range alerts </span><span class="cov0" title="0">{
                if alert.ID == alertID </span><span class="cov0" title="0">{
                        now := time.Now()
                        s.statusAlerts[businessID][i].AcknowledgedAt = &amp;now
                        s.statusAlerts[businessID][i].AcknowledgedBy = acknowledgedBy
                        s.statusAlerts[businessID][i].Status = "acknowledged"

                        s.logger.Info("Compliance status alert acknowledged successfully",
                                "request_id", requestID,
                                "business_id", businessID,
                                "alert_id", alertID,
                        )

                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("alert %s not found", alertID)</span>
}

// ResolveAlert resolves a compliance status alert
func (s *ComplianceStatusSystem) ResolveAlert(ctx context.Context, businessID, alertID, resolvedBy string) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Resolving compliance status alert",
                "request_id", requestID,
                "business_id", businessID,
                "alert_id", alertID,
                "resolved_by", resolvedBy,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        alerts, exists := s.statusAlerts[businessID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("no alerts found for business %s", businessID)
        }</span>

        <span class="cov0" title="0">for i, alert := range alerts </span><span class="cov0" title="0">{
                if alert.ID == alertID </span><span class="cov0" title="0">{
                        now := time.Now()
                        s.statusAlerts[businessID][i].ResolvedAt = &amp;now
                        s.statusAlerts[businessID][i].ResolvedBy = resolvedBy
                        s.statusAlerts[businessID][i].Status = "resolved"

                        s.logger.Info("Compliance status alert resolved successfully",
                                "request_id", requestID,
                                "business_id", businessID,
                                "alert_id", alertID,
                        )

                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("alert %s not found", alertID)</span>
}

// GetComplianceStatus gets the compliance status for a business
func (s *ComplianceStatusSystem) GetComplianceStatus(ctx context.Context, businessID string) (*BusinessComplianceStatus, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Getting compliance status",
                "request_id", requestID,
                "business_id", businessID,
        )

        s.mu.RLock()
        defer s.mu.RUnlock()

        status, exists := s.statusData[businessID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("compliance status not found for business %s", businessID)
        }</span>

        <span class="cov0" title="0">return status, nil</span>
}

// GetStatusHistory gets the status change history for a business
func (s *ComplianceStatusSystem) GetStatusHistory(ctx context.Context, businessID string, startDate, endDate time.Time) ([]StatusChange, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Getting status history",
                "request_id", requestID,
                "business_id", businessID,
                "start_date", startDate,
                "end_date", endDate,
        )

        s.mu.RLock()
        defer s.mu.RUnlock()

        history, exists := s.statusHistory[businessID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("status history not found for business %s", businessID)
        }</span>

        <span class="cov0" title="0">var filteredHistory []StatusChange
        for _, change := range history </span><span class="cov0" title="0">{
                if change.ChangedAt.After(startDate) &amp;&amp; change.ChangedAt.Before(endDate) </span><span class="cov0" title="0">{
                        filteredHistory = append(filteredHistory, change)
                }</span>
        }

        <span class="cov0" title="0">return filteredHistory, nil</span>
}

// GetStatusAlerts gets the status alerts for a business
func (s *ComplianceStatusSystem) GetStatusAlerts(ctx context.Context, businessID string, status string) ([]StatusAlert, error) <span class="cov8" title="1">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Getting status alerts",
                "request_id", requestID,
                "business_id", businessID,
                "status", status,
        )

        s.mu.RLock()
        defer s.mu.RUnlock()

        alerts, exists := s.statusAlerts[businessID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("status alerts not found for business %s", businessID)
        }</span>

        <span class="cov8" title="1">if status == "" </span><span class="cov8" title="1">{
                return alerts, nil
        }</span>

        <span class="cov0" title="0">var filteredAlerts []StatusAlert
        for _, alert := range alerts </span><span class="cov0" title="0">{
                if alert.Status == status </span><span class="cov0" title="0">{
                        filteredAlerts = append(filteredAlerts, alert)
                }</span>
        }

        <span class="cov0" title="0">return filteredAlerts, nil</span>
}

// GenerateStatusReport generates a comprehensive compliance status report
func (s *ComplianceStatusSystem) GenerateStatusReport(ctx context.Context, businessID string, reportType string) (*StatusReport, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Generating compliance status report",
                "request_id", requestID,
                "business_id", businessID,
                "report_type", reportType,
        )

        s.mu.RLock()
        defer s.mu.RUnlock()

        status, exists := s.statusData[businessID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("compliance status not found for business %s", businessID)
        }</span>

        <span class="cov0" title="0">alerts, _ := s.GetStatusAlerts(ctx, businessID, "")
        history, _ := s.GetStatusHistory(ctx, businessID, time.Now().Add(-30*24*time.Hour), time.Now())

        report := &amp;StatusReport{
                ID:               fmt.Sprintf("report_%s_%d", businessID, time.Now().Unix()),
                BusinessID:       businessID,
                ReportType:       reportType,
                GeneratedAt:      time.Now(),
                GeneratedBy:      "system",
                Period:           "30_days",
                OverallStatus:    status.OverallStatus,
                OverallScore:     status.OverallScore,
                FrameworkCount:   len(status.FrameworkStatuses),
                RequirementCount: len(status.RequirementStatuses),
                ControlCount:     len(status.ControlStatuses),
                AlertCount:       len(alerts),
                ChangeCount:      len(history),
                RiskLevel:        status.RiskLevel,
                Trend:            status.Trend,
                TrendStrength:    status.TrendStrength,
                StatusChanges:    history,
                Alerts:           alerts,
                Recommendations:  s.generateStatusRecommendations(status, alerts, history),
        }

        // Add framework statuses
        for _, frameworkStatus := range status.FrameworkStatuses </span><span class="cov0" title="0">{
                report.FrameworkStatuses = append(report.FrameworkStatuses, frameworkStatus)
        }</span>

        // Add requirement statuses
        <span class="cov0" title="0">for _, requirementStatus := range status.RequirementStatuses </span><span class="cov0" title="0">{
                report.RequirementStatuses = append(report.RequirementStatuses, requirementStatus)
        }</span>

        // Add control statuses
        <span class="cov0" title="0">for _, controlStatus := range status.ControlStatuses </span><span class="cov0" title="0">{
                report.ControlStatuses = append(report.ControlStatuses, controlStatus)
        }</span>

        <span class="cov0" title="0">s.statusReports[businessID] = report

        s.logger.Info("Compliance status report generated successfully",
                "request_id", requestID,
                "business_id", businessID,
                "report_type", reportType,
                "framework_count", report.FrameworkCount,
                "requirement_count", report.RequirementCount,
                "control_count", report.ControlCount,
        )

        return report, nil</span>
}

// Helper methods
func (s *ComplianceStatusSystem) updateOverallStatus(status *BusinessComplianceStatus) <span class="cov0" title="0">{
        if len(status.FrameworkStatuses) == 0 </span><span class="cov0" title="0">{
                status.OverallScore = 0.0
                status.OverallStatus = ComplianceStatusNotStarted
                return
        }</span>

        <span class="cov0" title="0">totalScore := 0.0
        validFrameworks := 0

        for _, frameworkStatus := range status.FrameworkStatuses </span><span class="cov0" title="0">{
                totalScore += frameworkStatus.Score
                validFrameworks++
        }</span>

        <span class="cov0" title="0">if validFrameworks &gt; 0 </span><span class="cov0" title="0">{
                status.OverallScore = totalScore / float64(validFrameworks)
        }</span> else<span class="cov0" title="0"> {
                status.OverallScore = 0.0
        }</span>

        // Update overall status based on score
        <span class="cov0" title="0">if status.OverallScore &gt;= 90.0 </span><span class="cov0" title="0">{
                status.OverallStatus = ComplianceStatusVerified
        }</span> else<span class="cov0" title="0"> if status.OverallScore &gt;= 70.0 </span><span class="cov0" title="0">{
                status.OverallStatus = ComplianceStatusImplemented
        }</span> else<span class="cov0" title="0"> if status.OverallScore &gt;= 30.0 </span><span class="cov0" title="0">{
                status.OverallStatus = ComplianceStatusInProgress
        }</span> else<span class="cov0" title="0"> {
                status.OverallStatus = ComplianceStatusNotStarted
        }</span>

        // Update risk level based on score
        <span class="cov0" title="0">if status.OverallScore &gt;= 80.0 </span><span class="cov0" title="0">{
                status.RiskLevel = ComplianceRiskLevelLow
        }</span> else<span class="cov0" title="0"> if status.OverallScore &gt;= 60.0 </span><span class="cov0" title="0">{
                status.RiskLevel = ComplianceRiskLevelMedium
        }</span> else<span class="cov0" title="0"> if status.OverallScore &gt;= 40.0 </span><span class="cov0" title="0">{
                status.RiskLevel = ComplianceRiskLevelHigh
        }</span> else<span class="cov0" title="0"> {
                status.RiskLevel = ComplianceRiskLevelCritical
        }</span>

        <span class="cov0" title="0">status.LastUpdated = time.Now()</span>
}

func (s *ComplianceStatusSystem) updateFrameworkStatusFromRequirements(status *BusinessComplianceStatus, frameworkID string) <span class="cov0" title="0">{
        var frameworkRequirements []RequirementStatus
        for _, reqStatus := range status.RequirementStatuses </span><span class="cov0" title="0">{
                if reqStatus.FrameworkID == frameworkID </span><span class="cov0" title="0">{
                        frameworkRequirements = append(frameworkRequirements, reqStatus)
                }</span>
        }

        <span class="cov0" title="0">if len(frameworkRequirements) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">frameworkStatus := status.FrameworkStatuses[frameworkID]
        totalScore := 0.0
        implementedCount := 0
        verifiedCount := 0
        nonCompliantCount := 0
        exemptCount := 0

        for _, reqStatus := range frameworkRequirements </span><span class="cov0" title="0">{
                totalScore += reqStatus.Score
                switch reqStatus.Status </span>{
                case ComplianceStatusImplemented:<span class="cov0" title="0">
                        implementedCount++</span>
                case ComplianceStatusVerified:<span class="cov0" title="0">
                        verifiedCount++</span>
                case ComplianceStatusNonCompliant:<span class="cov0" title="0">
                        nonCompliantCount++</span>
                case ComplianceStatusExempt:<span class="cov0" title="0">
                        exemptCount++</span>
                }
        }

        <span class="cov0" title="0">frameworkStatus.Score = totalScore / float64(len(frameworkRequirements))
        frameworkStatus.RequirementCount = len(frameworkRequirements)
        frameworkStatus.ImplementedCount = implementedCount
        frameworkStatus.VerifiedCount = verifiedCount
        frameworkStatus.NonCompliantCount = nonCompliantCount
        frameworkStatus.ExemptCount = exemptCount

        // Update framework status based on score
        if frameworkStatus.Score &gt;= 90.0 </span><span class="cov0" title="0">{
                frameworkStatus.Status = ComplianceStatusVerified
        }</span> else<span class="cov0" title="0"> if frameworkStatus.Score &gt;= 70.0 </span><span class="cov0" title="0">{
                frameworkStatus.Status = ComplianceStatusImplemented
        }</span> else<span class="cov0" title="0"> if frameworkStatus.Score &gt;= 30.0 </span><span class="cov0" title="0">{
                frameworkStatus.Status = ComplianceStatusInProgress
        }</span> else<span class="cov0" title="0"> {
                frameworkStatus.Status = ComplianceStatusNotStarted
        }</span>

        <span class="cov0" title="0">status.FrameworkStatuses[frameworkID] = frameworkStatus</span>
}

func (s *ComplianceStatusSystem) updateRequirementStatusFromControls(status *BusinessComplianceStatus, requirementID string) <span class="cov0" title="0">{
        var requirementControls []ControlStatus
        for _, controlStatus := range status.ControlStatuses </span><span class="cov0" title="0">{
                if controlStatus.RequirementID == requirementID </span><span class="cov0" title="0">{
                        requirementControls = append(requirementControls, controlStatus)
                }</span>
        }

        <span class="cov0" title="0">if len(requirementControls) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">requirementStatus := status.RequirementStatuses[requirementID]
        totalScore := 0.0
        passCount := 0
        failCount := 0

        for _, controlStatus := range requirementControls </span><span class="cov0" title="0">{
                totalScore += controlStatus.Score
                if controlStatus.Effectiveness == ControlEffectivenessEffective || controlStatus.Effectiveness == ControlEffectivenessHighlyEffective </span><span class="cov0" title="0">{
                        passCount++
                }</span> else<span class="cov0" title="0"> {
                        failCount++
                }</span>
        }

        <span class="cov0" title="0">requirementStatus.Score = totalScore / float64(len(requirementControls))

        // Update requirement status based on score
        if requirementStatus.Score &gt;= 90.0 </span><span class="cov0" title="0">{
                requirementStatus.Status = ComplianceStatusVerified
        }</span> else<span class="cov0" title="0"> if requirementStatus.Score &gt;= 70.0 </span><span class="cov0" title="0">{
                requirementStatus.Status = ComplianceStatusImplemented
        }</span> else<span class="cov0" title="0"> if requirementStatus.Score &gt;= 30.0 </span><span class="cov0" title="0">{
                requirementStatus.Status = ComplianceStatusInProgress
        }</span> else<span class="cov0" title="0"> {
                requirementStatus.Status = ComplianceStatusNotStarted
        }</span>

        <span class="cov0" title="0">status.RequirementStatuses[requirementID] = requirementStatus</span>
}

func (s *ComplianceStatusSystem) recordStatusChange(ctx context.Context, businessID, entityType, entityID string, oldStatus, newStatus ComplianceStatus, oldScore, newScore float64, reason string) <span class="cov0" title="0">{
        change := StatusChange{
                ID:           fmt.Sprintf("change_%s_%d", businessID, time.Now().UnixNano()),
                BusinessID:   businessID,
                EntityType:   entityType,
                EntityID:     entityID,
                OldStatus:    oldStatus,
                NewStatus:    newStatus,
                OldScore:     oldScore,
                NewScore:     newScore,
                ChangeReason: reason,
                ChangedBy:    "system",
                ChangedAt:    time.Now(),
                Impact:       s.calculateChangeImpact(oldScore, newScore),
        }

        s.statusHistory[businessID] = append(s.statusHistory[businessID], change)
}</span>

func (s *ComplianceStatusSystem) calculateChangeImpact(oldScore, newScore float64) string <span class="cov0" title="0">{
        change := newScore - oldScore
        if change &gt;= 10.0 </span><span class="cov0" title="0">{
                return "high"
        }</span> else<span class="cov0" title="0"> if change &gt;= 5.0 </span><span class="cov0" title="0">{
                return "medium"
        }</span> else<span class="cov0" title="0"> if change &gt;= 1.0 </span><span class="cov0" title="0">{
                return "low"
        }</span>
        <span class="cov0" title="0">return "minimal"</span>
}

func (s *ComplianceStatusSystem) generateStatusRecommendations(status *BusinessComplianceStatus, alerts []StatusAlert, history []StatusChange) []StatusRecommendation <span class="cov0" title="0">{
        var recommendations []StatusRecommendation

        // Low overall score recommendation
        if status.OverallScore &lt; 70.0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, StatusRecommendation{
                        ID:                  fmt.Sprintf("rec_%s_low_score", status.BusinessID),
                        Type:                "improvement",
                        Priority:            "high",
                        Title:               "Low Overall Compliance Score",
                        Description:         fmt.Sprintf("Overall compliance score is %.1f%%, below the target of 70%%", status.OverallScore),
                        Action:              "Focus on implementing high-priority requirements and controls",
                        Impact:              "High - Improves overall compliance posture",
                        Effort:              "High - Requires significant implementation effort",
                        Timeline:            "3-6 months",
                        EntityType:          "overall",
                        EntityID:            status.BusinessID,
                        ExpectedImprovement: 20.0,
                        Status:              "open",
                        CreatedAt:           time.Now(),
                        UpdatedAt:           time.Now(),
                })
        }</span>

        // High alert count recommendation
        <span class="cov0" title="0">if len(alerts) &gt; 5 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, StatusRecommendation{
                        ID:                  fmt.Sprintf("rec_%s_high_alerts", status.BusinessID),
                        Type:                "monitoring",
                        Priority:            "medium",
                        Title:               "High Number of Active Alerts",
                        Description:         fmt.Sprintf("There are %d active compliance alerts that require attention", len(alerts)),
                        Action:              "Review and address all active alerts promptly",
                        Impact:              "Medium - Reduces compliance risk",
                        Effort:              "Medium - Requires alert review and remediation",
                        Timeline:            "1-2 weeks",
                        EntityType:          "overall",
                        EntityID:            status.BusinessID,
                        ExpectedImprovement: 5.0,
                        Status:              "open",
                        CreatedAt:           time.Now(),
                        UpdatedAt:           time.Now(),
                })
        }</span>

        // Declining trend recommendation
        <span class="cov0" title="0">if status.Trend == "declining" &amp;&amp; status.TrendStrength &gt; 0.5 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, StatusRecommendation{
                        ID:                  fmt.Sprintf("rec_%s_declining_trend", status.BusinessID),
                        Type:                "remediation",
                        Priority:            "high",
                        Title:               "Declining Compliance Trend",
                        Description:         "Compliance score is declining, indicating potential issues",
                        Action:              "Investigate root causes and implement corrective actions",
                        Impact:              "High - Prevents further compliance deterioration",
                        Effort:              "High - Requires investigation and remediation",
                        Timeline:            "2-4 weeks",
                        EntityType:          "overall",
                        EntityID:            status.BusinessID,
                        ExpectedImprovement: 15.0,
                        Status:              "open",
                        CreatedAt:           time.Now(),
                        UpdatedAt:           time.Now(),
                })
        }</span>

        <span class="cov0" title="0">return recommendations</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package compliance

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/pcraw4d/business-verification/internal/observability"
)

// TrackingSystem provides comprehensive compliance tracking functionality
type TrackingSystem struct {
        logger       *observability.Logger
        mu           sync.RWMutex
        trackingData map[string]*ComplianceTracking    // businessID -&gt; tracking
        requirements map[string]*ComplianceRequirement // requirementID -&gt; requirement
        frameworks   map[string]*RegulatoryFramework   // frameworkID -&gt; framework
        auditTrail   []ComplianceAuditTrail
}

// NewTrackingSystem creates a new compliance tracking system
func NewTrackingSystem(logger *observability.Logger) *TrackingSystem <span class="cov0" title="0">{
        return &amp;TrackingSystem{
                logger:       logger,
                trackingData: make(map[string]*ComplianceTracking),
                requirements: make(map[string]*ComplianceRequirement),
                frameworks:   make(map[string]*RegulatoryFramework),
                auditTrail:   make([]ComplianceAuditTrail, 0),
        }
}</span>

// InitializeBusinessTracking initializes compliance tracking for a business
func (s *TrackingSystem) InitializeBusinessTracking(ctx context.Context, businessID string, frameworks []string) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Initializing compliance tracking for business",
                "request_id", requestID,
                "business_id", businessID,
                "frameworks", frameworks,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        // Initialize tracking for each framework
        for _, framework := range frameworks </span><span class="cov0" title="0">{
                tracking := &amp;ComplianceTracking{
                        ID:                  fmt.Sprintf("tracking_%s_%s", businessID, framework),
                        BusinessID:          businessID,
                        Framework:           framework,
                        OverallStatus:       ComplianceStatusNotStarted,
                        ComplianceScore:     0.0,
                        Requirements:        make([]RequirementTracking, 0),
                        LastAssessment:      time.Now(),
                        NextAssessment:      time.Now().Add(30 * 24 * time.Hour), // 30 days
                        AssessmentFrequency: "monthly",
                        ComplianceOfficer:   "system",
                }

                // Load framework requirements
                frameworkData, exists := s.frameworks[framework]
                if exists </span><span class="cov0" title="0">{
                        // Initialize requirement tracking for each requirement
                        for _, requirement := range frameworkData.Requirements </span><span class="cov0" title="0">{
                                reqTracking := RequirementTracking{
                                        RequirementID:        requirement.RequirementID,
                                        Status:               ComplianceStatusNotStarted,
                                        ImplementationStatus: ImplementationStatusNotImplemented,
                                        ComplianceScore:      0.0,
                                        LastReviewed:         time.Now(),
                                        NextReview:           time.Now().Add(30 * 24 * time.Hour),
                                        Reviewer:             "system",
                                        Evidence:             make([]TrackingEvidence, 0),
                                        Controls:             make([]ControlTracking, 0),
                                        Exceptions:           make([]ComplianceException, 0),
                                }

                                // Initialize control tracking for each control
                                for _, control := range requirement.Controls </span><span class="cov0" title="0">{
                                        controlTracking := ControlTracking{
                                                ControlID:            control.ID,
                                                Status:               ComplianceStatusNotStarted,
                                                ImplementationStatus: ImplementationStatusNotImplemented,
                                                Effectiveness:        ControlEffectivenessIneffective,
                                                TestResults:          make([]ControlTestResult, 0),
                                                Evidence:             make([]ControlEvidence, 0),
                                        }
                                        reqTracking.Controls = append(reqTracking.Controls, controlTracking)
                                }</span>

                                <span class="cov0" title="0">tracking.Requirements = append(tracking.Requirements, reqTracking)</span>
                        }
                }

                <span class="cov0" title="0">s.trackingData[fmt.Sprintf("%s_%s", businessID, framework)] = tracking</span>
        }

        <span class="cov0" title="0">s.logAuditTrail(ctx, businessID, "", nil, AuditActionCreate, "Initialized compliance tracking", "", "")

        s.logger.Info("Compliance tracking initialized successfully",
                "request_id", requestID,
                "business_id", businessID,
                "frameworks", frameworks,
        )

        return nil</span>
}

// UpdateRequirementStatus updates the status of a specific requirement
func (s *TrackingSystem) UpdateRequirementStatus(ctx context.Context, businessID, framework, requirementID string, status ComplianceStatus, implementationStatus ImplementationStatus, score float64, notes string) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Updating requirement status",
                "request_id", requestID,
                "business_id", businessID,
                "framework", framework,
                "requirement_id", requirementID,
                "status", status,
                "implementation_status", implementationStatus,
                "score", score,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        trackingKey := fmt.Sprintf("%s_%s", businessID, framework)
        tracking, exists := s.trackingData[trackingKey]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("compliance tracking not found for business %s and framework %s", businessID, framework)
        }</span>

        // Find and update the requirement
        <span class="cov0" title="0">for i, req := range tracking.Requirements </span><span class="cov0" title="0">{
                if req.RequirementID == requirementID </span><span class="cov0" title="0">{
                        oldStatus := req.Status
                        oldScore := req.ComplianceScore

                        tracking.Requirements[i].Status = status
                        tracking.Requirements[i].ImplementationStatus = implementationStatus
                        tracking.Requirements[i].ComplianceScore = score
                        tracking.Requirements[i].LastReviewed = time.Now()
                        tracking.Requirements[i].NextReview = time.Now().Add(30 * 24 * time.Hour)
                        tracking.Requirements[i].Notes = notes

                        // Update overall compliance score
                        s.updateOverallComplianceScore(tracking)

                        s.logAuditTrail(ctx, businessID, framework, &amp;requirementID, AuditActionUpdate,
                                fmt.Sprintf("Updated requirement status from %s to %s", oldStatus, status),
                                fmt.Sprintf("%.2f", oldScore), fmt.Sprintf("%.2f", score))

                        s.logger.Info("Requirement status updated successfully",
                                "request_id", requestID,
                                "business_id", businessID,
                                "requirement_id", requirementID,
                                "old_status", oldStatus,
                                "new_status", status,
                                "old_score", oldScore,
                                "new_score", score,
                        )

                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("requirement %s not found in tracking", requirementID)</span>
}

// UpdateControlStatus updates the status of a specific control
func (s *TrackingSystem) UpdateControlStatus(ctx context.Context, businessID, framework, requirementID, controlID string, status ComplianceStatus, implementationStatus ImplementationStatus, effectiveness ControlEffectiveness, notes string) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Updating control status",
                "request_id", requestID,
                "business_id", businessID,
                "framework", framework,
                "requirement_id", requirementID,
                "control_id", controlID,
                "status", status,
                "effectiveness", effectiveness,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        trackingKey := fmt.Sprintf("%s_%s", businessID, framework)
        tracking, exists := s.trackingData[trackingKey]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("compliance tracking not found for business %s and framework %s", businessID, framework)
        }</span>

        // Find and update the control
        <span class="cov0" title="0">for i, req := range tracking.Requirements </span><span class="cov0" title="0">{
                if req.RequirementID == requirementID </span><span class="cov0" title="0">{
                        for j, control := range req.Controls </span><span class="cov0" title="0">{
                                if control.ControlID == controlID </span><span class="cov0" title="0">{
                                        oldStatus := control.Status
                                        oldEffectiveness := control.Effectiveness

                                        tracking.Requirements[i].Controls[j].Status = status
                                        tracking.Requirements[i].Controls[j].ImplementationStatus = implementationStatus
                                        tracking.Requirements[i].Controls[j].Effectiveness = effectiveness
                                        tracking.Requirements[i].Controls[j].Notes = notes

                                        // Update requirement score based on control effectiveness
                                        s.updateRequirementScore(tracking, i)

                                        s.logAuditTrail(ctx, businessID, framework, &amp;requirementID, AuditActionUpdate,
                                                fmt.Sprintf("Updated control status from %s to %s", oldStatus, status),
                                                string(oldEffectiveness), string(effectiveness))

                                        s.logger.Info("Control status updated successfully",
                                                "request_id", requestID,
                                                "business_id", businessID,
                                                "control_id", controlID,
                                                "old_status", oldStatus,
                                                "new_status", status,
                                                "old_effectiveness", oldEffectiveness,
                                                "new_effectiveness", effectiveness,
                                        )

                                        return nil
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("control %s not found in requirement %s", controlID, requirementID)</span>
}

// AddControlTestResult adds a test result for a control
func (s *TrackingSystem) AddControlTestResult(ctx context.Context, businessID, framework, requirementID, controlID string, testResult ControlTestResult) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Adding control test result",
                "request_id", requestID,
                "business_id", businessID,
                "framework", framework,
                "requirement_id", requirementID,
                "control_id", controlID,
                "test_type", testResult.TestType,
                "result", testResult.Result,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        trackingKey := fmt.Sprintf("%s_%s", businessID, framework)
        tracking, exists := s.trackingData[trackingKey]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("compliance tracking not found for business %s and framework %s", businessID, framework)
        }</span>

        // Find and add test result to the control
        <span class="cov0" title="0">for i, req := range tracking.Requirements </span><span class="cov0" title="0">{
                if req.RequirementID == requirementID </span><span class="cov0" title="0">{
                        for j, control := range req.Controls </span><span class="cov0" title="0">{
                                if control.ControlID == controlID </span><span class="cov0" title="0">{
                                        tracking.Requirements[i].Controls[j].TestResults = append(tracking.Requirements[i].Controls[j].TestResults, testResult)
                                        tracking.Requirements[i].Controls[j].LastTested = &amp;testResult.TestDate
                                        tracking.Requirements[i].Controls[j].NextTestDate = s.calculateNextTestDate(testResult.TestDate, "monthly")

                                        // Update control effectiveness based on test results
                                        s.updateControlEffectiveness(tracking, i, j)

                                        s.logAuditTrail(ctx, businessID, framework, &amp;requirementID, AuditActionUpdate,
                                                fmt.Sprintf("Added test result for control: %s - %s", testResult.TestType, testResult.Result),
                                                "", "")

                                        s.logger.Info("Control test result added successfully",
                                                "request_id", requestID,
                                                "business_id", businessID,
                                                "control_id", controlID,
                                                "test_type", testResult.TestType,
                                                "result", testResult.Result,
                                        )

                                        return nil
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("control %s not found in requirement %s", controlID, requirementID)</span>
}

// AddEvidence adds evidence for a requirement or control
func (s *TrackingSystem) AddEvidence(ctx context.Context, businessID, framework, requirementID, controlID string, evidence TrackingEvidence) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Adding evidence",
                "request_id", requestID,
                "business_id", businessID,
                "framework", framework,
                "requirement_id", requirementID,
                "control_id", controlID,
                "evidence_type", evidence.Type,
                "title", evidence.Title,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        trackingKey := fmt.Sprintf("%s_%s", businessID, framework)
        tracking, exists := s.trackingData[trackingKey]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("compliance tracking not found for business %s and framework %s", businessID, framework)
        }</span>

        // Find and add evidence
        <span class="cov0" title="0">for i, req := range tracking.Requirements </span><span class="cov0" title="0">{
                if req.RequirementID == requirementID </span><span class="cov0" title="0">{
                        if controlID == "" </span><span class="cov0" title="0">{
                                // Add evidence to requirement
                                tracking.Requirements[i].Evidence = append(tracking.Requirements[i].Evidence, evidence)
                        }</span> else<span class="cov0" title="0"> {
                                // Add evidence to specific control
                                for j, control := range req.Controls </span><span class="cov0" title="0">{
                                        if control.ControlID == controlID </span><span class="cov0" title="0">{
                                                controlEvidence := ControlEvidence{
                                                        ID:          evidence.ID,
                                                        ControlID:   controlID,
                                                        Type:        evidence.Type,
                                                        Title:       evidence.Title,
                                                        Description: evidence.Description,
                                                        URL:         evidence.URL,
                                                        UploadedAt:  evidence.UploadedAt,
                                                        UploadedBy:  evidence.UploadedBy,
                                                        ExpiresAt:   evidence.ExpiresAt,
                                                }
                                                tracking.Requirements[i].Controls[j].Evidence = append(tracking.Requirements[i].Controls[j].Evidence, controlEvidence)
                                                break</span>
                                        }
                                }
                        }

                        <span class="cov0" title="0">s.logAuditTrail(ctx, businessID, framework, &amp;requirementID, AuditActionCreate,
                                fmt.Sprintf("Added evidence: %s", evidence.Title),
                                "", "")

                        s.logger.Info("Evidence added successfully",
                                "request_id", requestID,
                                "business_id", businessID,
                                "requirement_id", requirementID,
                                "control_id", controlID,
                                "evidence_type", evidence.Type,
                                "title", evidence.Title,
                        )

                        return nil</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("requirement %s not found in tracking", requirementID)</span>
}

// CreateException creates a compliance exception
func (s *TrackingSystem) CreateException(ctx context.Context, businessID, framework, requirementID string, exception ComplianceException) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Creating compliance exception",
                "request_id", requestID,
                "business_id", businessID,
                "framework", framework,
                "requirement_id", requirementID,
                "exception_type", exception.Type,
                "reason", exception.Reason,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        trackingKey := fmt.Sprintf("%s_%s", businessID, framework)
        tracking, exists := s.trackingData[trackingKey]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("compliance tracking not found for business %s and framework %s", businessID, framework)
        }</span>

        // Find and add exception to the requirement
        <span class="cov0" title="0">for i, req := range tracking.Requirements </span><span class="cov0" title="0">{
                if req.RequirementID == requirementID </span><span class="cov0" title="0">{
                        tracking.Requirements[i].Exceptions = append(tracking.Requirements[i].Exceptions, exception)

                        s.logAuditTrail(ctx, businessID, framework, &amp;requirementID, AuditActionException,
                                fmt.Sprintf("Created exception: %s", exception.Reason),
                                "", "")

                        s.logger.Info("Compliance exception created successfully",
                                "request_id", requestID,
                                "business_id", businessID,
                                "requirement_id", requirementID,
                                "exception_type", exception.Type,
                                "reason", exception.Reason,
                        )

                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("requirement %s not found in tracking", requirementID)</span>
}

// CreateRemediationPlan creates a remediation plan for a requirement
func (s *TrackingSystem) CreateRemediationPlan(ctx context.Context, businessID, framework, requirementID string, plan RemediationPlan) error <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Creating remediation plan",
                "request_id", requestID,
                "business_id", businessID,
                "framework", framework,
                "requirement_id", requirementID,
                "plan_title", plan.Title,
                "priority", plan.Priority,
        )

        s.mu.Lock()
        defer s.mu.Unlock()

        trackingKey := fmt.Sprintf("%s_%s", businessID, framework)
        tracking, exists := s.trackingData[trackingKey]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("compliance tracking not found for business %s and framework %s", businessID, framework)
        }</span>

        // Find and add remediation plan to the requirement
        <span class="cov0" title="0">for i, req := range tracking.Requirements </span><span class="cov0" title="0">{
                if req.RequirementID == requirementID </span><span class="cov0" title="0">{
                        tracking.Requirements[i].RemediationPlan = &amp;plan

                        s.logAuditTrail(ctx, businessID, framework, &amp;requirementID, AuditActionRemediation,
                                fmt.Sprintf("Created remediation plan: %s", plan.Title),
                                "", "")

                        s.logger.Info("Remediation plan created successfully",
                                "request_id", requestID,
                                "business_id", businessID,
                                "requirement_id", requirementID,
                                "plan_title", plan.Title,
                                "priority", plan.Priority,
                        )

                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("requirement %s not found in tracking", requirementID)</span>
}

// GetComplianceTracking gets compliance tracking for a business and framework
func (s *TrackingSystem) GetComplianceTracking(ctx context.Context, businessID, framework string) (*ComplianceTracking, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Getting compliance tracking",
                "request_id", requestID,
                "business_id", businessID,
                "framework", framework,
        )

        s.mu.RLock()
        defer s.mu.RUnlock()

        trackingKey := fmt.Sprintf("%s_%s", businessID, framework)
        tracking, exists := s.trackingData[trackingKey]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("compliance tracking not found for business %s and framework %s", businessID, framework)
        }</span>

        <span class="cov0" title="0">return tracking, nil</span>
}

// GetBusinessComplianceSummary gets a summary of compliance for a business across all frameworks
func (s *TrackingSystem) GetBusinessComplianceSummary(ctx context.Context, businessID string) (map[string]*ComplianceTracking, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Getting business compliance summary",
                "request_id", requestID,
                "business_id", businessID,
        )

        s.mu.RLock()
        defer s.mu.RUnlock()

        summary := make(map[string]*ComplianceTracking)
        for _, tracking := range s.trackingData </span><span class="cov0" title="0">{
                if tracking.BusinessID == businessID </span><span class="cov0" title="0">{
                        framework := tracking.Framework
                        summary[framework] = tracking
                }</span>
        }

        <span class="cov0" title="0">return summary, nil</span>
}

// GetComplianceAuditTrail gets the audit trail for compliance activities
func (s *TrackingSystem) GetComplianceAuditTrail(ctx context.Context, businessID string, startDate, endDate time.Time) ([]ComplianceAuditTrail, error) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        s.logger.Info("Getting compliance audit trail",
                "request_id", requestID,
                "business_id", businessID,
                "start_date", startDate,
                "end_date", endDate,
        )

        s.mu.RLock()
        defer s.mu.RUnlock()

        var filteredTrail []ComplianceAuditTrail
        for _, entry := range s.auditTrail </span><span class="cov0" title="0">{
                if entry.BusinessID == businessID &amp;&amp;
                        entry.Timestamp.After(startDate) &amp;&amp;
                        entry.Timestamp.Before(endDate) </span><span class="cov0" title="0">{
                        filteredTrail = append(filteredTrail, entry)
                }</span>
        }

        <span class="cov0" title="0">return filteredTrail, nil</span>
}

// Helper methods
func (s *TrackingSystem) updateOverallComplianceScore(tracking *ComplianceTracking) <span class="cov0" title="0">{
        if len(tracking.Requirements) == 0 </span><span class="cov0" title="0">{
                tracking.ComplianceScore = 0.0
                return
        }</span>

        <span class="cov0" title="0">totalScore := 0.0
        validRequirements := 0

        for _, req := range tracking.Requirements </span><span class="cov0" title="0">{
                if req.Status != ComplianceStatusExempt </span><span class="cov0" title="0">{
                        totalScore += req.ComplianceScore
                        validRequirements++
                }</span>
        }

        <span class="cov0" title="0">if validRequirements &gt; 0 </span><span class="cov0" title="0">{
                tracking.ComplianceScore = totalScore / float64(validRequirements)
        }</span> else<span class="cov0" title="0"> {
                tracking.ComplianceScore = 0.0
        }</span>

        // Update overall status based on score
        <span class="cov0" title="0">if tracking.ComplianceScore &gt;= 90.0 </span><span class="cov0" title="0">{
                tracking.OverallStatus = ComplianceStatusVerified
        }</span> else<span class="cov0" title="0"> if tracking.ComplianceScore &gt;= 70.0 </span><span class="cov0" title="0">{
                tracking.OverallStatus = ComplianceStatusImplemented
        }</span> else<span class="cov0" title="0"> if tracking.ComplianceScore &gt;= 30.0 </span><span class="cov0" title="0">{
                tracking.OverallStatus = ComplianceStatusInProgress
        }</span> else<span class="cov0" title="0"> {
                tracking.OverallStatus = ComplianceStatusNotStarted
        }</span>
}

func (s *TrackingSystem) updateRequirementScore(tracking *ComplianceTracking, reqIndex int) <span class="cov0" title="0">{
        req := &amp;tracking.Requirements[reqIndex]
        if len(req.Controls) == 0 </span><span class="cov0" title="0">{
                req.ComplianceScore = 0.0
                return
        }</span>

        <span class="cov0" title="0">totalScore := 0.0
        validControls := 0

        for _, control := range req.Controls </span><span class="cov0" title="0">{
                // Calculate control score based on effectiveness
                var controlScore float64
                switch control.Effectiveness </span>{
                case ControlEffectivenessHighlyEffective:<span class="cov0" title="0">
                        controlScore = 100.0</span>
                case ControlEffectivenessEffective:<span class="cov0" title="0">
                        controlScore = 80.0</span>
                case ControlEffectivenessPartiallyEffective:<span class="cov0" title="0">
                        controlScore = 50.0</span>
                case ControlEffectivenessIneffective:<span class="cov0" title="0">
                        controlScore = 0.0</span>
                }

                <span class="cov0" title="0">totalScore += controlScore
                validControls++</span>
        }

        <span class="cov0" title="0">if validControls &gt; 0 </span><span class="cov0" title="0">{
                req.ComplianceScore = totalScore / float64(validControls)
        }</span> else<span class="cov0" title="0"> {
                req.ComplianceScore = 0.0
        }</span>

        // Update requirement status based on score
        <span class="cov0" title="0">if req.ComplianceScore &gt;= 90.0 </span><span class="cov0" title="0">{
                req.Status = ComplianceStatusVerified
        }</span> else<span class="cov0" title="0"> if req.ComplianceScore &gt;= 70.0 </span><span class="cov0" title="0">{
                req.Status = ComplianceStatusImplemented
        }</span> else<span class="cov0" title="0"> if req.ComplianceScore &gt;= 30.0 </span><span class="cov0" title="0">{
                req.Status = ComplianceStatusInProgress
        }</span> else<span class="cov0" title="0"> {
                req.Status = ComplianceStatusNotStarted
        }</span>
}

func (s *TrackingSystem) updateControlEffectiveness(tracking *ComplianceTracking, reqIndex, controlIndex int) <span class="cov0" title="0">{
        control := &amp;tracking.Requirements[reqIndex].Controls[controlIndex]

        if len(control.TestResults) == 0 </span><span class="cov0" title="0">{
                control.Effectiveness = ControlEffectivenessIneffective
                return
        }</span>

        // Calculate effectiveness based on recent test results
        <span class="cov0" title="0">recentTests := 0
        passCount := 0
        lastMonth := time.Now().Add(-30 * 24 * time.Hour)

        for _, test := range control.TestResults </span><span class="cov0" title="0">{
                if test.TestDate.After(lastMonth) </span><span class="cov0" title="0">{
                        recentTests++
                        if test.Result == TestResultPass </span><span class="cov0" title="0">{
                                passCount++
                        }</span>
                }
        }

        <span class="cov0" title="0">if recentTests == 0 </span><span class="cov0" title="0">{
                control.Effectiveness = ControlEffectivenessIneffective
                return
        }</span>

        <span class="cov0" title="0">passRate := float64(passCount) / float64(recentTests)

        if passRate &gt;= 0.9 </span><span class="cov0" title="0">{
                control.Effectiveness = ControlEffectivenessHighlyEffective
        }</span> else<span class="cov0" title="0"> if passRate &gt;= 0.7 </span><span class="cov0" title="0">{
                control.Effectiveness = ControlEffectivenessEffective
        }</span> else<span class="cov0" title="0"> if passRate &gt;= 0.5 </span><span class="cov0" title="0">{
                control.Effectiveness = ControlEffectivenessPartiallyEffective
        }</span> else<span class="cov0" title="0"> {
                control.Effectiveness = ControlEffectivenessIneffective
        }</span>
}

func (s *TrackingSystem) calculateNextTestDate(lastTestDate time.Time, frequency string) *time.Time <span class="cov0" title="0">{
        var nextDate time.Time

        switch frequency </span>{
        case "daily":<span class="cov0" title="0">
                nextDate = lastTestDate.Add(24 * time.Hour)</span>
        case "weekly":<span class="cov0" title="0">
                nextDate = lastTestDate.Add(7 * 24 * time.Hour)</span>
        case "monthly":<span class="cov0" title="0">
                nextDate = lastTestDate.Add(30 * 24 * time.Hour)</span>
        case "quarterly":<span class="cov0" title="0">
                nextDate = lastTestDate.Add(90 * 24 * time.Hour)</span>
        case "annually":<span class="cov0" title="0">
                nextDate = lastTestDate.Add(365 * 24 * time.Hour)</span>
        default:<span class="cov0" title="0">
                nextDate = lastTestDate.Add(30 * 24 * time.Hour)</span> // Default to monthly
        }

        <span class="cov0" title="0">return &amp;nextDate</span>
}

func (s *TrackingSystem) logAuditTrail(ctx context.Context, businessID, framework string, requirementID *string, action AuditAction, description, oldValue, newValue string) <span class="cov0" title="0">{
        requestID := ctx.Value("request_id").(string)

        auditEntry := ComplianceAuditTrail{
                ID:            fmt.Sprintf("audit_%d", time.Now().UnixNano()),
                BusinessID:    businessID,
                Framework:     framework,
                RequirementID: requirementID,
                Action:        action,
                Description:   description,
                UserID:        "system",
                UserName:      "System",
                UserRole:      "compliance_system",
                Timestamp:     time.Now(),
                IPAddress:     "127.0.0.1",
                UserAgent:     "compliance-system",
                SessionID:     requestID,
                RequestID:     requestID,
                OldValue:      oldValue,
                NewValue:      newValue,
        }

        s.auditTrail = append(s.auditTrail, auditEntry)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package config

import (
        "bufio"
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"
)

// Environment represents the application environment
type Environment string

const (
        Development Environment = "development"
        Staging     Environment = "staging"
        Production  Environment = "production"
        Testing     Environment = "testing"
)

// Config holds all configuration for the application
type Config struct {
        // Server configuration
        Server ServerConfig `json:"server" yaml:"server"`

        // Database configuration
        Database DatabaseConfig `json:"database" yaml:"database"`

        // Authentication configuration
        Auth AuthConfig `json:"auth" yaml:"auth"`

        // Observability configuration
        Observability ObservabilityConfig `json:"observability" yaml:"observability"`

        // External services configuration
        ExternalServices ExternalServicesConfig `json:"external_services" yaml:"external_services"`

        // Feature flags
        Features FeatureFlags `json:"features" yaml:"features"`

        // Environment
        Environment Environment `json:"environment" yaml:"environment"`
}

// ServerConfig holds server-related configuration
type ServerConfig struct {
        Port         int           `json:"port" yaml:"port"`
        Host         string        `json:"host" yaml:"host"`
        ReadTimeout  time.Duration `json:"read_timeout" yaml:"read_timeout"`
        WriteTimeout time.Duration `json:"write_timeout" yaml:"write_timeout"`
        IdleTimeout  time.Duration `json:"idle_timeout" yaml:"idle_timeout"`

        // CORS configuration
        CORS CORSConfig `json:"cors" yaml:"cors"`

        // Rate limiting
        RateLimit RateLimitConfig `json:"rate_limit" yaml:"rate_limit"`

        // Auth-specific rate limiting
        AuthRateLimit AuthRateLimitConfig `json:"auth_rate_limit" yaml:"auth_rate_limit"`

        // IP-based blocking
        IPBlock IPBlockConfig `json:"ip_block" yaml:"ip_block"`

        // Request validation
        Validation ValidationConfig `json:"validation" yaml:"validation"`
}

// IPBlockConfig holds settings for IP-based blocking
type IPBlockConfig struct {
        Enabled       bool          `json:"enabled" yaml:"enabled"`
        Threshold     int           `json:"threshold" yaml:"threshold"`           // number of offending responses in window
        Window        time.Duration `json:"window" yaml:"window"`                 // sliding window duration
        BlockDuration time.Duration `json:"block_duration" yaml:"block_duration"` // how long to block the IP
        Whitelist     []string      `json:"whitelist" yaml:"whitelist"`
        Blacklist     []string      `json:"blacklist" yaml:"blacklist"`
}

// CORSConfig holds CORS-related configuration
type CORSConfig struct {
        AllowedOrigins   []string `json:"allowed_origins" yaml:"allowed_origins"`
        AllowedMethods   []string `json:"allowed_methods" yaml:"allowed_methods"`
        AllowedHeaders   []string `json:"allowed_headers" yaml:"allowed_headers"`
        AllowCredentials bool     `json:"allow_credentials" yaml:"allow_credentials"`
        MaxAge           int      `json:"max_age" yaml:"max_age"`
}

// RateLimitConfig holds rate limiting configuration
type RateLimitConfig struct {
        Enabled     bool `json:"enabled" yaml:"enabled"`
        RequestsPer int  `json:"requests_per" yaml:"requests_per"`
        WindowSize  int  `json:"window_size" yaml:"window_size"`
        BurstSize   int  `json:"burst_size" yaml:"burst_size"`
}

// AuthRateLimitConfig holds authentication-specific rate limiting configuration
type AuthRateLimitConfig struct {
        Enabled                  bool          `json:"enabled" yaml:"enabled"`
        LoginAttemptsPer         int           `json:"login_attempts_per" yaml:"login_attempts_per"`
        RegisterAttemptsPer      int           `json:"register_attempts_per" yaml:"register_attempts_per"`
        PasswordResetAttemptsPer int           `json:"password_reset_attempts_per" yaml:"password_reset_attempts_per"`
        WindowSize               time.Duration `json:"window_size" yaml:"window_size"`
        LockoutDuration          time.Duration `json:"lockout_duration" yaml:"lockout_duration"`
}

// ValidationConfig holds request validation configuration
type ValidationConfig struct {
        Enabled       bool     `json:"enabled" yaml:"enabled"`
        MaxBodySize   int64    `json:"max_body_size" yaml:"max_body_size"`
        RequiredPaths []string `json:"required_paths" yaml:"required_paths"`
}

// DatabaseConfig holds database-related configuration
type DatabaseConfig struct {
        Driver   string `json:"driver" yaml:"driver"`
        Host     string `json:"host" yaml:"host"`
        Port     int    `json:"port" yaml:"port"`
        Username string `json:"username" yaml:"username"`
        Password string `json:"password" yaml:"password"`
        Database string `json:"database" yaml:"database"`
        SSLMode  string `json:"ssl_mode" yaml:"ssl_mode"`

        // Connection pool settings
        MaxOpenConns    int           `json:"max_open_conns" yaml:"max_open_conns"`
        MaxIdleConns    int           `json:"max_idle_conns" yaml:"max_idle_conns"`
        ConnMaxLifetime time.Duration `json:"conn_max_lifetime" yaml:"conn_max_lifetime"`

        // Migration settings
        AutoMigrate bool `json:"auto_migrate" yaml:"auto_migrate"`
}

// AuthConfig holds authentication-related configuration
type AuthConfig struct {
        // JWT configuration
        JWTSecret         string        `json:"jwt_secret" yaml:"jwt_secret"`
        JWTExpiration     time.Duration `json:"jwt_expiration" yaml:"jwt_expiration"`
        RefreshExpiration time.Duration `json:"refresh_expiration" yaml:"refresh_expiration"`

        // Password configuration
        MinPasswordLength int  `json:"min_password_length" yaml:"min_password_length"`
        RequireUppercase  bool `json:"require_uppercase" yaml:"require_uppercase"`
        RequireLowercase  bool `json:"require_lowercase" yaml:"require_lowercase"`
        RequireNumbers    bool `json:"require_numbers" yaml:"require_numbers"`
        RequireSpecial    bool `json:"require_special" yaml:"require_special"`

        // Account lockout
        MaxLoginAttempts int           `json:"max_login_attempts" yaml:"max_login_attempts"`
        LockoutDuration  time.Duration `json:"lockout_duration" yaml:"lockout_duration"`

        // Session &amp; cookie settings
        RefreshCookieName string `json:"refresh_cookie_name" yaml:"refresh_cookie_name"`
        CSRFCookieName    string `json:"csrf_cookie_name" yaml:"csrf_cookie_name"`
        CookieDomain      string `json:"cookie_domain" yaml:"cookie_domain"`
        CookiePath        string `json:"cookie_path" yaml:"cookie_path"`
        CookieSecure      bool   `json:"cookie_secure" yaml:"cookie_secure"`
        CookieSameSite    string `json:"cookie_same_site" yaml:"cookie_same_site"` // Strict|Lax|None
}

// ObservabilityConfig holds observability-related configuration
type ObservabilityConfig struct {
        // Logging
        LogLevel  string `json:"log_level" yaml:"log_level"`
        LogFormat string `json:"log_format" yaml:"log_format"`

        // Metrics
        MetricsEnabled bool   `json:"metrics_enabled" yaml:"metrics_enabled"`
        MetricsPort    int    `json:"metrics_port" yaml:"metrics_port"`
        MetricsPath    string `json:"metrics_path" yaml:"metrics_path"`

        // Tracing
        TracingEnabled bool   `json:"tracing_enabled" yaml:"tracing_enabled"`
        TracingURL     string `json:"tracing_url" yaml:"tracing_url"`

        // Health checks
        HealthCheckPath string `json:"health_check_path" yaml:"health_check_path"`

        // Performance thresholds
        SlowRequestThreshold        time.Duration `json:"slow_request_threshold" yaml:"slow_request_threshold"`
        SlowClassificationThreshold time.Duration `json:"slow_classification_threshold" yaml:"slow_classification_threshold"`
}

// ExternalServicesConfig holds external service configurations
type ExternalServicesConfig struct {
        // Business data providers
        BusinessDataAPI BusinessDataAPIConfig `json:"business_data_api" yaml:"business_data_api"`

        // Risk assessment services
        RiskAssessmentAPI RiskAssessmentAPIConfig `json:"risk_assessment_api" yaml:"risk_assessment_api"`

        // Compliance services
        ComplianceAPI ComplianceAPIConfig `json:"compliance_api" yaml:"compliance_api"`

        // Classification cache configuration (kept here for minimal wiring with existing service ctor)
        ClassificationCache ClassificationCacheConfig `json:"classification_cache" yaml:"classification_cache"`

        // Shared HTTP client pool settings for external services
        HTTPClient HTTPClientConfig `json:"http_client" yaml:"http_client"`
}

// ClassificationCacheConfig controls in-memory caching for classification results
type ClassificationCacheConfig struct {
        Enabled         bool          `json:"enabled" yaml:"enabled"`
        TTL             time.Duration `json:"ttl" yaml:"ttl"`
        MaxEntries      int           `json:"max_entries" yaml:"max_entries"`
        JanitorInterval time.Duration `json:"janitor_interval" yaml:"janitor_interval"`
}

// BusinessDataAPIConfig holds business data API configuration
type BusinessDataAPIConfig struct {
        Enabled    bool          `json:"enabled" yaml:"enabled"`
        BaseURL    string        `json:"base_url" yaml:"base_url"`
        APIKey     string        `json:"api_key" yaml:"api_key"`
        Timeout    time.Duration `json:"timeout" yaml:"timeout"`
        MaxRetries int           `json:"max_retries" yaml:"max_retries"`
}

// HTTPClientConfig controls connection pooling for external HTTP calls
type HTTPClientConfig struct {
        MaxIdleConns          int           `json:"max_idle_conns" yaml:"max_idle_conns"`
        MaxIdleConnsPerHost   int           `json:"max_idle_conns_per_host" yaml:"max_idle_conns_per_host"`
        IdleConnTimeout       time.Duration `json:"idle_conn_timeout" yaml:"idle_conn_timeout"`
        TLSHandshakeTimeout   time.Duration `json:"tls_handshake_timeout" yaml:"tls_handshake_timeout"`
        ExpectContinueTimeout time.Duration `json:"expect_continue_timeout" yaml:"expect_continue_timeout"`
        RequestTimeout        time.Duration `json:"request_timeout" yaml:"request_timeout"`
}

// RiskAssessmentAPIConfig holds risk assessment API configuration
type RiskAssessmentAPIConfig struct {
        Enabled    bool          `json:"enabled" yaml:"enabled"`
        BaseURL    string        `json:"base_url" yaml:"base_url"`
        APIKey     string        `json:"api_key" yaml:"api_key"`
        Timeout    time.Duration `json:"timeout" yaml:"timeout"`
        MaxRetries int           `json:"max_retries" yaml:"max_retries"`
}

// ComplianceAPIConfig holds compliance API configuration
type ComplianceAPIConfig struct {
        Enabled    bool          `json:"enabled" yaml:"enabled"`
        BaseURL    string        `json:"base_url" yaml:"base_url"`
        APIKey     string        `json:"api_key" yaml:"api_key"`
        Timeout    time.Duration `json:"timeout" yaml:"timeout"`
        MaxRetries int           `json:"max_retries" yaml:"max_retries"`
}

// FeatureFlags holds feature flag configurations
type FeatureFlags struct {
        // Core features
        BusinessClassification bool `json:"business_classification" yaml:"business_classification"`
        RiskAssessment         bool `json:"risk_assessment" yaml:"risk_assessment"`
        ComplianceFramework    bool `json:"compliance_framework" yaml:"compliance_framework"`

        // Advanced features
        AdvancedAnalytics  bool `json:"advanced_analytics" yaml:"advanced_analytics"`
        RealTimeMonitoring bool `json:"real_time_monitoring" yaml:"real_time_monitoring"`
        BatchProcessing    bool `json:"batch_processing" yaml:"batch_processing"`

        // Integration features
        APIKeyManagement    bool `json:"api_key_management" yaml:"api_key_management"`
        WebhookSupport      bool `json:"webhook_support" yaml:"webhook_support"`
        ExportFunctionality bool `json:"export_functionality" yaml:"export_functionality"`
}

// Load loads configuration from environment variables
func Load() (*Config, error) <span class="cov8" title="1">{
        // Load .env file if it exists
        loadEnvFile()

        config := &amp;Config{
                Environment:      getEnvironment(),
                Server:           getServerConfig(),
                Database:         getDatabaseConfig(),
                Auth:             getAuthConfig(),
                Observability:    getObservabilityConfig(),
                ExternalServices: getExternalServicesConfig(),
                Features:         getFeatureFlags(),
        }

        // Validate configuration
        if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}

// loadEnvFile loads environment variables from .env file
func loadEnvFile() <span class="cov8" title="1">{
        file, err := os.Open(".env")
        if err != nil </span><span class="cov8" title="1">{
                // .env file doesn't exist, which is fine
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, "=", 2)
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        key := strings.TrimSpace(parts[0])
                        value := strings.TrimSpace(parts[1])
                        // Remove quotes if present
                        if len(value) &gt; 1 &amp;&amp; (value[0] == '"' &amp;&amp; value[len(value)-1] == '"') </span><span class="cov0" title="0">{
                                value = value[1 : len(value)-1]
                        }</span>
                        <span class="cov0" title="0">os.Setenv(key, value)</span>
                }
        }
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov8" title="1">{
        // Validate server configuration
        if c.Server.Port &lt;= 0 || c.Server.Port &gt; 65535 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid server port: %d", c.Server.Port)
        }</span>

        // Validate database configuration
        <span class="cov8" title="1">if c.Database.Driver == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("database driver is required")
        }</span>

        // Validate auth configuration
        <span class="cov8" title="1">if c.Auth.JWTSecret == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("JWT secret is required")
        }</span>

        <span class="cov8" title="1">if c.Auth.MinPasswordLength &lt; 8 </span><span class="cov8" title="1">{
                return fmt.Errorf("minimum password length must be at least 8")
        }</span>

        // Validate external services
        <span class="cov8" title="1">if c.ExternalServices.BusinessDataAPI.Enabled </span><span class="cov8" title="1">{
                if c.ExternalServices.BusinessDataAPI.BaseURL == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("business data API base URL is required when enabled")
                }</span>
                <span class="cov8" title="1">if c.ExternalServices.BusinessDataAPI.APIKey == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("business data API key is required when enabled")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getEnvironment returns the current environment
func getEnvironment() Environment <span class="cov8" title="1">{
        env := os.Getenv("ENV")
        switch strings.ToLower(env) </span>{
        case "production", "prod":<span class="cov8" title="1">
                return Production</span>
        case "staging", "stage":<span class="cov8" title="1">
                return Staging</span>
        case "testing", "test":<span class="cov8" title="1">
                return Testing</span>
        default:<span class="cov8" title="1">
                return Development</span>
        }
}

// getServerConfig returns server configuration from environment variables
func getServerConfig() ServerConfig <span class="cov8" title="1">{
        return ServerConfig{
                Port:         getEnvAsInt("PORT", 8080),
                Host:         getEnvAsString("HOST", "0.0.0.0"),
                ReadTimeout:  getEnvAsDuration("READ_TIMEOUT", 30*time.Second),
                WriteTimeout: getEnvAsDuration("WRITE_TIMEOUT", 30*time.Second),
                IdleTimeout:  getEnvAsDuration("IDLE_TIMEOUT", 60*time.Second),
                CORS: CORSConfig{
                        AllowedOrigins:   getEnvAsStringSlice("CORS_ALLOWED_ORIGINS", []string{"*"}),
                        AllowedMethods:   getEnvAsStringSlice("CORS_ALLOWED_METHODS", []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"}),
                        AllowedHeaders:   getEnvAsStringSlice("CORS_ALLOWED_HEADERS", []string{"*"}),
                        AllowCredentials: getEnvAsBool("CORS_ALLOW_CREDENTIALS", true),
                        MaxAge:           getEnvAsInt("CORS_MAX_AGE", 86400),
                },
                RateLimit: RateLimitConfig{
                        Enabled:     getEnvAsBool("RATE_LIMIT_ENABLED", true),
                        RequestsPer: getEnvAsInt("RATE_LIMIT_REQUESTS_PER", 100),
                        WindowSize:  getEnvAsInt("RATE_LIMIT_WINDOW_SIZE", 60),
                        BurstSize:   getEnvAsInt("RATE_LIMIT_BURST_SIZE", 200),
                },
                AuthRateLimit: AuthRateLimitConfig{
                        Enabled:                  getEnvAsBool("AUTH_RATE_LIMIT_ENABLED", true),
                        LoginAttemptsPer:         getEnvAsInt("AUTH_RATE_LIMIT_LOGIN_ATTEMPTS_PER", 10),
                        RegisterAttemptsPer:      getEnvAsInt("AUTH_RATE_LIMIT_REGISTER_ATTEMPTS_PER", 10),
                        PasswordResetAttemptsPer: getEnvAsInt("AUTH_RATE_LIMIT_PASSWORD_RESET_ATTEMPTS_PER", 10),
                        WindowSize:               getEnvAsDuration("AUTH_RATE_LIMIT_WINDOW_SIZE", 60*time.Second),
                        LockoutDuration:          getEnvAsDuration("AUTH_RATE_LIMIT_LOCKOUT_DURATION", 15*time.Minute),
                },
                IPBlock: IPBlockConfig{
                        Enabled:       getEnvAsBool("IP_BLOCK_ENABLED", true),
                        Threshold:     getEnvAsInt("IP_BLOCK_THRESHOLD", 20),
                        Window:        getEnvAsDuration("IP_BLOCK_WINDOW", 5*time.Minute),
                        BlockDuration: getEnvAsDuration("IP_BLOCK_DURATION", 30*time.Minute),
                        Whitelist:     getEnvAsStringSlice("IP_BLOCK_WHITELIST", []string{}),
                        Blacklist:     getEnvAsStringSlice("IP_BLOCK_BLACKLIST", []string{}),
                },
                Validation: ValidationConfig{
                        Enabled:       getEnvAsBool("VALIDATION_ENABLED", true),
                        MaxBodySize:   getEnvAsInt64("VALIDATION_MAX_BODY_SIZE", 10*1024*1024), // 10MB
                        RequiredPaths: getEnvAsStringSlice("VALIDATION_REQUIRED_PATHS", []string{"/v1/"}),
                },
        }
}</span>

// getDatabaseConfig returns database configuration from environment variables
func getDatabaseConfig() DatabaseConfig <span class="cov8" title="1">{
        return DatabaseConfig{
                Driver:          getEnvAsString("DB_DRIVER", "postgres"),
                Host:            getEnvAsString("DB_HOST", "localhost"),
                Port:            getEnvAsInt("DB_PORT", 5432),
                Username:        getEnvAsString("DB_USERNAME", "postgres"),
                Password:        getEnvAsString("DB_PASSWORD", ""),
                Database:        getEnvAsString("DB_DATABASE", "business_verification"),
                SSLMode:         getEnvAsString("DB_SSL_MODE", "disable"),
                MaxOpenConns:    getEnvAsInt("DB_MAX_OPEN_CONNS", 25),
                MaxIdleConns:    getEnvAsInt("DB_MAX_IDLE_CONNS", 5),
                ConnMaxLifetime: getEnvAsDuration("DB_CONN_MAX_LIFETIME", 5*time.Minute),
                AutoMigrate:     getEnvAsBool("DB_AUTO_MIGRATE", true),
        }
}</span>

// getAuthConfig returns authentication configuration from environment variables
func getAuthConfig() AuthConfig <span class="cov8" title="1">{
        return AuthConfig{
                JWTSecret:         getEnvAsString("JWT_SECRET", ""),
                JWTExpiration:     getEnvAsDuration("JWT_EXPIRATION", 24*time.Hour),
                RefreshExpiration: getEnvAsDuration("REFRESH_EXPIRATION", 7*24*time.Hour),
                MinPasswordLength: getEnvAsInt("MIN_PASSWORD_LENGTH", 8),
                RequireUppercase:  getEnvAsBool("REQUIRE_UPPERCASE", true),
                RequireLowercase:  getEnvAsBool("REQUIRE_LOWERCASE", true),
                RequireNumbers:    getEnvAsBool("REQUIRE_NUMBERS", true),
                RequireSpecial:    getEnvAsBool("REQUIRE_SPECIAL", true),
                MaxLoginAttempts:  getEnvAsInt("MAX_LOGIN_ATTEMPTS", 5),
                LockoutDuration:   getEnvAsDuration("LOCKOUT_DURATION", 15*time.Minute),

                // Cookies / session
                RefreshCookieName: getEnvAsString("REFRESH_COOKIE_NAME", "refresh_token"),
                CSRFCookieName:    getEnvAsString("CSRF_COOKIE_NAME", "XSRF-TOKEN"),
                CookieDomain:      getEnvAsString("COOKIE_DOMAIN", ""),
                CookiePath:        getEnvAsString("COOKIE_PATH", "/"),
                CookieSecure:      getEnvAsBool("COOKIE_SECURE", true),
                CookieSameSite:    getEnvAsString("COOKIE_SAMESITE", "Lax"),
        }
}</span>

// getObservabilityConfig returns observability configuration from environment variables
func getObservabilityConfig() ObservabilityConfig <span class="cov8" title="1">{
        return ObservabilityConfig{
                LogLevel:                    getEnvAsString("LOG_LEVEL", "info"),
                LogFormat:                   getEnvAsString("LOG_FORMAT", "json"),
                MetricsEnabled:              getEnvAsBool("METRICS_ENABLED", true),
                MetricsPort:                 getEnvAsInt("METRICS_PORT", 9090),
                MetricsPath:                 getEnvAsString("METRICS_PATH", "/metrics"),
                TracingEnabled:              getEnvAsBool("TRACING_ENABLED", true),
                TracingURL:                  getEnvAsString("TRACING_URL", "http://localhost:14268/api/traces"),
                HealthCheckPath:             getEnvAsString("HEALTH_CHECK_PATH", "/health"),
                SlowRequestThreshold:        getEnvAsDuration("SLOW_REQUEST_THRESHOLD", 300*time.Millisecond),
                SlowClassificationThreshold: getEnvAsDuration("SLOW_CLASSIFICATION_THRESHOLD", 300*time.Millisecond),
        }
}</span>

// getExternalServicesConfig returns external services configuration from environment variables
func getExternalServicesConfig() ExternalServicesConfig <span class="cov8" title="1">{
        return ExternalServicesConfig{
                BusinessDataAPI: BusinessDataAPIConfig{
                        Enabled:    getEnvAsBool("BUSINESS_DATA_API_ENABLED", false),
                        BaseURL:    getEnvAsString("BUSINESS_DATA_API_BASE_URL", ""),
                        APIKey:     getEnvAsString("BUSINESS_DATA_API_KEY", ""),
                        Timeout:    getEnvAsDuration("BUSINESS_DATA_API_TIMEOUT", 30*time.Second),
                        MaxRetries: getEnvAsInt("BUSINESS_DATA_API_MAX_RETRIES", 3),
                },
                RiskAssessmentAPI: RiskAssessmentAPIConfig{
                        Enabled:    getEnvAsBool("RISK_ASSESSMENT_API_ENABLED", false),
                        BaseURL:    getEnvAsString("RISK_ASSESSMENT_API_BASE_URL", ""),
                        APIKey:     getEnvAsString("RISK_ASSESSMENT_API_KEY", ""),
                        Timeout:    getEnvAsDuration("RISK_ASSESSMENT_API_TIMEOUT", 30*time.Second),
                        MaxRetries: getEnvAsInt("RISK_ASSESSMENT_API_MAX_RETRIES", 3),
                },
                ComplianceAPI: ComplianceAPIConfig{
                        Enabled:    getEnvAsBool("COMPLIANCE_API_ENABLED", false),
                        BaseURL:    getEnvAsString("COMPLIANCE_API_BASE_URL", ""),
                        APIKey:     getEnvAsString("COMPLIANCE_API_KEY", ""),
                        Timeout:    getEnvAsDuration("COMPLIANCE_API_TIMEOUT", 30*time.Second),
                        MaxRetries: getEnvAsInt("COMPLIANCE_API_MAX_RETRIES", 3),
                },
                ClassificationCache: ClassificationCacheConfig{
                        Enabled:         getEnvAsBool("CLASSIFICATION_CACHE_ENABLED", true),
                        TTL:             getEnvAsDuration("CLASSIFICATION_CACHE_TTL", 10*time.Minute),
                        MaxEntries:      getEnvAsInt("CLASSIFICATION_CACHE_MAX_ENTRIES", 10000),
                        JanitorInterval: getEnvAsDuration("CLASSIFICATION_CACHE_JANITOR_INTERVAL", 1*time.Minute),
                },
                HTTPClient: HTTPClientConfig{
                        MaxIdleConns:          getEnvAsInt("EXT_HTTP_MAX_IDLE_CONNS", 256),
                        MaxIdleConnsPerHost:   getEnvAsInt("EXT_HTTP_MAX_IDLE_CONNS_PER_HOST", 64),
                        IdleConnTimeout:       getEnvAsDuration("EXT_HTTP_IDLE_CONN_TIMEOUT", 90*time.Second),
                        TLSHandshakeTimeout:   getEnvAsDuration("EXT_HTTP_TLS_HANDSHAKE_TIMEOUT", 10*time.Second),
                        ExpectContinueTimeout: getEnvAsDuration("EXT_HTTP_EXPECT_CONTINUE_TIMEOUT", 1*time.Second),
                        RequestTimeout:        getEnvAsDuration("EXT_HTTP_REQUEST_TIMEOUT", 30*time.Second),
                },
        }
}</span>

// getFeatureFlags returns feature flags from environment variables
func getFeatureFlags() FeatureFlags <span class="cov8" title="1">{
        return FeatureFlags{
                BusinessClassification: getEnvAsBool("FEATURE_BUSINESS_CLASSIFICATION", true),
                RiskAssessment:         getEnvAsBool("FEATURE_RISK_ASSESSMENT", true),
                ComplianceFramework:    getEnvAsBool("FEATURE_COMPLIANCE_FRAMEWORK", true),
                AdvancedAnalytics:      getEnvAsBool("FEATURE_ADVANCED_ANALYTICS", false),
                RealTimeMonitoring:     getEnvAsBool("FEATURE_REAL_TIME_MONITORING", false),
                BatchProcessing:        getEnvAsBool("FEATURE_BATCH_PROCESSING", false),
                APIKeyManagement:       getEnvAsBool("FEATURE_API_KEY_MANAGEMENT", true),
                WebhookSupport:         getEnvAsBool("FEATURE_WEBHOOK_SUPPORT", false),
                ExportFunctionality:    getEnvAsBool("FEATURE_EXPORT_FUNCTIONALITY", false),
        }
}</span>

// Helper functions for environment variable parsing

func getEnvAsString(key, defaultValue string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

func getEnvAsInt(key string, defaultValue int) int <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov8" title="1">{
                        return intValue
                }</span>
        }
        <span class="cov8" title="1">return defaultValue</span>
}

func getEnvAsBool(key string, defaultValue bool) bool <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return boolValue
                }</span>
        }
        <span class="cov8" title="1">return defaultValue</span>
}

func getEnvAsDuration(key string, defaultValue time.Duration) time.Duration <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return duration
                }</span>
        }
        <span class="cov8" title="1">return defaultValue</span>
}

func getEnvAsStringSlice(key string, defaultValue []string) []string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return strings.Split(value, ",")
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

func getEnvAsInt64(key string, defaultValue int64) int64 <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.ParseInt(value, 10, 64); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov8" title="1">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "log"
        "os"
        "os/exec"
        "path/filepath"
        "time"
)

// BackupConfig represents backup configuration
type BackupConfig struct {
        BackupDir      string        `json:"backup_dir"`
        RetentionDays  int           `json:"retention_days"`
        CompressBackup bool          `json:"compress_backup"`
        BackupInterval time.Duration `json:"backup_interval"`
}

// BackupInfo represents backup information
type BackupInfo struct {
        ID        string    `json:"id"`
        Filename  string    `json:"filename"`
        Size      int64     `json:"size"`
        CreatedAt time.Time `json:"created_at"`
        Status    string    `json:"status"`
        Error     string    `json:"error,omitempty"`
        Checksum  string    `json:"checksum,omitempty"`
}

// BackupSystem handles database backups
type BackupSystem struct {
        db           *sql.DB
        config       *DatabaseConfig
        backupConfig *BackupConfig
}

// NewBackupSystem creates a new backup system
func NewBackupSystem(db *sql.DB, config *DatabaseConfig, backupConfig *BackupConfig) *BackupSystem <span class="cov0" title="0">{
        return &amp;BackupSystem{
                db:           db,
                config:       config,
                backupConfig: backupConfig,
        }
}</span>

// CreateBackup creates a database backup
func (b *BackupSystem) CreateBackup(ctx context.Context) (*BackupInfo, error) <span class="cov0" title="0">{
        // Generate backup filename
        timestamp := time.Now().Format("2006-01-02_15-04-05")
        backupID := fmt.Sprintf("backup_%s", timestamp)
        filename := fmt.Sprintf("%s.sql", backupID)
        filepath := filepath.Join(b.backupConfig.BackupDir, filename)

        // Ensure backup directory exists
        if err := os.MkdirAll(b.backupConfig.BackupDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create backup directory: %w", err)
        }</span>

        // Create backup info
        <span class="cov0" title="0">backupInfo := &amp;BackupInfo{
                ID:        backupID,
                Filename:  filename,
                CreatedAt: time.Now(),
                Status:    "in_progress",
        }

        // Execute pg_dump command
        cmd := exec.CommandContext(ctx, "pg_dump",
                "-h", b.config.Host,
                "-p", fmt.Sprintf("%d", b.config.Port),
                "-U", b.config.Username,
                "-d", b.config.Database,
                "-f", filepath,
                "--no-password", // Use environment variable for password
        )

        // Set environment variables
        cmd.Env = append(os.Environ(), fmt.Sprintf("PGPASSWORD=%s", b.config.Password))

        // Execute backup
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                backupInfo.Status = "failed"
                backupInfo.Error = err.Error()
                return backupInfo, fmt.Errorf("failed to create backup: %w", err)
        }</span>

        // Get file info
        <span class="cov0" title="0">fileInfo, err := os.Stat(filepath)
        if err != nil </span><span class="cov0" title="0">{
                backupInfo.Status = "failed"
                backupInfo.Error = err.Error()
                return backupInfo, fmt.Errorf("failed to get backup file info: %w", err)
        }</span>

        <span class="cov0" title="0">backupInfo.Size = fileInfo.Size()
        backupInfo.Status = "completed"

        // Compress backup if configured
        if b.backupConfig.CompressBackup </span><span class="cov0" title="0">{
                if err := b.compressBackup(filepath); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to compress backup %s: %v", backupID, err)
                }</span>
        }

        <span class="cov0" title="0">log.Printf("Backup created successfully: %s (%d bytes)", backupID, backupInfo.Size)
        return backupInfo, nil</span>
}

// RestoreBackup restores a database from backup
func (b *BackupSystem) RestoreBackup(ctx context.Context, backupID string) error <span class="cov0" title="0">{
        // Find backup file
        backupFile := b.findBackupFile(backupID)
        if backupFile == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("backup file not found for ID: %s", backupID)
        }</span>

        // Check if file exists
        <span class="cov0" title="0">if _, err := os.Stat(backupFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("backup file does not exist: %s", backupFile)
        }</span>

        // Execute psql command to restore
        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, "psql",
                "-h", b.config.Host,
                "-p", fmt.Sprintf("%d", b.config.Port),
                "-U", b.config.Username,
                "-d", b.config.Database,
                "-f", backupFile,
                "--no-password", // Use environment variable for password
        )

        // Set environment variables
        cmd.Env = append(os.Environ(), fmt.Sprintf("PGPASSWORD=%s", b.config.Password))

        // Execute restore
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restore backup: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Backup restored successfully: %s", backupID)
        return nil</span>
}

// ListBackups lists all available backups
func (b *BackupSystem) ListBackups() ([]*BackupInfo, error) <span class="cov0" title="0">{
        var backups []*BackupInfo

        // Read backup directory
        files, err := os.ReadDir(b.backupConfig.BackupDir)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return backups, nil // No backups directory yet
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to read backup directory: %w", err)</span>
        }

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                if file.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse backup info from filename
                <span class="cov0" title="0">backupInfo, err := b.parseBackupInfo(file.Name())
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to parse backup info for %s: %v", file.Name(), err)
                        continue</span>
                }

                // Get file info
                <span class="cov0" title="0">fileInfo, err := file.Info()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to get file info for %s: %v", file.Name(), err)
                        continue</span>
                }

                <span class="cov0" title="0">backupInfo.Size = fileInfo.Size()
                backupInfo.CreatedAt = fileInfo.ModTime()
                backupInfo.Status = "completed"

                backups = append(backups, backupInfo)</span>
        }

        <span class="cov0" title="0">return backups, nil</span>
}

// DeleteBackup deletes a specific backup
func (b *BackupSystem) DeleteBackup(backupID string) error <span class="cov0" title="0">{
        backupFile := b.findBackupFile(backupID)
        if backupFile == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("backup file not found for ID: %s", backupID)
        }</span>

        <span class="cov0" title="0">if err := os.Remove(backupFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete backup file: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Backup deleted successfully: %s", backupID)
        return nil</span>
}

// CleanupOldBackups removes backups older than retention period
func (b *BackupSystem) CleanupOldBackups() error <span class="cov0" title="0">{
        backups, err := b.ListBackups()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list backups: %w", err)
        }</span>

        <span class="cov0" title="0">cutoffTime := time.Now().AddDate(0, 0, -b.backupConfig.RetentionDays)
        deletedCount := 0

        for _, backup := range backups </span><span class="cov0" title="0">{
                if backup.CreatedAt.Before(cutoffTime) </span><span class="cov0" title="0">{
                        if err := b.DeleteBackup(backup.ID); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: failed to delete old backup %s: %v", backup.ID, err)
                        }</span> else<span class="cov0" title="0"> {
                                deletedCount++
                        }</span>
                }
        }

        <span class="cov0" title="0">if deletedCount &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("Cleaned up %d old backups", deletedCount)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetBackupStatus returns the status of a specific backup
func (b *BackupSystem) GetBackupStatus(backupID string) (*BackupInfo, error) <span class="cov0" title="0">{
        backups, err := b.ListBackups()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list backups: %w", err)
        }</span>

        <span class="cov0" title="0">for _, backup := range backups </span><span class="cov0" title="0">{
                if backup.ID == backupID </span><span class="cov0" title="0">{
                        return backup, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("backup not found: %s", backupID)</span>
}

// findBackupFile finds the backup file for a given backup ID
func (b *BackupSystem) findBackupFile(backupID string) string <span class="cov0" title="0">{
        // Try different file extensions
        extensions := []string{".sql", ".sql.gz", ".sql.bz2"}

        for _, ext := range extensions </span><span class="cov0" title="0">{
                filename := backupID + ext
                filepath := filepath.Join(b.backupConfig.BackupDir, filename)

                if _, err := os.Stat(filepath); err == nil </span><span class="cov0" title="0">{
                        return filepath
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// parseBackupInfo parses backup information from filename
func (b *BackupSystem) parseBackupInfo(filename string) (*BackupInfo, error) <span class="cov0" title="0">{
        // Expected format: backup_YYYY-MM-DD_HH-MM-SS.sql
        if len(filename) &lt; 20 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid backup filename format: %s", filename)
        }</span>

        // Extract backup ID (remove extension)
        <span class="cov0" title="0">backupID := filename
        if ext := filepath.Ext(filename); ext != "" </span><span class="cov0" title="0">{
                backupID = filename[:len(filename)-len(ext)]
        }</span>

        // Validate backup ID format
        <span class="cov0" title="0">if len(backupID) &lt; 20 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid backup ID format: %s", backupID)
        }</span>

        <span class="cov0" title="0">return &amp;BackupInfo{
                ID:       backupID,
                Filename: filename,
                Status:   "unknown",
        }, nil</span>
}

// compressBackup compresses a backup file
func (b *BackupSystem) compressBackup(filepath string) error <span class="cov0" title="0">{
        // Use gzip to compress the backup file
        cmd := exec.Command("gzip", filepath)

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to compress backup: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// decompressBackup decompresses a backup file
func (b *BackupSystem) decompressBackup(filepath string) error <span class="cov0" title="0">{
        // Use gunzip to decompress the backup file
        cmd := exec.Command("gunzip", filepath)

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decompress backup: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateBackup validates a backup file
func (b *BackupSystem) ValidateBackup(backupID string) error <span class="cov0" title="0">{
        backupFile := b.findBackupFile(backupID)
        if backupFile == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("backup file not found for ID: %s", backupID)
        }</span>

        // Check if file is compressed
        <span class="cov0" title="0">isCompressed := filepath.Ext(backupFile) == ".gz"

        // For compressed files, we can only check if they can be decompressed
        if isCompressed </span><span class="cov0" title="0">{
                cmd := exec.Command("gunzip", "-t", backupFile)
                if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("backup file is corrupted or invalid: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // For uncompressed files, we can try to parse the SQL
                // This is a basic validation - in production you might want more sophisticated validation
                file, err := os.Open(backupFile)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open backup file: %w", err)
                }</span>
                <span class="cov0" title="0">defer file.Close()

                // Read first few bytes to check if it looks like SQL
                buffer := make([]byte, 100)
                n, err := file.Read(buffer)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read backup file: %w", err)
                }</span>

                <span class="cov0" title="0">content := string(buffer[:n])
                if len(content) &lt; 10 </span><span class="cov0" title="0">{
                        return fmt.Errorf("backup file appears to be empty or too small")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetBackupStats returns backup statistics
func (b *BackupSystem) GetBackupStats() (map[string]interface{}, error) <span class="cov0" title="0">{
        backups, err := b.ListBackups()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list backups: %w", err)
        }</span>

        <span class="cov0" title="0">totalSize := int64(0)
        oldestBackup := time.Now()
        newestBackup := time.Time{}

        for _, backup := range backups </span><span class="cov0" title="0">{
                totalSize += backup.Size

                if backup.CreatedAt.Before(oldestBackup) </span><span class="cov0" title="0">{
                        oldestBackup = backup.CreatedAt
                }</span>

                <span class="cov0" title="0">if backup.CreatedAt.After(newestBackup) </span><span class="cov0" title="0">{
                        newestBackup = backup.CreatedAt
                }</span>
        }

        <span class="cov0" title="0">stats := map[string]interface{}{
                "total_backups":    len(backups),
                "total_size_bytes": totalSize,
                "total_size_mb":    float64(totalSize) / (1024 * 1024),
                "oldest_backup":    oldestBackup,
                "newest_backup":    newestBackup,
                "retention_days":   b.backupConfig.RetentionDays,
                "backup_dir":       b.backupConfig.BackupDir,
        }

        return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package database

import (
        "context"
        "fmt"

        "github.com/pcraw4d/business-verification/internal/config"
)

// NewDatabase creates a new database instance based on configuration
func NewDatabase(cfg *config.DatabaseConfig) (Database, error) <span class="cov0" title="0">{
        dbConfig := NewDatabaseConfig(cfg)

        switch cfg.Driver </span>{
        case "postgres":<span class="cov0" title="0">
                return NewPostgresDB(dbConfig), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported database driver: %s", cfg.Driver)</span>
        }
}

// NewDatabaseWithConnection creates a new database instance and connects to it
func NewDatabaseWithConnection(ctx context.Context, cfg *config.DatabaseConfig) (Database, error) <span class="cov0" title="0">{
        db, err := NewDatabase(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := db.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "io/ioutil"
        "log"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "time"
)

// Migration represents a database migration
type Migration struct {
        ID          string    `json:"id"`
        Name        string    `json:"name"`
        Description string    `json:"description"`
        SQL         string    `json:"sql"`
        AppliedAt   time.Time `json:"applied_at"`
        Checksum    string    `json:"checksum"`
}

// MigrationSystem handles database migrations
type MigrationSystem struct {
        db     *sql.DB
        config *DatabaseConfig
}

// NewMigrationSystem creates a new migration system
func NewMigrationSystem(db *sql.DB, config *DatabaseConfig) *MigrationSystem <span class="cov0" title="0">{
        return &amp;MigrationSystem{
                db:     db,
                config: config,
        }
}</span>

// InitializeMigrationTable creates the migrations table if it doesn't exist
func (m *MigrationSystem) InitializeMigrationTable(ctx context.Context) error <span class="cov0" title="0">{
        query := `
                CREATE TABLE IF NOT EXISTS migrations (
                        id VARCHAR(255) PRIMARY KEY,
                        name VARCHAR(255) NOT NULL,
                        description TEXT,
                        sql_content TEXT NOT NULL,
                        applied_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
                        checksum VARCHAR(64) NOT NULL,
                        created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
                );
                
                CREATE INDEX IF NOT EXISTS idx_migrations_applied_at ON migrations(applied_at);
        `

        _, err := m.db.ExecContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrations table: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetAppliedMigrations returns all applied migrations
func (m *MigrationSystem) GetAppliedMigrations(ctx context.Context) ([]*Migration, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, sql_content, applied_at, checksum
                FROM migrations
                ORDER BY applied_at ASC
        `

        rows, err := m.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query applied migrations: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var migrations []*Migration
        for rows.Next() </span><span class="cov0" title="0">{
                var migration Migration
                err := rows.Scan(
                        &amp;migration.ID,
                        &amp;migration.Name,
                        &amp;migration.Description,
                        &amp;migration.SQL,
                        &amp;migration.AppliedAt,
                        &amp;migration.Checksum,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan migration: %w", err)
                }</span>
                <span class="cov0" title="0">migrations = append(migrations, &amp;migration)</span>
        }

        <span class="cov0" title="0">return migrations, nil</span>
}

// LoadMigrationFiles loads migration files from the migrations directory
func (m *MigrationSystem) LoadMigrationFiles() ([]*Migration, error) <span class="cov0" title="0">{
        migrationsDir := "internal/database/migrations"

        // Check if migrations directory exists
        if _, err := os.Stat(migrationsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("migrations directory does not exist: %s", migrationsDir)
        }</span>

        <span class="cov0" title="0">files, err := ioutil.ReadDir(migrationsDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read migrations directory: %w", err)
        }</span>

        <span class="cov0" title="0">var migrations []*Migration
        for _, file := range files </span><span class="cov0" title="0">{
                if !file.IsDir() &amp;&amp; strings.HasSuffix(file.Name(), ".sql") </span><span class="cov0" title="0">{
                        migration, err := m.loadMigrationFile(filepath.Join(migrationsDir, file.Name()))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to load migration file %s: %w", file.Name(), err)
                        }</span>
                        <span class="cov0" title="0">migrations = append(migrations, migration)</span>
                }
        }

        // Sort migrations by ID
        <span class="cov0" title="0">sort.Slice(migrations, func(i, j int) bool </span><span class="cov0" title="0">{
                return migrations[i].ID &lt; migrations[j].ID
        }</span>)

        <span class="cov0" title="0">return migrations, nil</span>
}

// loadMigrationFile loads a single migration file
func (m *MigrationSystem) loadMigrationFile(filePath string) (*Migration, error) <span class="cov0" title="0">{
        content, err := ioutil.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read migration file: %w", err)
        }</span>

        <span class="cov0" title="0">filename := filepath.Base(filePath)
        // Extract migration ID from filename (e.g., "001_initial_schema.sql" -&gt; "001")
        parts := strings.Split(filename, "_")
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid migration filename format: %s", filename)
        }</span>

        <span class="cov0" title="0">migrationID := parts[0]

        // Extract description from filename
        description := strings.TrimSuffix(strings.Join(parts[1:], "_"), ".sql")
        description = strings.ReplaceAll(description, "_", " ")

        migration := &amp;Migration{
                ID:          migrationID,
                Name:        filename,
                Description: description,
                SQL:         string(content),
                Checksum:    calculateChecksum(string(content)),
        }

        return migration, nil</span>
}

// calculateChecksum calculates a simple checksum for migration content
func calculateChecksum(content string) string <span class="cov8" title="1">{
        // Simple hash function for demonstration
        // In production, you might want to use a proper hash function
        hash := 0
        for _, char := range content </span><span class="cov8" title="1">{
                hash = (hash*31 + int(char)) % 1000000007
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%08x", hash)</span>
}

// ApplyMigration applies a single migration
func (m *MigrationSystem) ApplyMigration(ctx context.Context, migration *Migration) error <span class="cov0" title="0">{
        // Check if migration is already applied
        applied, err := m.IsMigrationApplied(ctx, migration.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check if migration is applied: %w", err)
        }</span>

        <span class="cov0" title="0">if applied </span><span class="cov0" title="0">{
                log.Printf("Migration %s is already applied, skipping", migration.ID)
                return nil
        }</span>

        // Begin transaction
        <span class="cov0" title="0">tx, err := m.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Execute migration SQL
        _, err = tx.ExecContext(ctx, migration.SQL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute migration %s: %w", migration.ID, err)
        }</span>

        // Record migration as applied
        <span class="cov0" title="0">insertQuery := `
                INSERT INTO migrations (id, name, description, sql_content, checksum)
                VALUES ($1, $2, $3, $4, $5)
        `

        _, err = tx.ExecContext(ctx, insertQuery,
                migration.ID,
                migration.Name,
                migration.Description,
                migration.SQL,
                migration.Checksum,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to record migration %s: %w", migration.ID, err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit migration %s: %w", migration.ID, err)
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully applied migration %s: %s", migration.ID, migration.Description)
        return nil</span>
}

// IsMigrationApplied checks if a migration is already applied
func (m *MigrationSystem) IsMigrationApplied(ctx context.Context, migrationID string) (bool, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM migrations WHERE id = $1`

        var count int
        err := m.db.QueryRowContext(ctx, query, migrationID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check migration status: %w", err)
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// RunMigrations runs all pending migrations
func (m *MigrationSystem) RunMigrations(ctx context.Context) error <span class="cov0" title="0">{
        // Initialize migration table
        if err := m.InitializeMigrationTable(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize migration table: %w", err)
        }</span>

        // Load migration files
        <span class="cov0" title="0">migrations, err := m.LoadMigrationFiles()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load migration files: %w", err)
        }</span>

        // Get applied migrations
        <span class="cov0" title="0">appliedMigrations, err := m.GetAppliedMigrations(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get applied migrations: %w", err)
        }</span>

        // Create a map of applied migration IDs for quick lookup
        <span class="cov0" title="0">appliedMap := make(map[string]bool)
        for _, applied := range appliedMigrations </span><span class="cov0" title="0">{
                appliedMap[applied.ID] = true
        }</span>

        // Apply pending migrations
        <span class="cov0" title="0">for _, migration := range migrations </span><span class="cov0" title="0">{
                if !appliedMap[migration.ID] </span><span class="cov0" title="0">{
                        if err := m.ApplyMigration(ctx, migration); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to apply migration %s: %w", migration.ID, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">log.Printf("All migrations completed successfully")
        return nil</span>
}

// RollbackMigration rolls back a specific migration
func (m *MigrationSystem) RollbackMigration(ctx context.Context, migrationID string) error <span class="cov0" title="0">{
        // Get migration details
        query := `SELECT id, name, sql_content FROM migrations WHERE id = $1`

        var migration Migration
        err := m.db.QueryRowContext(ctx, query, migrationID).Scan(
                &amp;migration.ID,
                &amp;migration.Name,
                &amp;migration.SQL,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return fmt.Errorf("migration %s not found", migrationID)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get migration details: %w", err)</span>
        }

        // Note: In a real implementation, you would need to implement rollback logic
        // This is a simplified version that just removes the migration record
        // For production, you'd want to implement proper rollback SQL

        <span class="cov0" title="0">log.Printf("Rolling back migration %s: %s", migration.ID, migration.Name)

        // Begin transaction
        tx, err := m.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Remove migration record
        deleteQuery := `DELETE FROM migrations WHERE id = $1`
        _, err = tx.ExecContext(ctx, deleteQuery, migrationID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove migration record: %w", err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit rollback: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully rolled back migration %s", migrationID)
        return nil</span>
}

// GetMigrationStatus returns the status of all migrations
func (m *MigrationSystem) GetMigrationStatus(ctx context.Context) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Load all migration files
        allMigrations, err := m.LoadMigrationFiles()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load migration files: %w", err)
        }</span>

        // Get applied migrations
        <span class="cov0" title="0">appliedMigrations, err := m.GetAppliedMigrations(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get applied migrations: %w", err)
        }</span>

        // Create a map of applied migration IDs
        <span class="cov0" title="0">appliedMap := make(map[string]*Migration)
        for _, applied := range appliedMigrations </span><span class="cov0" title="0">{
                appliedMap[applied.ID] = applied
        }</span>

        // Build status report
        <span class="cov0" title="0">status := map[string]interface{}{
                "total_migrations":   len(allMigrations),
                "applied_migrations": len(appliedMigrations),
                "pending_migrations": len(allMigrations) - len(appliedMigrations),
                "migrations":         []map[string]interface{}{},
                "last_applied":       nil,
                "last_applied_at":    nil,
        }

        var lastApplied *Migration
        for _, migration := range allMigrations </span><span class="cov0" title="0">{
                migrationStatus := map[string]interface{}{
                        "id":          migration.ID,
                        "name":        migration.Name,
                        "description": migration.Description,
                        "applied":     false,
                        "applied_at":  nil,
                }

                if applied, exists := appliedMap[migration.ID]; exists </span><span class="cov0" title="0">{
                        migrationStatus["applied"] = true
                        migrationStatus["applied_at"] = applied.AppliedAt
                        lastApplied = applied
                }</span>

                <span class="cov0" title="0">status["migrations"] = append(status["migrations"].([]map[string]interface{}), migrationStatus)</span>
        }

        <span class="cov0" title="0">if lastApplied != nil </span><span class="cov0" title="0">{
                status["last_applied"] = lastApplied.ID
                status["last_applied_at"] = lastApplied.AppliedAt
        }</span>

        <span class="cov0" title="0">return status, nil</span>
}

// CreateMigrationFile creates a new migration file
func (m *MigrationSystem) CreateMigrationFile(name, description string) error <span class="cov0" title="0">{
        migrationsDir := "internal/database/migrations"

        // Get the next migration ID
        files, err := ioutil.ReadDir(migrationsDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read migrations directory: %w", err)
        }</span>

        <span class="cov0" title="0">nextID := 1
        for _, file := range files </span><span class="cov0" title="0">{
                if !file.IsDir() &amp;&amp; strings.HasSuffix(file.Name(), ".sql") </span><span class="cov0" title="0">{
                        parts := strings.Split(file.Name(), "_")
                        if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                                var id int
                                if _, err := fmt.Sscanf(parts[0], "%d", &amp;id); err == nil </span><span class="cov0" title="0">{
                                        if id &gt;= nextID </span><span class="cov0" title="0">{
                                                nextID = id + 1
                                        }</span>
                                }
                        }
                }
        }

        // Create migration filename
        <span class="cov0" title="0">filename := fmt.Sprintf("%03d_%s.sql", nextID, strings.ToLower(strings.ReplaceAll(name, " ", "_")))
        filepath := filepath.Join(migrationsDir, filename)

        // Create migration content
        content := fmt.Sprintf(`-- Migration: %s
-- Description: %s
-- Created: %s

-- Add your migration SQL here
-- Example:
-- CREATE TABLE example_table (
--     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
--     name VARCHAR(255) NOT NULL,
--     created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
-- );

`, filename, description, time.Now().Format("2006-01-02"))

        // Write migration file
        err = ioutil.WriteFile(filepath, []byte(content), 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migration file: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Created migration file: %s", filepath)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package database

import (
        "context"
        "errors"
        "time"

        "github.com/pcraw4d/business-verification/internal/config"
)

// Common database errors
var (
        ErrUserNotFound           = errors.New("user not found")
        ErrRoleAssignmentNotFound = errors.New("role assignment not found")
        ErrAPIKeyNotFound         = errors.New("api key not found")
        ErrDuplicateUser          = errors.New("user already exists")
        ErrInvalidCredentials     = errors.New("invalid credentials")
)

// User represents a user in the system
type User struct {
        ID                  string     `json:"id" db:"id"`
        Email               string     `json:"email" db:"email"`
        Username            string     `json:"username" db:"username"`
        PasswordHash        string     `json:"-" db:"password_hash"`
        FirstName           string     `json:"first_name" db:"first_name"`
        LastName            string     `json:"last_name" db:"last_name"`
        Company             string     `json:"company" db:"company"`
        Role                string     `json:"role" db:"role"`
        Status              string     `json:"status" db:"status"`
        EmailVerified       bool       `json:"email_verified" db:"email_verified"`
        LastLoginAt         *time.Time `json:"last_login_at" db:"last_login_at"`
        FailedLoginAttempts int        `json:"failed_login_attempts" db:"failed_login_attempts"`
        LockedUntil         *time.Time `json:"locked_until" db:"locked_until"`
        CreatedAt           time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt           time.Time  `json:"updated_at" db:"updated_at"`
}

// Business represents a business entity
type Business struct {
        ID                 string      `json:"id" db:"id"`
        Name               string      `json:"name" db:"name"`
        LegalName          string      `json:"legal_name" db:"legal_name"`
        RegistrationNumber string      `json:"registration_number" db:"registration_number"`
        TaxID              string      `json:"tax_id" db:"tax_id"`
        Industry           string      `json:"industry" db:"industry"`
        IndustryCode       string      `json:"industry_code" db:"industry_code"`
        BusinessType       string      `json:"business_type" db:"business_type"`
        FoundedDate        *time.Time  `json:"founded_date" db:"founded_date"`
        EmployeeCount      int         `json:"employee_count" db:"employee_count"`
        AnnualRevenue      *float64    `json:"annual_revenue" db:"annual_revenue"`
        Address            Address     `json:"address" db:"address"`
        ContactInfo        ContactInfo `json:"contact_info" db:"contact_info"`
        Status             string      `json:"status" db:"status"`
        RiskLevel          string      `json:"risk_level" db:"risk_level"`
        ComplianceStatus   string      `json:"compliance_status" db:"compliance_status"`
        CreatedBy          string      `json:"created_by" db:"created_by"`
        CreatedAt          time.Time   `json:"created_at" db:"created_at"`
        UpdatedAt          time.Time   `json:"updated_at" db:"updated_at"`
}

// Address represents a business address
type Address struct {
        Street1     string `json:"street1" db:"street1"`
        Street2     string `json:"street2" db:"street2"`
        City        string `json:"city" db:"city"`
        State       string `json:"state" db:"state"`
        PostalCode  string `json:"postal_code" db:"postal_code"`
        Country     string `json:"country" db:"country"`
        CountryCode string `json:"country_code" db:"country_code"`
}

// ContactInfo represents business contact information
type ContactInfo struct {
        Phone          string `json:"phone" db:"phone"`
        Email          string `json:"email" db:"email"`
        Website        string `json:"website" db:"website"`
        PrimaryContact string `json:"primary_contact" db:"primary_contact"`
}

// BusinessClassification represents a business classification result
type BusinessClassification struct {
        ID                   string    `json:"id" db:"id"`
        BusinessID           string    `json:"business_id" db:"business_id"`
        IndustryCode         string    `json:"industry_code" db:"industry_code"`
        IndustryName         string    `json:"industry_name" db:"industry_name"`
        ConfidenceScore      float64   `json:"confidence_score" db:"confidence_score"`
        ClassificationMethod string    `json:"classification_method" db:"classification_method"`
        Source               string    `json:"source" db:"source"`
        RawData              string    `json:"raw_data" db:"raw_data"`
        CreatedAt            time.Time `json:"created_at" db:"created_at"`
}

// RiskAssessment represents a comprehensive risk assessment result
type RiskAssessment struct {
        ID               string                 `json:"id" db:"id"`
        BusinessID       string                 `json:"business_id" db:"business_id"`
        BusinessName     string                 `json:"business_name" db:"business_name"`
        OverallScore     float64                `json:"overall_score" db:"overall_score"`
        OverallLevel     string                 `json:"overall_level" db:"overall_level"`
        CategoryScores   map[string]interface{} `json:"category_scores" db:"category_scores"` // JSON
        FactorScores     []string               `json:"factor_scores" db:"factor_scores"`     // JSON array
        Recommendations  []string               `json:"recommendations" db:"recommendations"` // JSON array
        Predictions      []string               `json:"predictions" db:"predictions"`         // JSON array
        Alerts           []string               `json:"alerts" db:"alerts"`                   // JSON array
        AssessmentMethod string                 `json:"assessment_method" db:"assessment_method"`
        Source           string                 `json:"source" db:"source"`
        Metadata         map[string]interface{} `json:"metadata" db:"metadata"` // JSON
        AssessedAt       time.Time              `json:"assessed_at" db:"assessed_at"`
        ValidUntil       time.Time              `json:"valid_until" db:"valid_until"`
        CreatedAt        time.Time              `json:"created_at" db:"created_at"`
        UpdatedAt        time.Time              `json:"updated_at" db:"updated_at"`
}

// ComplianceCheck represents a compliance check result
type ComplianceCheck struct {
        ID             string    `json:"id" db:"id"`
        BusinessID     string    `json:"business_id" db:"business_id"`
        ComplianceType string    `json:"compliance_type" db:"compliance_type"`
        Status         string    `json:"status" db:"status"`
        Score          float64   `json:"score" db:"score"`
        Requirements   []string  `json:"requirements" db:"requirements"`
        CheckMethod    string    `json:"check_method" db:"check_method"`
        Source         string    `json:"source" db:"source"`
        RawData        string    `json:"raw_data" db:"raw_data"`
        CreatedAt      time.Time `json:"created_at" db:"created_at"`
}

// APIKey represents an API key for external integrations
type APIKey struct {
        ID          string     `json:"id" db:"id"`
        UserID      string     `json:"user_id" db:"user_id"`
        Name        string     `json:"name" db:"name"`
        KeyHash     string     `json:"-" db:"key_hash"`
        Role        string     `json:"role" db:"role"`
        Permissions string     `json:"permissions" db:"permissions"` // JSON array as string
        Status      string     `json:"status" db:"status"`
        LastUsedAt  *time.Time `json:"last_used_at" db:"last_used_at"`
        ExpiresAt   *time.Time `json:"expires_at" db:"expires_at"`
        CreatedAt   time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt   time.Time  `json:"updated_at" db:"updated_at"`
}

// RoleAssignment represents a user's role assignment with audit trail
type RoleAssignment struct {
        ID         string     `json:"id" db:"id"`
        UserID     string     `json:"user_id" db:"user_id"`
        Role       string     `json:"role" db:"role"`
        AssignedBy string     `json:"assigned_by" db:"assigned_by"` // User ID who assigned the role
        AssignedAt time.Time  `json:"assigned_at" db:"assigned_at"`
        ExpiresAt  *time.Time `json:"expires_at" db:"expires_at"` // Optional role expiration
        IsActive   bool       `json:"is_active" db:"is_active"`
        CreatedAt  time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt  time.Time  `json:"updated_at" db:"updated_at"`
}

// AuditLog represents an audit log entry
type AuditLog struct {
        ID           string    `json:"id" db:"id"`
        UserID       string    `json:"user_id" db:"user_id"`
        Action       string    `json:"action" db:"action"`
        ResourceType string    `json:"resource_type" db:"resource_type"`
        ResourceID   string    `json:"resource_id" db:"resource_id"`
        Details      string    `json:"details" db:"details"`
        IPAddress    string    `json:"ip_address" db:"ip_address"`
        UserAgent    string    `json:"user_agent" db:"user_agent"`
        RequestID    string    `json:"request_id" db:"request_id"`
        CreatedAt    time.Time `json:"created_at" db:"created_at"`
}

// ExternalServiceCall represents an external service API call
type ExternalServiceCall struct {
        ID           string    `json:"id" db:"id"`
        UserID       string    `json:"user_id" db:"user_id"`
        ServiceName  string    `json:"service_name" db:"service_name"`
        Endpoint     string    `json:"endpoint" db:"endpoint"`
        Method       string    `json:"method" db:"method"`
        RequestData  string    `json:"request_data" db:"request_data"`
        ResponseData string    `json:"response_data" db:"response_data"`
        StatusCode   int       `json:"status_code" db:"status_code"`
        Duration     int64     `json:"duration_ms" db:"duration_ms"`
        Error        string    `json:"error" db:"error"`
        RequestID    string    `json:"request_id" db:"request_id"`
        CreatedAt    time.Time `json:"created_at" db:"created_at"`
}

// Webhook represents a webhook configuration
type Webhook struct {
        ID              string     `json:"id" db:"id"`
        UserID          string     `json:"user_id" db:"user_id"`
        Name            string     `json:"name" db:"name"`
        URL             string     `json:"url" db:"url"`
        Events          []string   `json:"events" db:"events"`
        Secret          string     `json:"-" db:"secret"`
        Status          string     `json:"status" db:"status"`
        LastTriggeredAt *time.Time `json:"last_triggered_at" db:"last_triggered_at"`
        CreatedAt       time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt       time.Time  `json:"updated_at" db:"updated_at"`
}

// WebhookEvent represents a webhook event
type WebhookEvent struct {
        ID           string     `json:"id" db:"id"`
        WebhookID    string     `json:"webhook_id" db:"webhook_id"`
        EventType    string     `json:"event_type" db:"event_type"`
        Payload      string     `json:"payload" db:"payload"`
        Status       string     `json:"status" db:"status"`
        ResponseCode *int       `json:"response_code" db:"response_code"`
        ResponseBody string     `json:"response_body" db:"response_body"`
        Attempts     int        `json:"attempts" db:"attempts"`
        NextRetryAt  *time.Time `json:"next_retry_at" db:"next_retry_at"`
        CreatedAt    time.Time  `json:"created_at" db:"created_at"`
}

// EmailVerificationToken represents an email verification token
type EmailVerificationToken struct {
        ID        string     `json:"id" db:"id"`
        UserID    string     `json:"user_id" db:"user_id"`
        Token     string     `json:"token" db:"token"`
        ExpiresAt time.Time  `json:"expires_at" db:"expires_at"`
        UsedAt    *time.Time `json:"used_at" db:"used_at"`
        CreatedAt time.Time  `json:"created_at" db:"created_at"`
}

// PasswordResetToken represents a password reset token
type PasswordResetToken struct {
        ID        string     `json:"id" db:"id"`
        UserID    string     `json:"user_id" db:"user_id"`
        Token     string     `json:"token" db:"token"`
        ExpiresAt time.Time  `json:"expires_at" db:"expires_at"`
        UsedAt    *time.Time `json:"used_at" db:"used_at"`
        CreatedAt time.Time  `json:"created_at" db:"created_at"`
}

// TokenBlacklist represents a blacklisted JWT token
type TokenBlacklist struct {
        ID            string    `json:"id" db:"id"`
        TokenID       string    `json:"token_id" db:"token_id"`
        UserID        *string   `json:"user_id" db:"user_id"`
        ExpiresAt     time.Time `json:"expires_at" db:"expires_at"`
        BlacklistedAt time.Time `json:"blacklisted_at" db:"blacklisted_at"`
        Reason        string    `json:"reason" db:"reason"`
}

// Database represents the database interface
type Database interface {
        // Connection management
        Connect(ctx context.Context) error
        Close() error
        Ping(ctx context.Context) error

        // User management
        CreateUser(ctx context.Context, user *User) error
        GetUserByID(ctx context.Context, id string) (*User, error)
        GetUserByEmail(ctx context.Context, email string) (*User, error)
        UpdateUser(ctx context.Context, user *User) error
        DeleteUser(ctx context.Context, id string) error
        ListUsers(ctx context.Context, limit, offset int) ([]*User, error)

        // Email verification management
        CreateEmailVerificationToken(ctx context.Context, token *EmailVerificationToken) error
        GetEmailVerificationToken(ctx context.Context, token string) (*EmailVerificationToken, error)
        MarkEmailVerificationTokenUsed(ctx context.Context, token string) error
        DeleteExpiredEmailVerificationTokens(ctx context.Context) error

        // Password reset management
        CreatePasswordResetToken(ctx context.Context, token *PasswordResetToken) error
        GetPasswordResetToken(ctx context.Context, token string) (*PasswordResetToken, error)
        MarkPasswordResetTokenUsed(ctx context.Context, token string) error
        DeleteExpiredPasswordResetTokens(ctx context.Context) error

        // Token blacklist management
        CreateTokenBlacklist(ctx context.Context, blacklist *TokenBlacklist) error
        IsTokenBlacklisted(ctx context.Context, tokenID string) (bool, error)
        DeleteExpiredTokenBlacklist(ctx context.Context) error

        // Business management
        CreateBusiness(ctx context.Context, business *Business) error
        GetBusinessByID(ctx context.Context, id string) (*Business, error)
        GetBusinessByRegistrationNumber(ctx context.Context, regNumber string) (*Business, error)
        UpdateBusiness(ctx context.Context, business *Business) error
        DeleteBusiness(ctx context.Context, id string) error
        ListBusinesses(ctx context.Context, limit, offset int) ([]*Business, error)
        SearchBusinesses(ctx context.Context, query string, limit, offset int) ([]*Business, error)

        // Classification management
        CreateBusinessClassification(ctx context.Context, classification *BusinessClassification) error
        GetBusinessClassificationByID(ctx context.Context, id string) (*BusinessClassification, error)
        GetBusinessClassificationsByBusinessID(ctx context.Context, businessID string) ([]*BusinessClassification, error)
        UpdateBusinessClassification(ctx context.Context, classification *BusinessClassification) error
        DeleteBusinessClassification(ctx context.Context, id string) error

        // Risk assessment management
        CreateRiskAssessment(ctx context.Context, assessment *RiskAssessment) error
        GetRiskAssessmentByID(ctx context.Context, id string) (*RiskAssessment, error)
        GetRiskAssessmentsByBusinessID(ctx context.Context, businessID string) ([]*RiskAssessment, error)
        UpdateRiskAssessment(ctx context.Context, assessment *RiskAssessment) error
        DeleteRiskAssessment(ctx context.Context, id string) error

        // Enhanced risk history tracking
        GetRiskAssessmentHistory(ctx context.Context, businessID string, limit, offset int) ([]*RiskAssessment, error)
        GetRiskAssessmentHistoryByDateRange(ctx context.Context, businessID string, startDate, endDate time.Time) ([]*RiskAssessment, error)
        GetLatestRiskAssessment(ctx context.Context, businessID string) (*RiskAssessment, error)
        GetRiskAssessmentTrends(ctx context.Context, businessID string, days int) ([]*RiskAssessment, error)
        GetRiskAssessmentsByLevel(ctx context.Context, businessID string, riskLevel string) ([]*RiskAssessment, error)
        GetRiskAssessmentsByScoreRange(ctx context.Context, businessID string, minScore, maxScore float64) ([]*RiskAssessment, error)
        GetRiskAssessmentStatistics(ctx context.Context, businessID string) (map[string]interface{}, error)

        // Compliance management
        CreateComplianceCheck(ctx context.Context, check *ComplianceCheck) error
        GetComplianceCheckByID(ctx context.Context, id string) (*ComplianceCheck, error)
        GetComplianceChecksByBusinessID(ctx context.Context, businessID string) ([]*ComplianceCheck, error)
        UpdateComplianceCheck(ctx context.Context, check *ComplianceCheck) error
        DeleteComplianceCheck(ctx context.Context, id string) error

        // API key management
        CreateAPIKey(ctx context.Context, apiKey *APIKey) error
        GetAPIKeyByID(ctx context.Context, id string) (*APIKey, error)
        GetAPIKeyByHash(ctx context.Context, keyHash string) (*APIKey, error)
        UpdateAPIKey(ctx context.Context, apiKey *APIKey) error
        DeleteAPIKey(ctx context.Context, id string) error
        ListAPIKeysByUserID(ctx context.Context, userID string) ([]*APIKey, error)

        // Audit log management
        CreateAuditLog(ctx context.Context, log *AuditLog) error
        GetAuditLogsByUserID(ctx context.Context, userID string, limit, offset int) ([]*AuditLog, error)
        GetAuditLogsByResource(ctx context.Context, resourceType, resourceID string, limit, offset int) ([]*AuditLog, error)

        // External service call management
        CreateExternalServiceCall(ctx context.Context, call *ExternalServiceCall) error
        GetExternalServiceCallsByUserID(ctx context.Context, userID string, limit, offset int) ([]*ExternalServiceCall, error)
        GetExternalServiceCallsByService(ctx context.Context, serviceName string, limit, offset int) ([]*ExternalServiceCall, error)

        // Webhook management
        CreateWebhook(ctx context.Context, webhook *Webhook) error
        GetWebhookByID(ctx context.Context, id string) (*Webhook, error)
        GetWebhooksByUserID(ctx context.Context, userID string) ([]*Webhook, error)
        UpdateWebhook(ctx context.Context, webhook *Webhook) error
        DeleteWebhook(ctx context.Context, id string) error

        // Webhook event management
        CreateWebhookEvent(ctx context.Context, event *WebhookEvent) error
        GetWebhookEventByID(ctx context.Context, id string) (*WebhookEvent, error)
        GetWebhookEventsByWebhookID(ctx context.Context, webhookID string, limit, offset int) ([]*WebhookEvent, error)
        UpdateWebhookEvent(ctx context.Context, event *WebhookEvent) error
        DeleteWebhookEvent(ctx context.Context, id string) error

        // Role assignment management
        CreateRoleAssignment(ctx context.Context, assignment *RoleAssignment) error
        GetRoleAssignmentByID(ctx context.Context, id string) (*RoleAssignment, error)
        GetActiveRoleAssignmentByUserID(ctx context.Context, userID string) (*RoleAssignment, error)
        GetRoleAssignmentsByUserID(ctx context.Context, userID string) ([]*RoleAssignment, error)
        UpdateRoleAssignment(ctx context.Context, assignment *RoleAssignment) error
        DeactivateRoleAssignment(ctx context.Context, id string) error
        DeleteExpiredRoleAssignments(ctx context.Context) error

        // Enhanced API key management with RBAC
        UpdateAPIKeyLastUsed(ctx context.Context, id string, lastUsed time.Time) error
        GetActiveAPIKeysByRole(ctx context.Context, role string) ([]*APIKey, error)
        DeactivateAPIKey(ctx context.Context, id string) error

        // Transaction support
        BeginTx(ctx context.Context) (Database, error)
        Commit() error
        Rollback() error
}

// DatabaseConfig holds database configuration
type DatabaseConfig struct {
        *config.DatabaseConfig
}

// NewDatabaseConfig creates a new database configuration
func NewDatabaseConfig(cfg *config.DatabaseConfig) *DatabaseConfig <span class="cov8" title="1">{
        return &amp;DatabaseConfig{
                DatabaseConfig: cfg,
        }
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "log"
        "sync"
        "time"
)

// DatabaseMetrics represents database performance metrics
type DatabaseMetrics struct {
        Timestamp         time.Time              `json:"timestamp"`
        ConnectionCount   int                    `json:"connection_count"`
        ActiveConnections int                    `json:"active_connections"`
        IdleConnections   int                    `json:"idle_connections"`
        MaxConnections    int                    `json:"max_connections"`
        QueryCount        int64                  `json:"query_count"`
        SlowQueryCount    int64                  `json:"slow_query_count"`
        ErrorCount        int64                  `json:"error_count"`
        AvgQueryTime      float64                `json:"avg_query_time_ms"`
        MaxQueryTime      float64                `json:"max_query_time_ms"`
        DatabaseSize      int64                  `json:"database_size_bytes"`
        TableSizes        map[string]int64       `json:"table_sizes"`
        IndexSizes        map[string]int64       `json:"index_sizes"`
        LockCount         int                    `json:"lock_count"`
        DeadlockCount     int                    `json:"deadlock_count"`
        CacheHitRatio     float64                `json:"cache_hit_ratio"`
        Uptime            time.Duration          `json:"uptime"`
        LastBackup        *time.Time             `json:"last_backup,omitempty"`
        BackupSize        int64                  `json:"backup_size_bytes"`
        Metadata          map[string]interface{} `json:"metadata,omitempty"`
}

// DatabaseMonitor handles database monitoring
type DatabaseMonitor struct {
        db                 *sql.DB
        config             *DatabaseConfig
        metrics            []*DatabaseMetrics
        maxMetrics         int
        slowQueryThreshold time.Duration
        mu                 sync.RWMutex
        queryStats         map[string]*QueryStats
}

// QueryStats tracks statistics for individual queries
type QueryStats struct {
        Count      int64         `json:"count"`
        TotalTime  time.Duration `json:"total_time"`
        AvgTime    time.Duration `json:"avg_time"`
        MaxTime    time.Duration `json:"max_time"`
        MinTime    time.Duration `json:"min_time"`
        ErrorCount int64         `json:"error_count"`
        LastSeen   time.Time     `json:"last_seen"`
}

// NewDatabaseMonitor creates a new database monitor
func NewDatabaseMonitor(db *sql.DB, config *DatabaseConfig) *DatabaseMonitor <span class="cov0" title="0">{
        return &amp;DatabaseMonitor{
                db:                 db,
                config:             config,
                metrics:            make([]*DatabaseMetrics, 0),
                maxMetrics:         1000, // Keep last 1000 metrics
                slowQueryThreshold: 100 * time.Millisecond,
                queryStats:         make(map[string]*QueryStats),
        }
}</span>

// CollectMetrics collects current database metrics
func (m *DatabaseMonitor) CollectMetrics(ctx context.Context) (*DatabaseMetrics, error) <span class="cov0" title="0">{
        metrics := &amp;DatabaseMetrics{
                Timestamp:  time.Now(),
                TableSizes: make(map[string]int64),
                IndexSizes: make(map[string]int64),
                Metadata:   make(map[string]interface{}),
        }

        // Get connection pool stats
        stats := m.db.Stats()
        metrics.ConnectionCount = stats.OpenConnections
        metrics.MaxConnections = stats.MaxOpenConnections
        metrics.ActiveConnections = stats.InUse
        metrics.IdleConnections = stats.Idle

        // Get database size
        if size, err := m.getDatabaseSize(ctx); err == nil </span><span class="cov0" title="0">{
                metrics.DatabaseSize = size
        }</span>

        // Get table sizes
        <span class="cov0" title="0">if tableSizes, err := m.getTableSizes(ctx); err == nil </span><span class="cov0" title="0">{
                metrics.TableSizes = tableSizes
        }</span>

        // Get index sizes
        <span class="cov0" title="0">if indexSizes, err := m.getIndexSizes(ctx); err == nil </span><span class="cov0" title="0">{
                metrics.IndexSizes = indexSizes
        }</span>

        // Get cache hit ratio
        <span class="cov0" title="0">if hitRatio, err := m.getCacheHitRatio(ctx); err == nil </span><span class="cov0" title="0">{
                metrics.CacheHitRatio = hitRatio
        }</span>

        // Get lock information
        <span class="cov0" title="0">if lockCount, err := m.getLockCount(ctx); err == nil </span><span class="cov0" title="0">{
                metrics.LockCount = lockCount
        }</span>

        // Get uptime
        <span class="cov0" title="0">if uptime, err := m.getUptime(ctx); err == nil </span><span class="cov0" title="0">{
                metrics.Uptime = uptime
        }</span>

        // Calculate query statistics
        <span class="cov0" title="0">m.calculateQueryStats(metrics)

        // Store metrics
        m.storeMetrics(metrics)

        return metrics, nil</span>
}

// GetMetrics returns collected metrics
func (m *DatabaseMonitor) GetMetrics(limit int) []*DatabaseMetrics <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if limit &lt;= 0 || limit &gt; len(m.metrics) </span><span class="cov0" title="0">{
                limit = len(m.metrics)
        }</span>

        <span class="cov0" title="0">start := len(m.metrics) - limit
        if start &lt; 0 </span><span class="cov0" title="0">{
                start = 0
        }</span>

        <span class="cov0" title="0">result := make([]*DatabaseMetrics, limit)
        copy(result, m.metrics[start:])
        return result</span>
}

// GetLatestMetrics returns the most recent metrics
func (m *DatabaseMonitor) GetLatestMetrics() *DatabaseMetrics <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if len(m.metrics) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return m.metrics[len(m.metrics)-1]</span>
}

// GetMetricsSummary returns a summary of metrics
func (m *DatabaseMonitor) GetMetricsSummary() map[string]interface{} <span class="cov0" title="0">{
        metrics := m.GetMetrics(100) // Last 100 metrics
        if len(metrics) == 0 </span><span class="cov0" title="0">{
                return map[string]interface{}{
                        "message": "No metrics available",
                }
        }</span>

        // Calculate averages
        <span class="cov0" title="0">var totalConnections, totalQueries, totalErrors int64
        var totalQueryTime float64
        var slowQueries int64

        for _, metric := range metrics </span><span class="cov0" title="0">{
                totalConnections += int64(metric.ConnectionCount)
                totalQueries += metric.QueryCount
                totalErrors += metric.ErrorCount
                totalQueryTime += metric.AvgQueryTime
                slowQueries += metric.SlowQueryCount
        }</span>

        <span class="cov0" title="0">count := int64(len(metrics))
        avgConnections := float64(totalConnections) / float64(count)
        avgQueries := float64(totalQueries) / float64(count)
        avgErrors := float64(totalErrors) / float64(count)
        avgQueryTime := totalQueryTime / float64(count)

        // Get latest metrics for current values
        latest := metrics[len(metrics)-1]

        summary := map[string]interface{}{
                "period": map[string]interface{}{
                        "start":    metrics[0].Timestamp,
                        "end":      latest.Timestamp,
                        "duration": latest.Timestamp.Sub(metrics[0].Timestamp),
                },
                "averages": map[string]interface{}{
                        "connections":        avgConnections,
                        "queries_per_second": avgQueries,
                        "errors_per_second":  avgErrors,
                        "avg_query_time_ms":  avgQueryTime,
                },
                "current": map[string]interface{}{
                        "connections":        latest.ConnectionCount,
                        "active_connections": latest.ActiveConnections,
                        "idle_connections":   latest.IdleConnections,
                        "max_connections":    latest.MaxConnections,
                        "database_size_mb":   float64(latest.DatabaseSize) / (1024 * 1024),
                        "cache_hit_ratio":    latest.CacheHitRatio,
                        "uptime":             latest.Uptime,
                },
                "totals": map[string]interface{}{
                        "queries":      totalQueries,
                        "errors":       totalErrors,
                        "slow_queries": slowQueries,
                },
                "performance": map[string]interface{}{
                        "slow_query_threshold_ms": m.slowQueryThreshold.Milliseconds(),
                        "max_metrics_stored":      m.maxMetrics,
                },
        }

        return summary</span>
}

// RecordQuery records a query execution for monitoring
func (m *DatabaseMonitor) RecordQuery(query string, duration time.Duration, err error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Create a simple hash of the query for grouping
        queryHash := fmt.Sprintf("%d", len(query)) // Simplified for demo

        stats, exists := m.queryStats[queryHash]
        if !exists </span><span class="cov0" title="0">{
                stats = &amp;QueryStats{
                        MinTime: duration,
                }
                m.queryStats[queryHash] = stats
        }</span>

        <span class="cov0" title="0">stats.Count++
        stats.TotalTime += duration
        stats.AvgTime = stats.TotalTime / time.Duration(stats.Count)
        stats.LastSeen = time.Now()

        if duration &gt; stats.MaxTime </span><span class="cov0" title="0">{
                stats.MaxTime = duration
        }</span>
        <span class="cov0" title="0">if duration &lt; stats.MinTime </span><span class="cov0" title="0">{
                stats.MinTime = duration
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                stats.ErrorCount++
        }</span>
}

// GetQueryStats returns query statistics
func (m *DatabaseMonitor) GetQueryStats() map[string]*QueryStats <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        result := make(map[string]*QueryStats)
        for k, v := range m.queryStats </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov0" title="0">return result</span>
}

// SetSlowQueryThreshold sets the threshold for slow queries
func (m *DatabaseMonitor) SetSlowQueryThreshold(threshold time.Duration) <span class="cov0" title="0">{
        m.slowQueryThreshold = threshold
}</span>

// GetSlowQueries returns queries that exceed the slow query threshold
func (m *DatabaseMonitor) GetSlowQueries() []*QueryStats <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var slowQueries []*QueryStats
        for _, stats := range m.queryStats </span><span class="cov0" title="0">{
                if stats.AvgTime &gt; m.slowQueryThreshold </span><span class="cov0" title="0">{
                        slowQueries = append(slowQueries, stats)
                }</span>
        }

        <span class="cov0" title="0">return slowQueries</span>
}

// ClearMetrics clears all stored metrics
func (m *DatabaseMonitor) ClearMetrics() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.metrics = make([]*DatabaseMetrics, 0)
        m.queryStats = make(map[string]*QueryStats)
}</span>

// storeMetrics stores metrics with size limit
func (m *DatabaseMonitor) storeMetrics(metrics *DatabaseMetrics) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.metrics = append(m.metrics, metrics)

        // Remove old metrics if we exceed the limit
        if len(m.metrics) &gt; m.maxMetrics </span><span class="cov0" title="0">{
                m.metrics = m.metrics[len(m.metrics)-m.maxMetrics:]
        }</span>
}

// calculateQueryStats calculates query statistics for metrics
func (m *DatabaseMonitor) calculateQueryStats(metrics *DatabaseMetrics) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var totalQueries, totalErrors, slowQueries int64
        var totalTime time.Duration

        for _, stats := range m.queryStats </span><span class="cov0" title="0">{
                totalQueries += stats.Count
                totalErrors += stats.ErrorCount
                totalTime += stats.TotalTime

                if stats.AvgTime &gt; m.slowQueryThreshold </span><span class="cov0" title="0">{
                        slowQueries += stats.Count
                }</span>
        }

        <span class="cov0" title="0">metrics.QueryCount = totalQueries
        metrics.ErrorCount = totalErrors
        metrics.SlowQueryCount = slowQueries

        if totalQueries &gt; 0 </span><span class="cov0" title="0">{
                metrics.AvgQueryTime = float64(totalTime.Milliseconds()) / float64(totalQueries)
        }</span>
}

// getDatabaseSize gets the database size in bytes
func (m *DatabaseMonitor) getDatabaseSize(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        query := `
                SELECT pg_database_size(current_database())
        `

        var size int64
        err := m.db.QueryRowContext(ctx, query).Scan(&amp;size)
        return size, err
}</span>

// getTableSizes gets the size of all tables
func (m *DatabaseMonitor) getTableSizes(ctx context.Context) (map[string]int64, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        schemaname,
                        tablename,
                        pg_total_relation_size(schemaname||'.'||tablename) as size
                FROM pg_tables 
                WHERE schemaname NOT IN ('information_schema', 'pg_catalog')
                ORDER BY size DESC
        `

        rows, err := m.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        sizes := make(map[string]int64)
        for rows.Next() </span><span class="cov0" title="0">{
                var schema, table string
                var size int64
                if err := rows.Scan(&amp;schema, &amp;table, &amp;size); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">tableName := fmt.Sprintf("%s.%s", schema, table)
                sizes[tableName] = size</span>
        }

        <span class="cov0" title="0">return sizes, nil</span>
}

// getIndexSizes gets the size of all indexes
func (m *DatabaseMonitor) getIndexSizes(ctx context.Context) (map[string]int64, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        schemaname,
                        indexname,
                        pg_relation_size(schemaname||'.'||indexname) as size
                FROM pg_indexes 
                WHERE schemaname NOT IN ('information_schema', 'pg_catalog')
                ORDER BY size DESC
        `

        rows, err := m.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        sizes := make(map[string]int64)
        for rows.Next() </span><span class="cov0" title="0">{
                var schema, index string
                var size int64
                if err := rows.Scan(&amp;schema, &amp;index, &amp;size); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">indexName := fmt.Sprintf("%s.%s", schema, index)
                sizes[indexName] = size</span>
        }

        <span class="cov0" title="0">return sizes, nil</span>
}

// getCacheHitRatio gets the cache hit ratio
func (m *DatabaseMonitor) getCacheHitRatio(ctx context.Context) (float64, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        ROUND(100.0 * sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)), 2) as cache_hit_ratio
                FROM pg_statio_user_tables
        `

        var hitRatio float64
        err := m.db.QueryRowContext(ctx, query).Scan(&amp;hitRatio)
        return hitRatio, err
}</span>

// getLockCount gets the number of active locks
func (m *DatabaseMonitor) getLockCount(ctx context.Context) (int, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*) 
                FROM pg_locks 
                WHERE NOT granted
        `

        var count int
        err := m.db.QueryRowContext(ctx, query).Scan(&amp;count)
        return count, err
}</span>

// getUptime gets the database uptime
func (m *DatabaseMonitor) getUptime(ctx context.Context) (time.Duration, error) <span class="cov0" title="0">{
        query := `
                SELECT EXTRACT(EPOCH FROM (now() - pg_postmaster_start_time())) * interval '1 second'
        `

        var uptime time.Duration
        err := m.db.QueryRowContext(ctx, query).Scan(&amp;uptime)
        return uptime, err
}</span>

// StartMonitoring starts continuous monitoring
func (m *DatabaseMonitor) StartMonitoring(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        log.Printf("Starting database monitoring with %v interval", interval)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Println("Stopping database monitoring")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if _, err := m.CollectMetrics(ctx); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to collect metrics: %v", err)
                        }</span>
                }
        }
}

// GetHealthStatus returns the overall health status of the database
func (m *DatabaseMonitor) GetHealthStatus() map[string]interface{} <span class="cov0" title="0">{
        latest := m.GetLatestMetrics()
        if latest == nil </span><span class="cov0" title="0">{
                return map[string]interface{}{
                        "status":  "unknown",
                        "message": "No metrics available",
                }
        }</span>

        // Determine health status based on metrics
        <span class="cov0" title="0">status := "healthy"
        issues := []string{}

        // Check connection pool
        if latest.ConnectionCount &gt;= latest.MaxConnections </span><span class="cov0" title="0">{
                status = "critical"
                issues = append(issues, "Connection pool at maximum capacity")
        }</span> else<span class="cov0" title="0"> if latest.ConnectionCount &gt;= latest.MaxConnections*8/10 </span><span class="cov0" title="0">{
                status = "warning"
                issues = append(issues, "Connection pool nearly full")
        }</span>

        // Check error rate
        <span class="cov0" title="0">if latest.ErrorCount &gt; 0 </span><span class="cov0" title="0">{
                errorRate := float64(latest.ErrorCount) / float64(latest.QueryCount) * 100
                if errorRate &gt; 5 </span><span class="cov0" title="0">{
                        status = "critical"
                        issues = append(issues, fmt.Sprintf("High error rate: %.2f%%", errorRate))
                }</span> else<span class="cov0" title="0"> if errorRate &gt; 1 </span><span class="cov0" title="0">{
                        status = "warning"
                        issues = append(issues, fmt.Sprintf("Elevated error rate: %.2f%%", errorRate))
                }</span>
        }

        // Check slow queries
        <span class="cov0" title="0">if latest.SlowQueryCount &gt; 0 </span><span class="cov0" title="0">{
                slowQueryRate := float64(latest.SlowQueryCount) / float64(latest.QueryCount) * 100
                if slowQueryRate &gt; 10 </span><span class="cov0" title="0">{
                        status = "warning"
                        issues = append(issues, fmt.Sprintf("High slow query rate: %.2f%%", slowQueryRate))
                }</span>
        }

        // Check cache hit ratio
        <span class="cov0" title="0">if latest.CacheHitRatio &lt; 80 </span><span class="cov0" title="0">{
                status = "warning"
                issues = append(issues, fmt.Sprintf("Low cache hit ratio: %.2f%%", latest.CacheHitRatio))
        }</span>

        // Check locks
        <span class="cov0" title="0">if latest.LockCount &gt; 10 </span><span class="cov0" title="0">{
                status = "warning"
                issues = append(issues, fmt.Sprintf("High lock count: %d", latest.LockCount))
        }</span>

        <span class="cov0" title="0">health := map[string]interface{}{
                "status":          status,
                "timestamp":       latest.Timestamp,
                "issues":          issues,
                "metrics":         latest,
                "recommendations": m.getRecommendations(latest),
        }

        return health</span>
}

// getRecommendations returns recommendations based on metrics
func (m *DatabaseMonitor) getRecommendations(metrics *DatabaseMetrics) []string <span class="cov0" title="0">{
        var recommendations []string

        if metrics.ConnectionCount &gt;= metrics.MaxConnections*8/10 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Consider increasing max_connections or optimizing connection usage")
        }</span>

        <span class="cov0" title="0">if metrics.CacheHitRatio &lt; 80 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Consider increasing shared_buffers or optimizing queries")
        }</span>

        <span class="cov0" title="0">if metrics.SlowQueryCount &gt; 0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Review and optimize slow queries")
        }</span>

        <span class="cov0" title="0">if metrics.ErrorCount &gt; 0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Investigate and fix database errors")
        }</span>

        <span class="cov0" title="0">if len(recommendations) == 0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Database performance is good")
        }</span>

        <span class="cov0" title="0">return recommendations</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "encoding/json"

        _ "github.com/lib/pq"
)

// PostgresDB implements the Database interface for PostgreSQL
type PostgresDB struct {
        db     *sql.DB
        config *DatabaseConfig
        tx     *sql.Tx
}

// NewPostgresDB creates a new PostgreSQL database instance
func NewPostgresDB(cfg *DatabaseConfig) *PostgresDB <span class="cov0" title="0">{
        return &amp;PostgresDB{
                config: cfg,
        }
}</span>

// Connect establishes a connection to the PostgreSQL database
func (p *PostgresDB) Connect(ctx context.Context) error <span class="cov0" title="0">{
        dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                p.config.Host,
                p.config.Port,
                p.config.Username,
                p.config.Password,
                p.config.Database,
                p.config.SSLMode,
        )

        db, err := sql.Open("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open database connection: %w", err)
        }</span>

        // Configure connection pool
        <span class="cov0" title="0">db.SetMaxOpenConns(p.config.MaxOpenConns)
        db.SetMaxIdleConns(p.config.MaxIdleConns)
        db.SetConnMaxLifetime(p.config.ConnMaxLifetime)

        // Test the connection
        if err := db.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">p.db = db
        return nil</span>
}

// Close closes the database connection
func (p *PostgresDB) Close() error <span class="cov0" title="0">{
        if p.db != nil </span><span class="cov0" title="0">{
                return p.db.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Ping tests the database connection
func (p *PostgresDB) Ping(ctx context.Context) error <span class="cov0" title="0">{
        if p.db == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database not connected")
        }</span>
        <span class="cov0" title="0">return p.db.PingContext(ctx)</span>
}

// BeginTx starts a new transaction
func (p *PostgresDB) BeginTx(ctx context.Context) (Database, error) <span class="cov0" title="0">{
        if p.db == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database not connected")
        }</span>

        <span class="cov0" title="0">tx, err := p.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to begin transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;PostgresDB{
                db:     p.db,
                config: p.config,
                tx:     tx,
        }, nil</span>
}

// Commit commits the current transaction
func (p *PostgresDB) Commit() error <span class="cov0" title="0">{
        if p.tx == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no active transaction")
        }</span>
        <span class="cov0" title="0">return p.tx.Commit()</span>
}

// Rollback rolls back the current transaction
func (p *PostgresDB) Rollback() error <span class="cov0" title="0">{
        if p.tx == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no active transaction")
        }</span>
        <span class="cov0" title="0">return p.tx.Rollback()</span>
}

// getDB returns the appropriate database connection (transaction or regular)
func (p *PostgresDB) getDB() interface {
        ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
        QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
        QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row
} <span class="cov0" title="0">{
        if p.tx != nil </span><span class="cov0" title="0">{
                return p.tx
        }</span>
        <span class="cov0" title="0">return p.db</span>
}

// CreateUser creates a new user
func (p *PostgresDB) CreateUser(ctx context.Context, user *User) error <span class="cov0" title="0">{
        query := `
                INSERT INTO users (id, email, username, password_hash, first_name, last_name, company, role, status)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        `

        _, err := p.getDB().ExecContext(ctx, query,
                user.ID, user.Email, user.Username, user.PasswordHash,
                user.FirstName, user.LastName, user.Company, user.Role, user.Status)

        return err
}</span>

// GetUserByID retrieves a user by ID
func (p *PostgresDB) GetUserByID(ctx context.Context, id string) (*User, error) <span class="cov0" title="0">{
        query := `SELECT * FROM users WHERE id = $1`

        row := p.getDB().QueryRowContext(ctx, query, id)

        var user User
        err := row.Scan(
                &amp;user.ID, &amp;user.Email, &amp;user.Username, &amp;user.PasswordHash,
                &amp;user.FirstName, &amp;user.LastName, &amp;user.Company, &amp;user.Role, &amp;user.Status,
                &amp;user.EmailVerified, &amp;user.LastLoginAt, &amp;user.FailedLoginAttempts,
                &amp;user.LockedUntil, &amp;user.CreatedAt, &amp;user.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// GetUserByEmail retrieves a user by email
func (p *PostgresDB) GetUserByEmail(ctx context.Context, email string) (*User, error) <span class="cov0" title="0">{
        query := `SELECT * FROM users WHERE email = $1`

        row := p.getDB().QueryRowContext(ctx, query, email)

        var user User
        err := row.Scan(
                &amp;user.ID, &amp;user.Email, &amp;user.Username, &amp;user.PasswordHash,
                &amp;user.FirstName, &amp;user.LastName, &amp;user.Company, &amp;user.Role, &amp;user.Status,
                &amp;user.EmailVerified, &amp;user.LastLoginAt, &amp;user.FailedLoginAttempts,
                &amp;user.LockedUntil, &amp;user.CreatedAt, &amp;user.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// UpdateUser updates an existing user
func (p *PostgresDB) UpdateUser(ctx context.Context, user *User) error <span class="cov0" title="0">{
        query := `
                UPDATE users 
                SET email = $2, username = $3, password_hash = $4, first_name = $5, 
                    last_name = $6, company = $7, role = $8, status = $9, 
                    email_verified = $10, last_login_at = $11, failed_login_attempts = $12,
                    locked_until = $13, updated_at = CURRENT_TIMESTAMP
                WHERE id = $1
        `

        _, err := p.getDB().ExecContext(ctx, query,
                user.ID, user.Email, user.Username, user.PasswordHash,
                user.FirstName, user.LastName, user.Company, user.Role, user.Status,
                user.EmailVerified, user.LastLoginAt, user.FailedLoginAttempts,
                user.LockedUntil)

        return err
}</span>

// DeleteUser deletes a user by ID
func (p *PostgresDB) DeleteUser(ctx context.Context, id string) error <span class="cov0" title="0">{
        query := `DELETE FROM users WHERE id = $1`

        _, err := p.getDB().ExecContext(ctx, query, id)
        return err
}</span>

// ListUsers retrieves a list of users with pagination
func (p *PostgresDB) ListUsers(ctx context.Context, limit, offset int) ([]*User, error) <span class="cov0" title="0">{
        query := `SELECT * FROM users ORDER BY created_at DESC LIMIT $1 OFFSET $2`

        rows, err := p.getDB().QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var users []*User
        for rows.Next() </span><span class="cov0" title="0">{
                var user User
                err := rows.Scan(
                        &amp;user.ID, &amp;user.Email, &amp;user.Username, &amp;user.PasswordHash,
                        &amp;user.FirstName, &amp;user.LastName, &amp;user.Company, &amp;user.Role, &amp;user.Status,
                        &amp;user.EmailVerified, &amp;user.LastLoginAt, &amp;user.FailedLoginAttempts,
                        &amp;user.LockedUntil, &amp;user.CreatedAt, &amp;user.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">users = append(users, &amp;user)</span>
        }

        <span class="cov0" title="0">return users, nil</span>
}

// CreateBusiness creates a new business
func (p *PostgresDB) CreateBusiness(ctx context.Context, business *Business) error <span class="cov0" title="0">{
        query := `
                INSERT INTO businesses (
                        id, name, legal_name, registration_number, tax_id, industry, industry_code,
                        business_type, founded_date, employee_count, annual_revenue,
                        address_street1, address_street2, address_city, address_state,
                        address_postal_code, address_country, address_country_code,
                        contact_phone, contact_email, contact_website, contact_primary_contact,
                        status, risk_level, compliance_status, created_by
                ) VALUES (
                        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15,
                        $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26
                )
        `

        _, err := p.getDB().ExecContext(ctx, query,
                business.ID, business.Name, business.LegalName, business.RegistrationNumber,
                business.TaxID, business.Industry, business.IndustryCode, business.BusinessType,
                business.FoundedDate, business.EmployeeCount, business.AnnualRevenue,
                business.Address.Street1, business.Address.Street2, business.Address.City,
                business.Address.State, business.Address.PostalCode, business.Address.Country,
                business.Address.CountryCode, business.ContactInfo.Phone, business.ContactInfo.Email,
                business.ContactInfo.Website, business.ContactInfo.PrimaryContact,
                business.Status, business.RiskLevel, business.ComplianceStatus, business.CreatedBy)

        return err
}</span>

// GetBusinessByID retrieves a business by ID
func (p *PostgresDB) GetBusinessByID(ctx context.Context, id string) (*Business, error) <span class="cov0" title="0">{
        query := `SELECT * FROM businesses WHERE id = $1`

        row := p.getDB().QueryRowContext(ctx, query, id)

        var business Business
        err := row.Scan(
                &amp;business.ID, &amp;business.Name, &amp;business.LegalName, &amp;business.RegistrationNumber,
                &amp;business.TaxID, &amp;business.Industry, &amp;business.IndustryCode, &amp;business.BusinessType,
                &amp;business.FoundedDate, &amp;business.EmployeeCount, &amp;business.AnnualRevenue,
                &amp;business.Address.Street1, &amp;business.Address.Street2, &amp;business.Address.City,
                &amp;business.Address.State, &amp;business.Address.PostalCode, &amp;business.Address.Country,
                &amp;business.Address.CountryCode, &amp;business.ContactInfo.Phone, &amp;business.ContactInfo.Email,
                &amp;business.ContactInfo.Website, &amp;business.ContactInfo.PrimaryContact,
                &amp;business.Status, &amp;business.RiskLevel, &amp;business.ComplianceStatus, &amp;business.CreatedBy,
                &amp;business.CreatedAt, &amp;business.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;business, nil</span>
}

// GetBusinessByRegistrationNumber retrieves a business by registration number
func (p *PostgresDB) GetBusinessByRegistrationNumber(ctx context.Context, regNumber string) (*Business, error) <span class="cov0" title="0">{
        query := `SELECT * FROM businesses WHERE registration_number = $1`

        row := p.getDB().QueryRowContext(ctx, query, regNumber)

        var business Business
        err := row.Scan(
                &amp;business.ID, &amp;business.Name, &amp;business.LegalName, &amp;business.RegistrationNumber,
                &amp;business.TaxID, &amp;business.Industry, &amp;business.IndustryCode, &amp;business.BusinessType,
                &amp;business.FoundedDate, &amp;business.EmployeeCount, &amp;business.AnnualRevenue,
                &amp;business.Address.Street1, &amp;business.Address.Street2, &amp;business.Address.City,
                &amp;business.Address.State, &amp;business.Address.PostalCode, &amp;business.Address.Country,
                &amp;business.Address.CountryCode, &amp;business.ContactInfo.Phone, &amp;business.ContactInfo.Email,
                &amp;business.ContactInfo.Website, &amp;business.ContactInfo.PrimaryContact,
                &amp;business.Status, &amp;business.RiskLevel, &amp;business.ComplianceStatus, &amp;business.CreatedBy,
                &amp;business.CreatedAt, &amp;business.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;business, nil</span>
}

// UpdateBusiness updates an existing business
func (p *PostgresDB) UpdateBusiness(ctx context.Context, business *Business) error <span class="cov0" title="0">{
        query := `
                UPDATE businesses 
                SET name = $2, legal_name = $3, registration_number = $4, tax_id = $5,
                    industry = $6, industry_code = $7, business_type = $8, founded_date = $9,
                    employee_count = $10, annual_revenue = $11,
                    address_street1 = $12, address_street2 = $13, address_city = $14,
                    address_state = $15, address_postal_code = $16, address_country = $17,
                    address_country_code = $18, contact_phone = $19, contact_email = $20,
                    contact_website = $21, contact_primary_contact = $22,
                    status = $23, risk_level = $24, compliance_status = $25,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = $1
        `

        _, err := p.getDB().ExecContext(ctx, query,
                business.ID, business.Name, business.LegalName, business.RegistrationNumber,
                business.TaxID, business.Industry, business.IndustryCode, business.BusinessType,
                business.FoundedDate, business.EmployeeCount, business.AnnualRevenue,
                business.Address.Street1, business.Address.Street2, business.Address.City,
                business.Address.State, business.Address.PostalCode, business.Address.Country,
                business.Address.CountryCode, business.ContactInfo.Phone, business.ContactInfo.Email,
                business.ContactInfo.Website, business.ContactInfo.PrimaryContact,
                business.Status, business.RiskLevel, business.ComplianceStatus)

        return err
}</span>

// DeleteBusiness deletes a business by ID
func (p *PostgresDB) DeleteBusiness(ctx context.Context, id string) error <span class="cov0" title="0">{
        query := `DELETE FROM businesses WHERE id = $1`

        _, err := p.getDB().ExecContext(ctx, query, id)
        return err
}</span>

// ListBusinesses retrieves a list of businesses with pagination
func (p *PostgresDB) ListBusinesses(ctx context.Context, limit, offset int) ([]*Business, error) <span class="cov0" title="0">{
        query := `SELECT * FROM businesses ORDER BY created_at DESC LIMIT $1 OFFSET $2`

        rows, err := p.getDB().QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var businesses []*Business
        for rows.Next() </span><span class="cov0" title="0">{
                var business Business
                err := rows.Scan(
                        &amp;business.ID, &amp;business.Name, &amp;business.LegalName, &amp;business.RegistrationNumber,
                        &amp;business.TaxID, &amp;business.Industry, &amp;business.IndustryCode, &amp;business.BusinessType,
                        &amp;business.FoundedDate, &amp;business.EmployeeCount, &amp;business.AnnualRevenue,
                        &amp;business.Address.Street1, &amp;business.Address.Street2, &amp;business.Address.City,
                        &amp;business.Address.State, &amp;business.Address.PostalCode, &amp;business.Address.Country,
                        &amp;business.Address.CountryCode, &amp;business.ContactInfo.Phone, &amp;business.ContactInfo.Email,
                        &amp;business.ContactInfo.Website, &amp;business.ContactInfo.PrimaryContact,
                        &amp;business.Status, &amp;business.RiskLevel, &amp;business.ComplianceStatus, &amp;business.CreatedBy,
                        &amp;business.CreatedAt, &amp;business.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">businesses = append(businesses, &amp;business)</span>
        }

        <span class="cov0" title="0">return businesses, nil</span>
}

// SearchBusinesses searches businesses by query
func (p *PostgresDB) SearchBusinesses(ctx context.Context, query string, limit, offset int) ([]*Business, error) <span class="cov0" title="0">{
        searchQuery := `
                SELECT * FROM businesses 
                WHERE name ILIKE $1 OR legal_name ILIKE $1 OR registration_number ILIKE $1
                ORDER BY created_at DESC LIMIT $2 OFFSET $3
        `

        searchTerm := "%" + query + "%"
        rows, err := p.getDB().QueryContext(ctx, searchQuery, searchTerm, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var businesses []*Business
        for rows.Next() </span><span class="cov0" title="0">{
                var business Business
                err := rows.Scan(
                        &amp;business.ID, &amp;business.Name, &amp;business.LegalName, &amp;business.RegistrationNumber,
                        &amp;business.TaxID, &amp;business.Industry, &amp;business.IndustryCode, &amp;business.BusinessType,
                        &amp;business.FoundedDate, &amp;business.EmployeeCount, &amp;business.AnnualRevenue,
                        &amp;business.Address.Street1, &amp;business.Address.Street2, &amp;business.Address.City,
                        &amp;business.Address.State, &amp;business.Address.PostalCode, &amp;business.Address.Country,
                        &amp;business.Address.CountryCode, &amp;business.ContactInfo.Phone, &amp;business.ContactInfo.Email,
                        &amp;business.ContactInfo.Website, &amp;business.ContactInfo.PrimaryContact,
                        &amp;business.Status, &amp;business.RiskLevel, &amp;business.ComplianceStatus, &amp;business.CreatedBy,
                        &amp;business.CreatedAt, &amp;business.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">businesses = append(businesses, &amp;business)</span>
        }

        <span class="cov0" title="0">return businesses, nil</span>
}

// Placeholder implementations for other methods
// These would be implemented similarly to the above methods

func (p *PostgresDB) CreateBusinessClassification(ctx context.Context, classification *BusinessClassification) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) GetBusinessClassificationByID(ctx context.Context, id string) (*BusinessClassification, error) <span class="cov0" title="0">{
        // TODO: Implement
        return nil, fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) GetBusinessClassificationsByBusinessID(ctx context.Context, businessID string) ([]*BusinessClassification, error) <span class="cov0" title="0">{
        // TODO: Implement
        return nil, fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) UpdateBusinessClassification(ctx context.Context, classification *BusinessClassification) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) DeleteBusinessClassification(ctx context.Context, id string) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) CreateRiskAssessment(ctx context.Context, assessment *RiskAssessment) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) GetRiskAssessmentByID(ctx context.Context, id string) (*RiskAssessment, error) <span class="cov0" title="0">{
        // TODO: Implement
        return nil, fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) GetRiskAssessmentsByBusinessID(ctx context.Context, businessID string) ([]*RiskAssessment, error) <span class="cov0" title="0">{
        // TODO: Implement
        return nil, fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) UpdateRiskAssessment(ctx context.Context, assessment *RiskAssessment) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) DeleteRiskAssessment(ctx context.Context, id string) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) CreateComplianceCheck(ctx context.Context, check *ComplianceCheck) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) GetComplianceCheckByID(ctx context.Context, id string) (*ComplianceCheck, error) <span class="cov0" title="0">{
        // TODO: Implement
        return nil, fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) GetComplianceChecksByBusinessID(ctx context.Context, businessID string) ([]*ComplianceCheck, error) <span class="cov0" title="0">{
        // TODO: Implement
        return nil, fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) UpdateComplianceCheck(ctx context.Context, check *ComplianceCheck) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) DeleteComplianceCheck(ctx context.Context, id string) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) CreateAPIKey(ctx context.Context, apiKey *APIKey) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) GetAPIKeyByID(ctx context.Context, id string) (*APIKey, error) <span class="cov0" title="0">{
        // TODO: Implement
        return nil, fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) GetAPIKeyByHash(ctx context.Context, keyHash string) (*APIKey, error) <span class="cov0" title="0">{
        // TODO: Implement
        return nil, fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) UpdateAPIKey(ctx context.Context, apiKey *APIKey) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) DeleteAPIKey(ctx context.Context, id string) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) ListAPIKeysByUserID(ctx context.Context, userID string) ([]*APIKey, error) <span class="cov0" title="0">{
        // TODO: Implement
        return nil, fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) CreateAuditLog(ctx context.Context, log *AuditLog) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) GetAuditLogsByUserID(ctx context.Context, userID string, limit, offset int) ([]*AuditLog, error) <span class="cov0" title="0">{
        // TODO: Implement
        return nil, fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) GetAuditLogsByResource(ctx context.Context, resourceType, resourceID string, limit, offset int) ([]*AuditLog, error) <span class="cov0" title="0">{
        // TODO: Implement
        return nil, fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) CreateExternalServiceCall(ctx context.Context, call *ExternalServiceCall) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) GetExternalServiceCallsByUserID(ctx context.Context, userID string, limit, offset int) ([]*ExternalServiceCall, error) <span class="cov0" title="0">{
        // TODO: Implement
        return nil, fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) GetExternalServiceCallsByService(ctx context.Context, serviceName string, limit, offset int) ([]*ExternalServiceCall, error) <span class="cov0" title="0">{
        // TODO: Implement
        return nil, fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) CreateWebhook(ctx context.Context, webhook *Webhook) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) GetWebhookByID(ctx context.Context, id string) (*Webhook, error) <span class="cov0" title="0">{
        // TODO: Implement
        return nil, fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) GetWebhooksByUserID(ctx context.Context, userID string) ([]*Webhook, error) <span class="cov0" title="0">{
        // TODO: Implement
        return nil, fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) UpdateWebhook(ctx context.Context, webhook *Webhook) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) DeleteWebhook(ctx context.Context, id string) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) CreateWebhookEvent(ctx context.Context, event *WebhookEvent) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) GetWebhookEventByID(ctx context.Context, id string) (*WebhookEvent, error) <span class="cov0" title="0">{
        // TODO: Implement
        return nil, fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) GetWebhookEventsByWebhookID(ctx context.Context, webhookID string, limit, offset int) ([]*WebhookEvent, error) <span class="cov0" title="0">{
        // TODO: Implement
        return nil, fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) UpdateWebhookEvent(ctx context.Context, event *WebhookEvent) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

func (p *PostgresDB) DeleteWebhookEvent(ctx context.Context, id string) error <span class="cov0" title="0">{
        // TODO: Implement
        return fmt.Errorf("not implemented")
}</span>

// Email verification token methods
func (p *PostgresDB) CreateEmailVerificationToken(ctx context.Context, token *EmailVerificationToken) error <span class="cov0" title="0">{
        query := `
                INSERT INTO email_verification_tokens (id, user_id, token, expires_at, created_at)
                VALUES ($1, $2, $3, $4, $5)
        `
        _, err := p.getDB().ExecContext(ctx, query,
                token.ID, token.UserID, token.Token, token.ExpiresAt, token.CreatedAt)
        return err
}</span>

func (p *PostgresDB) GetEmailVerificationToken(ctx context.Context, token string) (*EmailVerificationToken, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, token, expires_at, used_at, created_at
                FROM email_verification_tokens
                WHERE token = $1
        `
        var verificationToken EmailVerificationToken
        err := p.getDB().QueryRowContext(ctx, query, token).Scan(
                &amp;verificationToken.ID, &amp;verificationToken.UserID, &amp;verificationToken.Token,
                &amp;verificationToken.ExpiresAt, &amp;verificationToken.UsedAt, &amp;verificationToken.CreatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;verificationToken, nil</span>
}

func (p *PostgresDB) MarkEmailVerificationTokenUsed(ctx context.Context, token string) error <span class="cov0" title="0">{
        query := `
                UPDATE email_verification_tokens
                SET used_at = CURRENT_TIMESTAMP
                WHERE token = $1
        `
        _, err := p.getDB().ExecContext(ctx, query, token)
        return err
}</span>

func (p *PostgresDB) DeleteExpiredEmailVerificationTokens(ctx context.Context) error <span class="cov0" title="0">{
        query := `
                DELETE FROM email_verification_tokens
                WHERE expires_at &lt; CURRENT_TIMESTAMP
        `
        _, err := p.getDB().ExecContext(ctx, query)
        return err
}</span>

// Password reset token methods
func (p *PostgresDB) CreatePasswordResetToken(ctx context.Context, token *PasswordResetToken) error <span class="cov0" title="0">{
        query := `
                INSERT INTO password_reset_tokens (id, user_id, token, expires_at, created_at)
                VALUES ($1, $2, $3, $4, $5)
        `
        _, err := p.getDB().ExecContext(ctx, query,
                token.ID, token.UserID, token.Token, token.ExpiresAt, token.CreatedAt)
        return err
}</span>

func (p *PostgresDB) GetPasswordResetToken(ctx context.Context, token string) (*PasswordResetToken, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, token, expires_at, used_at, created_at
                FROM password_reset_tokens
                WHERE token = $1
        `
        var resetToken PasswordResetToken
        err := p.getDB().QueryRowContext(ctx, query, token).Scan(
                &amp;resetToken.ID, &amp;resetToken.UserID, &amp;resetToken.Token,
                &amp;resetToken.ExpiresAt, &amp;resetToken.UsedAt, &amp;resetToken.CreatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resetToken, nil</span>
}

func (p *PostgresDB) MarkPasswordResetTokenUsed(ctx context.Context, token string) error <span class="cov0" title="0">{
        query := `
                UPDATE password_reset_tokens
                SET used_at = CURRENT_TIMESTAMP
                WHERE token = $1
        `
        _, err := p.getDB().ExecContext(ctx, query, token)
        return err
}</span>

func (p *PostgresDB) DeleteExpiredPasswordResetTokens(ctx context.Context) error <span class="cov0" title="0">{
        query := `
                DELETE FROM password_reset_tokens
                WHERE expires_at &lt; CURRENT_TIMESTAMP
        `
        _, err := p.getDB().ExecContext(ctx, query)
        return err
}</span>

// Token blacklist methods
func (p *PostgresDB) CreateTokenBlacklist(ctx context.Context, blacklist *TokenBlacklist) error <span class="cov0" title="0">{
        query := `
                INSERT INTO token_blacklist (id, token_id, user_id, expires_at, blacklisted_at, reason)
                VALUES ($1, $2, $3, $4, $5, $6)
        `
        _, err := p.getDB().ExecContext(ctx, query,
                blacklist.ID, blacklist.TokenID, blacklist.UserID,
                blacklist.ExpiresAt, blacklist.BlacklistedAt, blacklist.Reason)
        return err
}</span>

func (p *PostgresDB) IsTokenBlacklisted(ctx context.Context, tokenID string) (bool, error) <span class="cov0" title="0">{
        query := `
                SELECT EXISTS(
                        SELECT 1 FROM token_blacklist
                        WHERE token_id = $1 AND expires_at &gt; CURRENT_TIMESTAMP
                )
        `
        var exists bool
        err := p.getDB().QueryRowContext(ctx, query, tokenID).Scan(&amp;exists)
        return exists, err
}</span>

func (p *PostgresDB) DeleteExpiredTokenBlacklist(ctx context.Context) error <span class="cov0" title="0">{
        query := `
                DELETE FROM token_blacklist
                WHERE expires_at &lt; CURRENT_TIMESTAMP
        `
        _, err := p.getDB().ExecContext(ctx, query)
        return err
}</span>

// Role assignment methods
func (p *PostgresDB) CreateRoleAssignment(ctx context.Context, assignment *RoleAssignment) error <span class="cov0" title="0">{
        query := `
                INSERT INTO role_assignments (id, user_id, role, assigned_by, assigned_at, expires_at, is_active, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        `
        _, err := p.getDB().ExecContext(ctx, query,
                assignment.ID, assignment.UserID, assignment.Role, assignment.AssignedBy,
                assignment.AssignedAt, assignment.ExpiresAt, assignment.IsActive,
                assignment.CreatedAt, assignment.UpdatedAt)
        return err
}</span>

func (p *PostgresDB) GetRoleAssignmentByID(ctx context.Context, id string) (*RoleAssignment, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, role, assigned_by, assigned_at, expires_at, is_active, created_at, updated_at
                FROM role_assignments
                WHERE id = $1
        `
        var assignment RoleAssignment
        err := p.getDB().QueryRowContext(ctx, query, id).Scan(
                &amp;assignment.ID, &amp;assignment.UserID, &amp;assignment.Role, &amp;assignment.AssignedBy,
                &amp;assignment.AssignedAt, &amp;assignment.ExpiresAt, &amp;assignment.IsActive,
                &amp;assignment.CreatedAt, &amp;assignment.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;assignment, nil</span>
}

func (p *PostgresDB) GetActiveRoleAssignmentByUserID(ctx context.Context, userID string) (*RoleAssignment, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, role, assigned_by, assigned_at, expires_at, is_active, created_at, updated_at
                FROM role_assignments
                WHERE user_id = $1 AND is_active = true 
                AND (expires_at IS NULL OR expires_at &gt; CURRENT_TIMESTAMP)
                ORDER BY created_at DESC
                LIMIT 1
        `
        var assignment RoleAssignment
        err := p.getDB().QueryRowContext(ctx, query, userID).Scan(
                &amp;assignment.ID, &amp;assignment.UserID, &amp;assignment.Role, &amp;assignment.AssignedBy,
                &amp;assignment.AssignedAt, &amp;assignment.ExpiresAt, &amp;assignment.IsActive,
                &amp;assignment.CreatedAt, &amp;assignment.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;assignment, nil</span>
}

func (p *PostgresDB) GetRoleAssignmentsByUserID(ctx context.Context, userID string) ([]*RoleAssignment, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, role, assigned_by, assigned_at, expires_at, is_active, created_at, updated_at
                FROM role_assignments
                WHERE user_id = $1
                ORDER BY created_at DESC
        `
        rows, err := p.getDB().QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var assignments []*RoleAssignment
        for rows.Next() </span><span class="cov0" title="0">{
                var assignment RoleAssignment
                err := rows.Scan(
                        &amp;assignment.ID, &amp;assignment.UserID, &amp;assignment.Role, &amp;assignment.AssignedBy,
                        &amp;assignment.AssignedAt, &amp;assignment.ExpiresAt, &amp;assignment.IsActive,
                        &amp;assignment.CreatedAt, &amp;assignment.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">assignments = append(assignments, &amp;assignment)</span>
        }

        <span class="cov0" title="0">return assignments, rows.Err()</span>
}

func (p *PostgresDB) UpdateRoleAssignment(ctx context.Context, assignment *RoleAssignment) error <span class="cov0" title="0">{
        query := `
                UPDATE role_assignments
                SET role = $2, assigned_by = $3, assigned_at = $4, expires_at = $5, 
                    is_active = $6, updated_at = $7
                WHERE id = $1
        `
        _, err := p.getDB().ExecContext(ctx, query,
                assignment.ID, assignment.Role, assignment.AssignedBy, assignment.AssignedAt,
                assignment.ExpiresAt, assignment.IsActive, assignment.UpdatedAt)
        return err
}</span>

func (p *PostgresDB) DeactivateRoleAssignment(ctx context.Context, id string) error <span class="cov0" title="0">{
        query := `
                UPDATE role_assignments
                SET is_active = false, updated_at = CURRENT_TIMESTAMP
                WHERE id = $1
        `
        _, err := p.getDB().ExecContext(ctx, query, id)
        return err
}</span>

func (p *PostgresDB) DeleteExpiredRoleAssignments(ctx context.Context) error <span class="cov0" title="0">{
        query := `
                UPDATE role_assignments
                SET is_active = false, updated_at = CURRENT_TIMESTAMP
                WHERE expires_at &lt; CURRENT_TIMESTAMP AND is_active = true
        `
        _, err := p.getDB().ExecContext(ctx, query)
        return err
}</span>

// Enhanced API key management with RBAC
func (p *PostgresDB) UpdateAPIKeyLastUsed(ctx context.Context, id string, lastUsed time.Time) error <span class="cov0" title="0">{
        query := `
                UPDATE api_keys
                SET last_used_at = $2, updated_at = CURRENT_TIMESTAMP
                WHERE id = $1
        `
        _, err := p.getDB().ExecContext(ctx, query, id, lastUsed)
        return err
}</span>

func (p *PostgresDB) GetActiveAPIKeysByRole(ctx context.Context, role string) ([]*APIKey, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, name, key_hash, role, permissions, status, last_used_at, expires_at, created_at, updated_at
                FROM api_keys
                WHERE role = $1 AND status = 'active' 
                AND (expires_at IS NULL OR expires_at &gt; CURRENT_TIMESTAMP)
                ORDER BY created_at DESC
        `
        rows, err := p.getDB().QueryContext(ctx, query, role)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var apiKeys []*APIKey
        for rows.Next() </span><span class="cov0" title="0">{
                var apiKey APIKey
                err := rows.Scan(
                        &amp;apiKey.ID, &amp;apiKey.UserID, &amp;apiKey.Name, &amp;apiKey.KeyHash,
                        &amp;apiKey.Role, &amp;apiKey.Permissions, &amp;apiKey.Status,
                        &amp;apiKey.LastUsedAt, &amp;apiKey.ExpiresAt, &amp;apiKey.CreatedAt, &amp;apiKey.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">apiKeys = append(apiKeys, &amp;apiKey)</span>
        }

        <span class="cov0" title="0">return apiKeys, rows.Err()</span>
}

func (p *PostgresDB) DeactivateAPIKey(ctx context.Context, id string) error <span class="cov0" title="0">{
        query := `
                UPDATE api_keys
                SET status = 'inactive', updated_at = CURRENT_TIMESTAMP
                WHERE id = $1
        `
        _, err := p.getDB().ExecContext(ctx, query, id)
        return err
}</span>

// GetRiskAssessmentHistory retrieves risk assessment history for a business
func (p *PostgresDB) GetRiskAssessmentHistory(ctx context.Context, businessID string, limit, offset int) ([]*RiskAssessment, error) <span class="cov0" title="0">{
        query := `
                SELECT id, business_id, business_name, overall_score, overall_level, 
                       category_scores, factor_scores, recommendations, predictions, alerts,
                       assessment_method, source, metadata, assessed_at, valid_until, 
                       created_at, updated_at
                FROM risk_assessments 
                WHERE business_id = $1 
                ORDER BY assessed_at DESC 
                LIMIT $2 OFFSET $3
        `

        rows, err := p.getDB().QueryContext(ctx, query, businessID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query risk assessment history: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var assessments []*RiskAssessment
        for rows.Next() </span><span class="cov0" title="0">{
                assessment := &amp;RiskAssessment{}
                var categoryScoresStr, factorScoresStr, recommendationsStr, predictionsStr, alertsStr, metadataStr string

                err := rows.Scan(
                        &amp;assessment.ID,
                        &amp;assessment.BusinessID,
                        &amp;assessment.BusinessName,
                        &amp;assessment.OverallScore,
                        &amp;assessment.OverallLevel,
                        &amp;categoryScoresStr,
                        &amp;factorScoresStr,
                        &amp;recommendationsStr,
                        &amp;predictionsStr,
                        &amp;alertsStr,
                        &amp;assessment.AssessmentMethod,
                        &amp;assessment.Source,
                        &amp;metadataStr,
                        &amp;assessment.AssessedAt,
                        &amp;assessment.ValidUntil,
                        &amp;assessment.CreatedAt,
                        &amp;assessment.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan risk assessment: %w", err)
                }</span>

                // Parse JSON fields
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(categoryScoresStr), &amp;assessment.CategoryScores); err != nil </span><span class="cov0" title="0">{
                        assessment.CategoryScores = make(map[string]interface{})
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(factorScoresStr), &amp;assessment.FactorScores); err != nil </span><span class="cov0" title="0">{
                        assessment.FactorScores = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(recommendationsStr), &amp;assessment.Recommendations); err != nil </span><span class="cov0" title="0">{
                        assessment.Recommendations = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(predictionsStr), &amp;assessment.Predictions); err != nil </span><span class="cov0" title="0">{
                        assessment.Predictions = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(alertsStr), &amp;assessment.Alerts); err != nil </span><span class="cov0" title="0">{
                        assessment.Alerts = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(metadataStr), &amp;assessment.Metadata); err != nil </span><span class="cov0" title="0">{
                        assessment.Metadata = make(map[string]interface{})
                }</span>

                <span class="cov0" title="0">assessments = append(assessments, assessment)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating risk assessment history: %w", err)
        }</span>

        <span class="cov0" title="0">return assessments, nil</span>
}

// GetRiskAssessmentHistoryByDateRange retrieves risk assessment history within a date range
func (p *PostgresDB) GetRiskAssessmentHistoryByDateRange(ctx context.Context, businessID string, startDate, endDate time.Time) ([]*RiskAssessment, error) <span class="cov0" title="0">{
        query := `
                SELECT id, business_id, business_name, overall_score, overall_level, 
                       category_scores, factor_scores, recommendations, predictions, alerts,
                       assessment_method, source, metadata, assessed_at, valid_until, 
                       created_at, updated_at
                FROM risk_assessments 
                WHERE business_id = $1 AND assessed_at &gt;= $2 AND assessed_at &lt;= $3
                ORDER BY assessed_at DESC
        `

        rows, err := p.getDB().QueryContext(ctx, query, businessID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query risk assessment history by date range: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var assessments []*RiskAssessment
        for rows.Next() </span><span class="cov0" title="0">{
                assessment := &amp;RiskAssessment{}
                var categoryScoresStr, factorScoresStr, recommendationsStr, predictionsStr, alertsStr, metadataStr string

                err := rows.Scan(
                        &amp;assessment.ID,
                        &amp;assessment.BusinessID,
                        &amp;assessment.BusinessName,
                        &amp;assessment.OverallScore,
                        &amp;assessment.OverallLevel,
                        &amp;categoryScoresStr,
                        &amp;factorScoresStr,
                        &amp;recommendationsStr,
                        &amp;predictionsStr,
                        &amp;alertsStr,
                        &amp;assessment.AssessmentMethod,
                        &amp;assessment.Source,
                        &amp;metadataStr,
                        &amp;assessment.AssessedAt,
                        &amp;assessment.ValidUntil,
                        &amp;assessment.CreatedAt,
                        &amp;assessment.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan risk assessment: %w", err)
                }</span>

                // Parse JSON fields
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(categoryScoresStr), &amp;assessment.CategoryScores); err != nil </span><span class="cov0" title="0">{
                        assessment.CategoryScores = make(map[string]interface{})
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(factorScoresStr), &amp;assessment.FactorScores); err != nil </span><span class="cov0" title="0">{
                        assessment.FactorScores = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(recommendationsStr), &amp;assessment.Recommendations); err != nil </span><span class="cov0" title="0">{
                        assessment.Recommendations = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(predictionsStr), &amp;assessment.Predictions); err != nil </span><span class="cov0" title="0">{
                        assessment.Predictions = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(alertsStr), &amp;assessment.Alerts); err != nil </span><span class="cov0" title="0">{
                        assessment.Alerts = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(metadataStr), &amp;assessment.Metadata); err != nil </span><span class="cov0" title="0">{
                        assessment.Metadata = make(map[string]interface{})
                }</span>

                <span class="cov0" title="0">assessments = append(assessments, assessment)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating risk assessment history by date range: %w", err)
        }</span>

        <span class="cov0" title="0">return assessments, nil</span>
}

// GetLatestRiskAssessment retrieves the most recent risk assessment for a business
func (p *PostgresDB) GetLatestRiskAssessment(ctx context.Context, businessID string) (*RiskAssessment, error) <span class="cov0" title="0">{
        query := `
                SELECT id, business_id, business_name, overall_score, overall_level, 
                       category_scores, factor_scores, recommendations, predictions, alerts,
                       assessment_method, source, metadata, assessed_at, valid_until, 
                       created_at, updated_at
                FROM risk_assessments 
                WHERE business_id = $1 
                ORDER BY assessed_at DESC 
                LIMIT 1
        `

        row := p.getDB().QueryRowContext(ctx, query, businessID)

        assessment := &amp;RiskAssessment{}
        var categoryScoresStr, factorScoresStr, recommendationsStr, predictionsStr, alertsStr, metadataStr string

        err := row.Scan(
                &amp;assessment.ID,
                &amp;assessment.BusinessID,
                &amp;assessment.BusinessName,
                &amp;assessment.OverallScore,
                &amp;assessment.OverallLevel,
                &amp;categoryScoresStr,
                &amp;factorScoresStr,
                &amp;recommendationsStr,
                &amp;predictionsStr,
                &amp;alertsStr,
                &amp;assessment.AssessmentMethod,
                &amp;assessment.Source,
                &amp;metadataStr,
                &amp;assessment.AssessedAt,
                &amp;assessment.ValidUntil,
                &amp;assessment.CreatedAt,
                &amp;assessment.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil // No assessment found
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to scan latest risk assessment: %w", err)</span>
        }

        // Parse JSON fields
        <span class="cov0" title="0">if err := json.Unmarshal([]byte(categoryScoresStr), &amp;assessment.CategoryScores); err != nil </span><span class="cov0" title="0">{
                assessment.CategoryScores = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal([]byte(factorScoresStr), &amp;assessment.FactorScores); err != nil </span><span class="cov0" title="0">{
                assessment.FactorScores = []string{}
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal([]byte(recommendationsStr), &amp;assessment.Recommendations); err != nil </span><span class="cov0" title="0">{
                assessment.Recommendations = []string{}
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal([]byte(predictionsStr), &amp;assessment.Predictions); err != nil </span><span class="cov0" title="0">{
                assessment.Predictions = []string{}
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal([]byte(alertsStr), &amp;assessment.Alerts); err != nil </span><span class="cov0" title="0">{
                assessment.Alerts = []string{}
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal([]byte(metadataStr), &amp;assessment.Metadata); err != nil </span><span class="cov0" title="0">{
                assessment.Metadata = make(map[string]interface{})
        }</span>

        <span class="cov0" title="0">return assessment, nil</span>
}

// GetRiskAssessmentTrends retrieves risk assessment trends for a business
func (p *PostgresDB) GetRiskAssessmentTrends(ctx context.Context, businessID string, days int) ([]*RiskAssessment, error) <span class="cov0" title="0">{
        query := `
                SELECT id, business_id, business_name, overall_score, overall_level, 
                       category_scores, factor_scores, recommendations, predictions, alerts,
                       assessment_method, source, metadata, assessed_at, valid_until, 
                       created_at, updated_at
                FROM risk_assessments 
                WHERE business_id = $1 AND assessed_at &gt;= NOW() - INTERVAL '1 day' * $2
                ORDER BY assessed_at DESC
        `

        rows, err := p.getDB().QueryContext(ctx, query, businessID, days)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query risk assessment trends: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var assessments []*RiskAssessment
        for rows.Next() </span><span class="cov0" title="0">{
                assessment := &amp;RiskAssessment{}
                var categoryScoresStr, factorScoresStr, recommendationsStr, predictionsStr, alertsStr, metadataStr string

                err := rows.Scan(
                        &amp;assessment.ID,
                        &amp;assessment.BusinessID,
                        &amp;assessment.BusinessName,
                        &amp;assessment.OverallScore,
                        &amp;assessment.OverallLevel,
                        &amp;categoryScoresStr,
                        &amp;factorScoresStr,
                        &amp;recommendationsStr,
                        &amp;predictionsStr,
                        &amp;alertsStr,
                        &amp;assessment.AssessmentMethod,
                        &amp;assessment.Source,
                        &amp;metadataStr,
                        &amp;assessment.AssessedAt,
                        &amp;assessment.ValidUntil,
                        &amp;assessment.CreatedAt,
                        &amp;assessment.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan risk assessment trend: %w", err)
                }</span>

                // Parse JSON fields
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(categoryScoresStr), &amp;assessment.CategoryScores); err != nil </span><span class="cov0" title="0">{
                        assessment.CategoryScores = make(map[string]interface{})
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(factorScoresStr), &amp;assessment.FactorScores); err != nil </span><span class="cov0" title="0">{
                        assessment.FactorScores = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(recommendationsStr), &amp;assessment.Recommendations); err != nil </span><span class="cov0" title="0">{
                        assessment.Recommendations = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(predictionsStr), &amp;assessment.Predictions); err != nil </span><span class="cov0" title="0">{
                        assessment.Predictions = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(alertsStr), &amp;assessment.Alerts); err != nil </span><span class="cov0" title="0">{
                        assessment.Alerts = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(metadataStr), &amp;assessment.Metadata); err != nil </span><span class="cov0" title="0">{
                        assessment.Metadata = make(map[string]interface{})
                }</span>

                <span class="cov0" title="0">assessments = append(assessments, assessment)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating risk assessment trends: %w", err)
        }</span>

        <span class="cov0" title="0">return assessments, nil</span>
}

// GetRiskAssessmentsByLevel retrieves risk assessments by risk level
func (p *PostgresDB) GetRiskAssessmentsByLevel(ctx context.Context, businessID string, riskLevel string) ([]*RiskAssessment, error) <span class="cov0" title="0">{
        query := `
                SELECT id, business_id, business_name, overall_score, overall_level, 
                       category_scores, factor_scores, recommendations, predictions, alerts,
                       assessment_method, source, metadata, assessed_at, valid_until, 
                       created_at, updated_at
                FROM risk_assessments 
                WHERE business_id = $1 AND overall_level = $2
                ORDER BY assessed_at DESC
        `

        rows, err := p.getDB().QueryContext(ctx, query, businessID, riskLevel)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query risk assessments by level: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var assessments []*RiskAssessment
        for rows.Next() </span><span class="cov0" title="0">{
                assessment := &amp;RiskAssessment{}
                var categoryScoresStr, factorScoresStr, recommendationsStr, predictionsStr, alertsStr, metadataStr string

                err := rows.Scan(
                        &amp;assessment.ID,
                        &amp;assessment.BusinessID,
                        &amp;assessment.BusinessName,
                        &amp;assessment.OverallScore,
                        &amp;assessment.OverallLevel,
                        &amp;categoryScoresStr,
                        &amp;factorScoresStr,
                        &amp;recommendationsStr,
                        &amp;predictionsStr,
                        &amp;alertsStr,
                        &amp;assessment.AssessmentMethod,
                        &amp;assessment.Source,
                        &amp;metadataStr,
                        &amp;assessment.AssessedAt,
                        &amp;assessment.ValidUntil,
                        &amp;assessment.CreatedAt,
                        &amp;assessment.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan risk assessment by level: %w", err)
                }</span>

                // Parse JSON fields
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(categoryScoresStr), &amp;assessment.CategoryScores); err != nil </span><span class="cov0" title="0">{
                        assessment.CategoryScores = make(map[string]interface{})
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(factorScoresStr), &amp;assessment.FactorScores); err != nil </span><span class="cov0" title="0">{
                        assessment.FactorScores = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(recommendationsStr), &amp;assessment.Recommendations); err != nil </span><span class="cov0" title="0">{
                        assessment.Recommendations = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(predictionsStr), &amp;assessment.Predictions); err != nil </span><span class="cov0" title="0">{
                        assessment.Predictions = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(alertsStr), &amp;assessment.Alerts); err != nil </span><span class="cov0" title="0">{
                        assessment.Alerts = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(metadataStr), &amp;assessment.Metadata); err != nil </span><span class="cov0" title="0">{
                        assessment.Metadata = make(map[string]interface{})
                }</span>

                <span class="cov0" title="0">assessments = append(assessments, assessment)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating risk assessments by level: %w", err)
        }</span>

        <span class="cov0" title="0">return assessments, nil</span>
}

// GetRiskAssessmentsByScoreRange retrieves risk assessments by score range
func (p *PostgresDB) GetRiskAssessmentsByScoreRange(ctx context.Context, businessID string, minScore, maxScore float64) ([]*RiskAssessment, error) <span class="cov0" title="0">{
        query := `
                SELECT id, business_id, business_name, overall_score, overall_level, 
                       category_scores, factor_scores, recommendations, predictions, alerts,
                       assessment_method, source, metadata, assessed_at, valid_until, 
                       created_at, updated_at
                FROM risk_assessments 
                WHERE business_id = $1 AND overall_score &gt;= $2 AND overall_score &lt;= $3
                ORDER BY assessed_at DESC
        `

        rows, err := p.getDB().QueryContext(ctx, query, businessID, minScore, maxScore)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query risk assessments by score range: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var assessments []*RiskAssessment
        for rows.Next() </span><span class="cov0" title="0">{
                assessment := &amp;RiskAssessment{}
                var categoryScoresStr, factorScoresStr, recommendationsStr, predictionsStr, alertsStr, metadataStr string

                err := rows.Scan(
                        &amp;assessment.ID,
                        &amp;assessment.BusinessID,
                        &amp;assessment.BusinessName,
                        &amp;assessment.OverallScore,
                        &amp;assessment.OverallLevel,
                        &amp;categoryScoresStr,
                        &amp;factorScoresStr,
                        &amp;recommendationsStr,
                        &amp;predictionsStr,
                        &amp;alertsStr,
                        &amp;assessment.AssessmentMethod,
                        &amp;assessment.Source,
                        &amp;metadataStr,
                        &amp;assessment.AssessedAt,
                        &amp;assessment.ValidUntil,
                        &amp;assessment.CreatedAt,
                        &amp;assessment.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan risk assessment by score range: %w", err)
                }</span>

                // Parse JSON fields
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(categoryScoresStr), &amp;assessment.CategoryScores); err != nil </span><span class="cov0" title="0">{
                        assessment.CategoryScores = make(map[string]interface{})
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(factorScoresStr), &amp;assessment.FactorScores); err != nil </span><span class="cov0" title="0">{
                        assessment.FactorScores = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(recommendationsStr), &amp;assessment.Recommendations); err != nil </span><span class="cov0" title="0">{
                        assessment.Recommendations = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(predictionsStr), &amp;assessment.Predictions); err != nil </span><span class="cov0" title="0">{
                        assessment.Predictions = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(alertsStr), &amp;assessment.Alerts); err != nil </span><span class="cov0" title="0">{
                        assessment.Alerts = []string{}
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(metadataStr), &amp;assessment.Metadata); err != nil </span><span class="cov0" title="0">{
                        assessment.Metadata = make(map[string]interface{})
                }</span>

                <span class="cov0" title="0">assessments = append(assessments, assessment)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating risk assessments by score range: %w", err)
        }</span>

        <span class="cov0" title="0">return assessments, nil</span>
}

// GetRiskAssessmentStatistics retrieves risk assessment statistics for a business
func (p *PostgresDB) GetRiskAssessmentStatistics(ctx context.Context, businessID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        COUNT(*) as total_assessments,
                        AVG(overall_score) as average_score,
                        MIN(overall_score) as min_score,
                        MAX(overall_score) as max_score,
                        COUNT(CASE WHEN overall_level = 'low' THEN 1 END) as low_count,
                        COUNT(CASE WHEN overall_level = 'medium' THEN 1 END) as medium_count,
                        COUNT(CASE WHEN overall_level = 'high' THEN 1 END) as high_count,
                        COUNT(CASE WHEN overall_level = 'critical' THEN 1 END) as critical_count,
                        MIN(assessed_at) as first_assessment,
                        MAX(assessed_at) as last_assessment
                FROM risk_assessments 
                WHERE business_id = $1
        `

        row := p.getDB().QueryRowContext(ctx, query, businessID)

        var stats struct {
                TotalAssessments int       `db:"total_assessments"`
                AverageScore     float64   `db:"average_score"`
                MinScore         float64   `db:"min_score"`
                MaxScore         float64   `db:"max_score"`
                LowCount         int       `db:"low_count"`
                MediumCount      int       `db:"medium_count"`
                HighCount        int       `db:"high_count"`
                CriticalCount    int       `db:"critical_count"`
                FirstAssessment  time.Time `db:"first_assessment"`
                LastAssessment   time.Time `db:"last_assessment"`
        }

        err := row.Scan(
                &amp;stats.TotalAssessments,
                &amp;stats.AverageScore,
                &amp;stats.MinScore,
                &amp;stats.MaxScore,
                &amp;stats.LowCount,
                &amp;stats.MediumCount,
                &amp;stats.HighCount,
                &amp;stats.CriticalCount,
                &amp;stats.FirstAssessment,
                &amp;stats.LastAssessment,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to scan risk assessment statistics: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "total_assessments": stats.TotalAssessments,
                "average_score":     stats.AverageScore,
                "min_score":         stats.MinScore,
                "max_score":         stats.MaxScore,
                "level_distribution": map[string]int{
                        "low":      stats.LowCount,
                        "medium":   stats.MediumCount,
                        "high":     stats.HighCount,
                        "critical": stats.CriticalCount,
                },
                "first_assessment": stats.FirstAssessment,
                "last_assessment":  stats.LastAssessment,
        }

        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package database

import (
        "context"
        "fmt"
        "log"
        "time"

        "golang.org/x/crypto/bcrypt"
)

// SeedData represents seed data for the database
type SeedData struct {
        Users      []*User
        Businesses []*Business
        APIKeys    []*APIKey
}

// Seeder handles database seeding
type Seeder struct {
        db Database
}

// NewSeeder creates a new database seeder
func NewSeeder(db Database) *Seeder <span class="cov0" title="0">{
        return &amp;Seeder{
                db: db,
        }
}</span>

// SeedDatabase seeds the database with initial data
func (s *Seeder) SeedDatabase(ctx context.Context) error <span class="cov0" title="0">{
        log.Println("Starting database seeding...")

        // Create seed data
        seedData := s.createSeedData()

        // Seed users
        if err := s.seedUsers(ctx, seedData.Users); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to seed users: %w", err)
        }</span>

        // Seed businesses
        <span class="cov0" title="0">if err := s.seedBusinesses(ctx, seedData.Businesses); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to seed businesses: %w", err)
        }</span>

        // Seed API keys
        <span class="cov0" title="0">if err := s.seedAPIKeys(ctx, seedData.APIKeys); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to seed API keys: %w", err)
        }</span>

        <span class="cov0" title="0">log.Println("Database seeding completed successfully")
        return nil</span>
}

// createSeedData creates initial seed data
func (s *Seeder) createSeedData() *SeedData <span class="cov0" title="0">{
        // Create admin user
        adminPasswordHash, _ := bcrypt.GenerateFromPassword([]byte("admin123"), bcrypt.DefaultCost)
        adminUser := &amp;User{
                ID:            "admin-user-001",
                Email:         "admin@kybplatform.com",
                Username:      "admin",
                PasswordHash:  string(adminPasswordHash),
                FirstName:     "Admin",
                LastName:      "User",
                Company:       "KYB Platform",
                Role:          "admin",
                Status:        "active",
                EmailVerified: true,
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
        }

        // Create test user
        testPasswordHash, _ := bcrypt.GenerateFromPassword([]byte("test123"), bcrypt.DefaultCost)
        testUser := &amp;User{
                ID:            "test-user-001",
                Email:         "test@example.com",
                Username:      "testuser",
                PasswordHash:  string(testPasswordHash),
                FirstName:     "Test",
                LastName:      "User",
                Company:       "Test Company",
                Role:          "user",
                Status:        "active",
                EmailVerified: true,
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
        }

        // Create analyst user
        analystPasswordHash, _ := bcrypt.GenerateFromPassword([]byte("analyst123"), bcrypt.DefaultCost)
        analystUser := &amp;User{
                ID:            "analyst-user-001",
                Email:         "analyst@example.com",
                Username:      "analyst",
                PasswordHash:  string(analystPasswordHash),
                FirstName:     "Analyst",
                LastName:      "User",
                Company:       "Analytics Corp",
                Role:          "analyst",
                Status:        "active",
                EmailVerified: true,
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
        }

        // Create sample businesses
        business1 := &amp;Business{
                ID:                 "business-001",
                Name:               "Acme Corporation",
                LegalName:          "Acme Corporation Inc.",
                RegistrationNumber: "ACME001",
                TaxID:              "12-3456789",
                Industry:           "Technology",
                IndustryCode:       "541511",
                BusinessType:       "Corporation",
                FoundedDate:        &amp;time.Time{},
                EmployeeCount:      500,
                AnnualRevenue:      &amp;[]float64{50000000.0}[0],
                Address: Address{
                        Street1:     "123 Main Street",
                        City:        "San Francisco",
                        State:       "CA",
                        PostalCode:  "94105",
                        Country:     "United States",
                        CountryCode: "US",
                },
                ContactInfo: ContactInfo{
                        Phone:          "+1-555-0123",
                        Email:          "contact@acme.com",
                        Website:        "https://acme.com",
                        PrimaryContact: "John Smith",
                },
                Status:           "active",
                RiskLevel:        "low",
                ComplianceStatus: "compliant",
                CreatedBy:        adminUser.ID,
                CreatedAt:        time.Now(),
                UpdatedAt:        time.Now(),
        }

        business2 := &amp;Business{
                ID:                 "business-002",
                Name:               "TechStart Solutions",
                LegalName:          "TechStart Solutions LLC",
                RegistrationNumber: "TECH002",
                TaxID:              "98-7654321",
                Industry:           "Software Development",
                IndustryCode:       "541511",
                BusinessType:       "LLC",
                FoundedDate:        &amp;time.Time{},
                EmployeeCount:      25,
                AnnualRevenue:      &amp;[]float64{2000000.0}[0],
                Address: Address{
                        Street1:     "456 Innovation Drive",
                        City:        "Austin",
                        State:       "TX",
                        PostalCode:  "73301",
                        Country:     "United States",
                        CountryCode: "US",
                },
                ContactInfo: ContactInfo{
                        Phone:          "+1-555-0456",
                        Email:          "info@techstart.com",
                        Website:        "https://techstart.com",
                        PrimaryContact: "Jane Doe",
                },
                Status:           "active",
                RiskLevel:        "medium",
                ComplianceStatus: "pending",
                CreatedBy:        testUser.ID,
                CreatedAt:        time.Now(),
                UpdatedAt:        time.Now(),
        }

        business3 := &amp;Business{
                ID:                 "business-003",
                Name:               "Global Trading Co",
                LegalName:          "Global Trading Company Ltd",
                RegistrationNumber: "GLOBAL003",
                TaxID:              "55-1234567",
                Industry:           "Wholesale Trade",
                IndustryCode:       "423990",
                BusinessType:       "Corporation",
                FoundedDate:        &amp;time.Time{},
                EmployeeCount:      150,
                AnnualRevenue:      &amp;[]float64{15000000.0}[0],
                Address: Address{
                        Street1:     "789 Commerce Blvd",
                        City:        "Miami",
                        State:       "FL",
                        PostalCode:  "33101",
                        Country:     "United States",
                        CountryCode: "US",
                },
                ContactInfo: ContactInfo{
                        Phone:          "+1-555-0789",
                        Email:          "sales@globaltrading.com",
                        Website:        "https://globaltrading.com",
                        PrimaryContact: "Mike Johnson",
                },
                Status:           "active",
                RiskLevel:        "high",
                ComplianceStatus: "non_compliant",
                CreatedBy:        adminUser.ID,
                CreatedAt:        time.Now(),
                UpdatedAt:        time.Now(),
        }

        // Create sample API keys
        apiKey1 := &amp;APIKey{
                ID:          "api-key-001",
                UserID:      adminUser.ID,
                Name:        "Admin API Key",
                KeyHash:     "admin_key_hash_placeholder",
                Role:        "admin",
                Permissions: "[\"read\", \"write\", \"admin\"]",
                Status:      "active",
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }

        apiKey2 := &amp;APIKey{
                ID:          "api-key-002",
                UserID:      testUser.ID,
                Name:        "Test API Key",
                KeyHash:     "test_key_hash_placeholder",
                Role:        "user",
                Permissions: "[\"read\", \"write\"]",
                Status:      "active",
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }

        apiKey3 := &amp;APIKey{
                ID:          "api-key-003",
                UserID:      analystUser.ID,
                Name:        "Analyst API Key",
                KeyHash:     "analyst_key_hash_placeholder",
                Role:        "analyst",
                Permissions: "[\"read\", \"write\", \"analytics\"]",
                Status:      "active",
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }

        return &amp;SeedData{
                Users:      []*User{adminUser, testUser, analystUser},
                Businesses: []*Business{business1, business2, business3},
                APIKeys:    []*APIKey{apiKey1, apiKey2, apiKey3},
        }
}</span>

// seedUsers seeds users into the database
func (s *Seeder) seedUsers(ctx context.Context, users []*User) error <span class="cov0" title="0">{
        for _, user := range users </span><span class="cov0" title="0">{
                // Check if user already exists
                existingUser, err := s.db.GetUserByEmail(ctx, user.Email)
                if err == nil &amp;&amp; existingUser != nil </span><span class="cov0" title="0">{
                        log.Printf("User %s already exists, skipping", user.Email)
                        continue</span>
                }

                // Create user
                <span class="cov0" title="0">if err := s.db.CreateUser(ctx, user); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create user %s: %w", user.Email, err)
                }</span>

                <span class="cov0" title="0">log.Printf("Created user: %s (%s)", user.Email, user.Role)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// seedBusinesses seeds businesses into the database
func (s *Seeder) seedBusinesses(ctx context.Context, businesses []*Business) error <span class="cov0" title="0">{
        for _, business := range businesses </span><span class="cov0" title="0">{
                // Check if business already exists
                existingBusiness, err := s.db.GetBusinessByRegistrationNumber(ctx, business.RegistrationNumber)
                if err == nil &amp;&amp; existingBusiness != nil </span><span class="cov0" title="0">{
                        log.Printf("Business %s already exists, skipping", business.RegistrationNumber)
                        continue</span>
                }

                // Create business
                <span class="cov0" title="0">if err := s.db.CreateBusiness(ctx, business); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create business %s: %w", business.RegistrationNumber, err)
                }</span>

                <span class="cov0" title="0">log.Printf("Created business: %s (%s)", business.Name, business.RegistrationNumber)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// seedAPIKeys seeds API keys into the database
func (s *Seeder) seedAPIKeys(ctx context.Context, apiKeys []*APIKey) error <span class="cov0" title="0">{
        for _, apiKey := range apiKeys </span><span class="cov0" title="0">{
                // Check if API key already exists
                existingAPIKey, err := s.db.GetAPIKeyByID(ctx, apiKey.ID)
                if err == nil &amp;&amp; existingAPIKey != nil </span><span class="cov0" title="0">{
                        log.Printf("API key %s already exists, skipping", apiKey.ID)
                        continue</span>
                }

                // Create API key
                <span class="cov0" title="0">if err := s.db.CreateAPIKey(ctx, apiKey); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create API key %s: %w", apiKey.ID, err)
                }</span>

                <span class="cov0" title="0">log.Printf("Created API key: %s for user %s", apiKey.Name, apiKey.UserID)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ClearSeedData clears all seed data from the database
func (s *Seeder) ClearSeedData(ctx context.Context) error <span class="cov0" title="0">{
        log.Println("Clearing seed data...")

        // Note: In a real implementation, you would implement proper cleanup
        // This is a simplified version that just logs the action
        log.Println("Seed data cleared successfully")
        return nil
}</span>

// GetSeedDataInfo returns information about the seed data
func (s *Seeder) GetSeedDataInfo() map[string]interface{} <span class="cov0" title="0">{
        seedData := s.createSeedData()

        return map[string]interface{}{
                "users": map[string]interface{}{
                        "count": len(seedData.Users),
                        "roles": []string{"admin", "user", "analyst"},
                },
                "businesses": map[string]interface{}{
                        "count":      len(seedData.Businesses),
                        "industries": []string{"Technology", "Software Development", "Wholesale Trade"},
                },
                "api_keys": map[string]interface{}{
                        "count": len(seedData.APIKeys),
                        "roles": []string{"admin", "user", "analyst"},
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package datasource

import (
        "context"
        "net"
        "net/http"
        "sync"
        "time"
)

// EnrichmentRequest carries fields used to look up external business data
type EnrichmentRequest struct {
        BusinessName       string
        RegistrationNumber string
        CountryCode        string
}

// EnrichmentResult is a normalized bundle of optional data used to improve classification
type EnrichmentResult struct {
        CleanBusinessName string
        Industry          string
        Description       string
        Keywords          []string
}

// DataSource defines a pluggable enrichment source (DB, 3rd-party API, etc.)
type DataSource interface {
        Name() string
        Enrich(ctx context.Context, req EnrichmentRequest) (EnrichmentResult, error)
        HealthCheck(ctx context.Context) error
}

// Aggregator queries multiple sources with a timeout and merges results
type Aggregator struct {
        sources []DataSource
        timeout time.Duration
        client  *http.Client
}

// NewAggregator constructs a new aggregator
func NewAggregator(sources []DataSource, timeout time.Duration) *Aggregator <span class="cov0" title="0">{
        if timeout &lt;= 0 </span><span class="cov0" title="0">{
                timeout = 2 * time.Second
        }</span>
        <span class="cov0" title="0">return &amp;Aggregator{sources: sources, timeout: timeout}</span>
}

// SetHTTPClient installs a shared pooled HTTP client for use by data sources that perform HTTP calls.
func (a *Aggregator) SetHTTPClient(client *http.Client) <span class="cov0" title="0">{
        a.client = client
}</span>

// NewPooledHTTPClient creates a pooled HTTP client based on provided settings.
func NewPooledHTTPClient(maxIdleConns, maxIdlePerHost int, idleTimeout, tlsHandshakeTimeout, expectContinueTimeout, requestTimeout time.Duration) *http.Client <span class="cov0" title="0">{
        transport := &amp;http.Transport{
                Proxy: http.ProxyFromEnvironment,
                DialContext: (&amp;net.Dialer{
                        Timeout:   30 * time.Second,
                        KeepAlive: 30 * time.Second,
                }).DialContext,
                ForceAttemptHTTP2:     true,
                MaxIdleConns:          maxIdleConns,
                MaxIdleConnsPerHost:   maxIdlePerHost,
                IdleConnTimeout:       idleTimeout,
                TLSHandshakeTimeout:   tlsHandshakeTimeout,
                ExpectContinueTimeout: expectContinueTimeout,
        }
        return &amp;http.Client{Transport: transport, Timeout: requestTimeout}
}</span>

// Enrich queries all sources concurrently, returns a merged result
func (a *Aggregator) Enrich(ctx context.Context, req EnrichmentRequest) (EnrichmentResult, error) <span class="cov0" title="0">{
        if len(a.sources) == 0 </span><span class="cov0" title="0">{
                return EnrichmentResult{}, nil
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, a.timeout)
        defer cancel()

        type out struct {
                res EnrichmentResult
                err error
        }

        ch := make(chan out, len(a.sources))
        var wg sync.WaitGroup
        wg.Add(len(a.sources))
        for _, src := range a.sources </span><span class="cov0" title="0">{
                src := src
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        res, err := src.Enrich(ctx, req)
                        select </span>{
                        case ch &lt;- out{res: res, err: err}:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                        }
                }()
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(ch)
        }</span>()

        <span class="cov0" title="0">merged := EnrichmentResult{}
        for o := range ch </span><span class="cov0" title="0">{
                if o.err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if merged.CleanBusinessName == "" &amp;&amp; o.res.CleanBusinessName != "" </span><span class="cov0" title="0">{
                        merged.CleanBusinessName = o.res.CleanBusinessName
                }</span>
                <span class="cov0" title="0">if merged.Industry == "" &amp;&amp; o.res.Industry != "" </span><span class="cov0" title="0">{
                        merged.Industry = o.res.Industry
                }</span>
                <span class="cov0" title="0">if merged.Description == "" &amp;&amp; o.res.Description != "" </span><span class="cov0" title="0">{
                        merged.Description = o.res.Description
                }</span>
                <span class="cov0" title="0">if len(o.res.Keywords) &gt; 0 </span><span class="cov0" title="0">{
                        // append unique keywords
                        exist := make(map[string]struct{}, len(merged.Keywords))
                        for _, k := range merged.Keywords </span><span class="cov0" title="0">{
                                exist[k] = struct{}{}
                        }</span>
                        <span class="cov0" title="0">for _, k := range o.res.Keywords </span><span class="cov0" title="0">{
                                if _, ok := exist[k]; !ok </span><span class="cov0" title="0">{
                                        merged.Keywords = append(merged.Keywords, k)
                                        exist[k] = struct{}{}
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return merged, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package datasource

import (
        "context"

        "github.com/pcraw4d/business-verification/internal/database"
)

// DBSource enriches data using our primary application database
type DBSource struct {
        db database.Database
}

func NewDBSource(db database.Database) *DBSource <span class="cov0" title="0">{
        return &amp;DBSource{db: db}
}</span>

func (s *DBSource) Name() string <span class="cov0" title="0">{ return "db_source" }</span>

func (s *DBSource) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        return s.db.Ping(ctx)
}</span>

func (s *DBSource) Enrich(ctx context.Context, req EnrichmentRequest) (EnrichmentResult, error) <span class="cov0" title="0">{
        // Try by registration number first
        if req.RegistrationNumber != "" </span><span class="cov0" title="0">{
                if b, err := s.db.GetBusinessByRegistrationNumber(ctx, req.RegistrationNumber); err == nil &amp;&amp; b != nil </span><span class="cov0" title="0">{
                        return mapBusinessToEnrichment(b), nil
                }</span>
        }
        // Fallback by name
        <span class="cov0" title="0">if req.BusinessName != "" </span><span class="cov0" title="0">{
                // Basic search and pick the first match
                if list, err := s.db.SearchBusinesses(ctx, req.BusinessName, 1, 0); err == nil &amp;&amp; len(list) &gt; 0 </span><span class="cov0" title="0">{
                        return mapBusinessToEnrichment(list[0]), nil
                }</span>
        }
        <span class="cov0" title="0">return EnrichmentResult{}, nil</span>
}

func mapBusinessToEnrichment(b *database.Business) EnrichmentResult <span class="cov0" title="0">{
        res := EnrichmentResult{
                CleanBusinessName: b.LegalName,
                Industry:          b.Industry,
                Description:       "",
        }
        // Derive simple keywords from known fields
        keys := []string{}
        if b.Industry != "" </span><span class="cov0" title="0">{
                keys = append(keys, b.Industry)
        }</span>
        <span class="cov0" title="0">if b.BusinessType != "" </span><span class="cov0" title="0">{
                keys = append(keys, b.BusinessType)
        }</span>
        <span class="cov0" title="0">res.Keywords = keys
        return res</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package datasource

import (
        "context"
        "time"
)

// SourceHealth represents the health status of a single data source
type SourceHealth struct {
        SourceName string        `json:"source_name"`
        Healthy    bool          `json:"healthy"`
        CheckedAt  time.Time     `json:"checked_at"`
        Latency    time.Duration `json:"latency"`
        Error      string        `json:"error,omitempty"`
}

// CheckHealth probes all configured sources and stores the latest status internally.
func (a *Aggregator) CheckHealth(ctx context.Context) []SourceHealth <span class="cov0" title="0">{
        statuses := make([]SourceHealth, len(a.sources))
        if len(a.sources) == 0 </span><span class="cov0" title="0">{
                return statuses
        }</span>
        <span class="cov0" title="0">for i, src := range a.sources </span><span class="cov0" title="0">{
                started := time.Now()
                err := src.HealthCheck(ctx)
                statuses[i] = SourceHealth{
                        SourceName: src.Name(),
                        Healthy:    err == nil,
                        CheckedAt:  time.Now(),
                        Latency:    time.Since(started),
                }
                if err != nil </span><span class="cov0" title="0">{
                        statuses[i].Error = err.Error()
                }</span>
        }
        <span class="cov0" title="0">return statuses</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package observability

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "runtime"
        "time"

        "github.com/pcraw4d/business-verification/internal/config"
)

// HealthStatus represents the health status of a component
type HealthStatus string

const (
        Healthy   HealthStatus = "healthy"
        Unhealthy HealthStatus = "unhealthy"
        Degraded  HealthStatus = "degraded"
)

// HealthCheck represents a health check result
type HealthCheck struct {
        Component   string                 `json:"component"`
        Status      HealthStatus           `json:"status"`
        Message     string                 `json:"message,omitempty"`
        Details     map[string]interface{} `json:"details,omitempty"`
        LastChecked time.Time              `json:"last_checked"`
        Duration    time.Duration          `json:"duration_ms"`
}

// HealthResponse represents the overall health response
type HealthResponse struct {
        Status      HealthStatus           `json:"status"`
        Timestamp   time.Time              `json:"timestamp"`
        Version     string                 `json:"version"`
        Environment string                 `json:"environment"`
        Checks      map[string]HealthCheck `json:"checks"`
        Summary     HealthSummary          `json:"summary"`
}

// HealthSummary provides a summary of health checks
type HealthSummary struct {
        Total     int `json:"total"`
        Healthy   int `json:"healthy"`
        Unhealthy int `json:"unhealthy"`
        Degraded  int `json:"degraded"`
}

// HealthChecker defines the interface for health checks
type HealthChecker interface {
        Check(ctx context.Context) HealthCheck
}

// HealthManager manages health checks
type HealthManager struct {
        config      *config.ObservabilityConfig
        logger      *Logger
        checkers    map[string]HealthChecker
        version     string
        environment string
}

// NewHealthManager creates a new health manager
func NewHealthManager(cfg *config.ObservabilityConfig, logger *Logger, version, environment string) *HealthManager <span class="cov0" title="0">{
        return &amp;HealthManager{
                config:      cfg,
                logger:      logger,
                checkers:    make(map[string]HealthChecker),
                version:     version,
                environment: environment,
        }
}</span>

// AddChecker adds a health checker
func (hm *HealthManager) AddChecker(name string, checker HealthChecker) <span class="cov0" title="0">{
        hm.checkers[name] = checker
}</span>

// RemoveChecker removes a health checker
func (hm *HealthManager) RemoveChecker(name string) <span class="cov0" title="0">{
        delete(hm.checkers, name)
}</span>

// CheckAll performs all health checks
func (hm *HealthManager) CheckAll(ctx context.Context) HealthResponse <span class="cov0" title="0">{
        start := time.Now()
        checks := make(map[string]HealthCheck)

        // Perform all health checks
        for name, checker := range hm.checkers </span><span class="cov0" title="0">{
                checkStart := time.Now()
                check := checker.Check(ctx)
                check.Duration = time.Since(checkStart)
                check.LastChecked = time.Now()
                checks[name] = check

                // Log health check result
                hm.logger.LogHealthCheck(name, string(check.Status), check.Details)
        }</span>

        // Calculate summary
        <span class="cov0" title="0">summary := hm.calculateSummary(checks)

        // Determine overall status
        overallStatus := hm.determineOverallStatus(summary)

        response := HealthResponse{
                Status:      overallStatus,
                Timestamp:   time.Now(),
                Version:     hm.version,
                Environment: hm.environment,
                Checks:      checks,
                Summary:     summary,
        }

        // Log overall health status
        hm.logger.WithFields(map[string]interface{}{
                "overall_status": string(overallStatus),
                "total_checks":   summary.Total,
                "healthy":        summary.Healthy,
                "unhealthy":      summary.Unhealthy,
                "degraded":       summary.Degraded,
                "duration_ms":    time.Since(start).Milliseconds(),
        }).Info("Health check completed")

        return response</span>
}

// calculateSummary calculates the summary of health checks
func (hm *HealthManager) calculateSummary(checks map[string]HealthCheck) HealthSummary <span class="cov0" title="0">{
        summary := HealthSummary{
                Total: len(checks),
        }

        for _, check := range checks </span><span class="cov0" title="0">{
                switch check.Status </span>{
                case Healthy:<span class="cov0" title="0">
                        summary.Healthy++</span>
                case Unhealthy:<span class="cov0" title="0">
                        summary.Unhealthy++</span>
                case Degraded:<span class="cov0" title="0">
                        summary.Degraded++</span>
                }
        }

        <span class="cov0" title="0">return summary</span>
}

// determineOverallStatus determines the overall health status
func (hm *HealthManager) determineOverallStatus(summary HealthSummary) HealthStatus <span class="cov0" title="0">{
        if summary.Unhealthy &gt; 0 </span><span class="cov0" title="0">{
                return Unhealthy
        }</span>
        <span class="cov0" title="0">if summary.Degraded &gt; 0 </span><span class="cov0" title="0">{
                return Degraded
        }</span>
        <span class="cov0" title="0">return Healthy</span>
}

// ServeHTTP serves the health check endpoint
func (hm *HealthManager) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        // Set response headers
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Cache-Control", "no-cache")

        // Perform health checks
        response := hm.CheckAll(ctx)

        // Set status code based on overall health
        switch response.Status </span>{
        case Healthy:<span class="cov0" title="0">
                w.WriteHeader(http.StatusOK)</span>
        case Degraded:<span class="cov0" title="0">
                w.WriteHeader(http.StatusOK)</span> // Still OK but degraded
        case Unhealthy:<span class="cov0" title="0">
                w.WriteHeader(http.StatusServiceUnavailable)</span>
        }

        // Encode response
        <span class="cov0" title="0">if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode health response", http.StatusInternalServerError)
                return
        }</span>
}

// BasicHealthChecker provides basic health checks
type BasicHealthChecker struct {
        config *config.ObservabilityConfig
}

// NewBasicHealthChecker creates a new basic health checker
func NewBasicHealthChecker(cfg *config.ObservabilityConfig) *BasicHealthChecker <span class="cov0" title="0">{
        return &amp;BasicHealthChecker{
                config: cfg,
        }
}</span>

// Check performs basic health checks
func (bhc *BasicHealthChecker) Check(ctx context.Context) HealthCheck <span class="cov0" title="0">{
        start := time.Now()

        // Check runtime statistics
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        details := map[string]interface{}{
                "goroutines":      runtime.NumGoroutine(),
                "memory_alloc":    m.Alloc,
                "memory_sys":      m.Sys,
                "memory_heap":     m.HeapAlloc,
                "memory_heap_sys": m.HeapSys,
                "gc_cycles":       m.NumGC,
                "uptime_seconds":  time.Since(start).Seconds(),
        }

        // Determine status based on memory usage
        status := Healthy
        message := "Application is healthy"

        // Check if memory usage is high (simple heuristic)
        if m.Sys &gt; 1&lt;&lt;30 </span><span class="cov0" title="0">{ // 1GB
                status = Degraded
                message = "High memory usage detected"
        }</span>

        // Check if too many goroutines
        <span class="cov0" title="0">if runtime.NumGoroutine() &gt; 1000 </span><span class="cov0" title="0">{
                status = Unhealthy
                message = "Too many goroutines"
        }</span>

        <span class="cov0" title="0">return HealthCheck{
                Component:   "application",
                Status:      status,
                Message:     message,
                Details:     details,
                LastChecked: time.Now(),
                Duration:    time.Since(start),
        }</span>
}

// DatabaseHealthChecker provides database health checks
type DatabaseHealthChecker struct {
        pingFunc func(context.Context) error
}

// NewDatabaseHealthChecker creates a new database health checker
func NewDatabaseHealthChecker(pingFunc func(context.Context) error) *DatabaseHealthChecker <span class="cov0" title="0">{
        return &amp;DatabaseHealthChecker{
                pingFunc: pingFunc,
        }
}</span>

// Check performs database health checks
func (dhc *DatabaseHealthChecker) Check(ctx context.Context) HealthCheck <span class="cov0" title="0">{
        start := time.Now()

        if dhc.pingFunc == nil </span><span class="cov0" title="0">{
                return HealthCheck{
                        Component:   "database",
                        Status:      Unhealthy,
                        Message:     "Database checker not configured",
                        LastChecked: time.Now(),
                        Duration:    time.Since(start),
                }
        }</span>

        <span class="cov0" title="0">err := dhc.pingFunc(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return HealthCheck{
                        Component: "database",
                        Status:    Unhealthy,
                        Message:   fmt.Sprintf("Database connection failed: %v", err),
                        Details: map[string]interface{}{
                                "error": err.Error(),
                        },
                        LastChecked: time.Now(),
                        Duration:    time.Since(start),
                }
        }</span>

        <span class="cov0" title="0">return HealthCheck{
                Component:   "database",
                Status:      Healthy,
                Message:     "Database connection is healthy",
                LastChecked: time.Now(),
                Duration:    time.Since(start),
        }</span>
}

// ExternalServiceHealthChecker provides external service health checks
type ExternalServiceHealthChecker struct {
        serviceName string
        checkFunc   func(context.Context) error
}

// NewExternalServiceHealthChecker creates a new external service health checker
func NewExternalServiceHealthChecker(serviceName string, checkFunc func(context.Context) error) *ExternalServiceHealthChecker <span class="cov0" title="0">{
        return &amp;ExternalServiceHealthChecker{
                serviceName: serviceName,
                checkFunc:   checkFunc,
        }
}</span>

// Check performs external service health checks
func (eshc *ExternalServiceHealthChecker) Check(ctx context.Context) HealthCheck <span class="cov0" title="0">{
        start := time.Now()

        if eshc.checkFunc == nil </span><span class="cov0" title="0">{
                return HealthCheck{
                        Component:   eshc.serviceName,
                        Status:      Unhealthy,
                        Message:     "External service checker not configured",
                        LastChecked: time.Now(),
                        Duration:    time.Since(start),
                }
        }</span>

        <span class="cov0" title="0">err := eshc.checkFunc(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return HealthCheck{
                        Component: eshc.serviceName,
                        Status:    Unhealthy,
                        Message:   fmt.Sprintf("External service check failed: %v", err),
                        Details: map[string]interface{}{
                                "error": err.Error(),
                        },
                        LastChecked: time.Now(),
                        Duration:    time.Since(start),
                }
        }</span>

        <span class="cov0" title="0">return HealthCheck{
                Component:   eshc.serviceName,
                Status:      Healthy,
                Message:     fmt.Sprintf("%s is healthy", eshc.serviceName),
                LastChecked: time.Now(),
                Duration:    time.Since(start),
        }</span>
}

// StartHealthServer starts the health check server
func (hm *HealthManager) StartHealthServer(ctx context.Context) error <span class="cov0" title="0">{
        mux := http.NewServeMux()
        mux.Handle(hm.config.HealthCheckPath, hm)

        server := &amp;http.Server{
                Addr:    ":8081", // Health check port
                Handler: mux,
        }

        go func() </span><span class="cov0" title="0">{
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        fmt.Printf("Health server error: %v\n", err)
                }</span>
        }()

        // Wait for context cancellation
        <span class="cov0" title="0">&lt;-ctx.Done()

        // Graceful shutdown
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        return server.Shutdown(shutdownCtx)</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package observability

import (
        "context"
        "fmt"
        "io"
        "log/slog"
        "os"
        "time"

        "github.com/pcraw4d/business-verification/internal/config"
)

// Logger wraps slog.Logger with additional functionality
type Logger struct {
        *slog.Logger
        config *config.ObservabilityConfig
}

// NewLogger creates a new logger with the given configuration
func NewLogger(cfg *config.ObservabilityConfig) *Logger <span class="cov8" title="1">{
        var handler slog.Handler

        // Create the appropriate handler based on log format
        switch cfg.LogFormat </span>{
        case "json":<span class="cov8" title="1">
                handler = slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                        Level: getLogLevel(cfg.LogLevel),
                })</span>
        case "text":<span class="cov8" title="1">
                handler = slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{
                        Level: getLogLevel(cfg.LogLevel),
                })</span>
        default:<span class="cov0" title="0">
                // Default to JSON format
                handler = slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                        Level: getLogLevel(cfg.LogLevel),
                })</span>
        }

        <span class="cov8" title="1">logger := slog.New(handler)
        return &amp;Logger{
                Logger: logger,
                config: cfg,
        }</span>
}

// getLogLevel converts string log level to slog.Level
func getLogLevel(level string) slog.Level <span class="cov8" title="1">{
        switch level </span>{
        case "debug":<span class="cov8" title="1">
                return slog.LevelDebug</span>
        case "info":<span class="cov8" title="1">
                return slog.LevelInfo</span>
        case "warn":<span class="cov8" title="1">
                return slog.LevelWarn</span>
        case "error":<span class="cov8" title="1">
                return slog.LevelError</span>
        default:<span class="cov8" title="1">
                return slog.LevelInfo</span>
        }
}

// WithContext adds context information to the logger
func (l *Logger) WithContext(ctx context.Context) *Logger <span class="cov8" title="1">{
        // Extract request ID from context if available
        if requestID := getRequestID(ctx); requestID != "" </span><span class="cov8" title="1">{
                return &amp;Logger{
                        Logger: l.Logger.With("request_id", requestID),
                        config: l.config,
                }
        }</span>
        <span class="cov8" title="1">return l</span>
}

// WithFields adds multiple fields to the logger
func (l *Logger) WithFields(fields map[string]interface{}) *Logger <span class="cov8" title="1">{
        attrs := make([]any, 0, len(fields)*2)
        for key, value := range fields </span><span class="cov8" title="1">{
                attrs = append(attrs, key, value)
        }</span>
        <span class="cov8" title="1">return &amp;Logger{
                Logger: l.Logger.With(attrs...),
                config: l.config,
        }</span>
}

// WithError adds an error field to the logger
func (l *Logger) WithError(err error) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                Logger: l.Logger.With("error", err.Error()),
                config: l.config,
        }
}</span>

// WithUser adds user information to the logger
func (l *Logger) WithUser(userID string) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                Logger: l.Logger.With("user_id", userID),
                config: l.config,
        }
}</span>

// WithComponent adds component information to the logger
func (l *Logger) WithComponent(component string) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                Logger: l.Logger.With("component", component),
                config: l.config,
        }
}</span>

// WithOperation adds operation information to the logger
func (l *Logger) WithOperation(operation string) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                Logger: l.Logger.With("operation", operation),
                config: l.config,
        }
}</span>

// WithDuration adds duration information to the logger
func (l *Logger) WithDuration(duration time.Duration) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                Logger: l.Logger.With("duration_ms", duration.Milliseconds()),
                config: l.config,
        }
}</span>

// WithRequest adds HTTP request information to the logger
func (l *Logger) WithRequest(method, path, userAgent string, statusCode int) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                Logger: l.Logger.With(
                        "method", method,
                        "path", path,
                        "user_agent", userAgent,
                        "status_code", statusCode,
                ),
                config: l.config,
        }
}</span>

// WithDatabase adds database operation information to the logger
func (l *Logger) WithDatabase(operation, table string, rowsAffected int64) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                Logger: l.Logger.With(
                        "db_operation", operation,
                        "db_table", table,
                        "rows_affected", rowsAffected,
                ),
                config: l.config,
        }
}</span>

// WithExternalService adds external service information to the logger
func (l *Logger) WithExternalService(service, endpoint string, statusCode int) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                Logger: l.Logger.With(
                        "external_service", service,
                        "endpoint", endpoint,
                        "status_code", statusCode,
                ),
                config: l.config,
        }
}</span>

// LogAPIRequest logs an API request with timing information
func (l *Logger) LogAPIRequest(ctx context.Context, method, path, userAgent string, statusCode int, duration time.Duration) <span class="cov8" title="1">{
        l.WithContext(ctx).
                WithRequest(method, path, userAgent, statusCode).
                WithDuration(duration).
                Info("API request completed")
}</span>

// LogDatabaseOperation logs a database operation
func (l *Logger) LogDatabaseOperation(ctx context.Context, operation, table string, rowsAffected int64, duration time.Duration, err error) <span class="cov8" title="1">{
        logger := l.WithContext(ctx).
                WithDatabase(operation, table, rowsAffected).
                WithDuration(duration)

        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("Database operation failed")
        }</span> else<span class="cov8" title="1"> {
                logger.Info("Database operation completed")
        }</span>
}

// LogExternalServiceCall logs an external service call
func (l *Logger) LogExternalServiceCall(ctx context.Context, service, endpoint string, statusCode int, duration time.Duration, err error) <span class="cov8" title="1">{
        logger := l.WithContext(ctx).
                WithExternalService(service, endpoint, statusCode).
                WithDuration(duration)

        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("External service call failed")
        }</span> else<span class="cov8" title="1"> {
                logger.Info("External service call completed")
        }</span>
}

// LogBusinessEvent logs a business event
func (l *Logger) LogBusinessEvent(ctx context.Context, eventType, eventID string, details map[string]interface{}) <span class="cov8" title="1">{
        logger := l.WithContext(ctx).
                WithFields(map[string]interface{}{
                        "event_type": eventType,
                        "event_id":   eventID,
                })

        if len(details) &gt; 0 </span><span class="cov8" title="1">{
                logger = logger.WithFields(details)
        }</span>

        <span class="cov8" title="1">logger.Info("Business event occurred")</span>
}

// LogSecurityEvent logs a security event
func (l *Logger) LogSecurityEvent(ctx context.Context, eventType, userID, ipAddress string, details map[string]interface{}) <span class="cov8" title="1">{
        logger := l.WithContext(ctx).
                WithUser(userID).
                WithFields(map[string]interface{}{
                        "event_type": eventType,
                        "ip_address": ipAddress,
                })

        if len(details) &gt; 0 </span><span class="cov8" title="1">{
                logger = logger.WithFields(details)
        }</span>

        <span class="cov8" title="1">logger.Warn("Security event detected")</span>
}

// LogPerformance logs performance metrics
func (l *Logger) LogPerformance(ctx context.Context, metric string, value float64, unit string) <span class="cov8" title="1">{
        l.WithContext(ctx).
                WithFields(map[string]interface{}{
                        "metric": metric,
                        "value":  value,
                        "unit":   unit,
                }).
                Info("Performance metric recorded")
}</span>

// LogStartup logs application startup information
func (l *Logger) LogStartup(version, commitHash, buildTime string) <span class="cov8" title="1">{
        l.WithFields(map[string]interface{}{
                "version":     version,
                "commit_hash": commitHash,
                "build_time":  buildTime,
                "pid":         os.Getpid(),
        }).Info("Application starting")
}</span>

// LogShutdown logs application shutdown information
func (l *Logger) LogShutdown(reason string) <span class="cov8" title="1">{
        l.WithFields(map[string]interface{}{
                "reason": reason,
                "pid":    os.Getpid(),
        }).Info("Application shutting down")
}</span>

// LogHealthCheck logs health check results
func (l *Logger) LogHealthCheck(component string, status string, details map[string]interface{}) <span class="cov8" title="1">{
        logger := l.WithComponent(component).
                WithFields(map[string]interface{}{
                        "status": status,
                })

        if len(details) &gt; 0 </span><span class="cov8" title="1">{
                logger = logger.WithFields(details)
        }</span>

        <span class="cov8" title="1">switch status </span>{
        case "healthy":<span class="cov8" title="1">
                logger.Info("Health check passed")</span>
        case "unhealthy":<span class="cov0" title="0">
                logger.Error("Health check failed")</span>
        case "degraded":<span class="cov0" title="0">
                logger.Warn("Health check degraded")</span>
        default:<span class="cov0" title="0">
                logger.Info("Health check completed")</span>
        }
}

// getRequestID extracts request ID from context
func getRequestID(ctx context.Context) string <span class="cov8" title="1">{
        if ctx == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Try to get request ID from context
        <span class="cov8" title="1">if requestID, ok := ctx.Value("request_id").(string); ok </span><span class="cov8" title="1">{
                return requestID
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// SetOutput sets the output destination for the logger
func (l *Logger) SetOutput(w io.Writer) <span class="cov0" title="0">{
        var handler slog.Handler

        switch l.config.LogFormat </span>{
        case "json":<span class="cov0" title="0">
                handler = slog.NewJSONHandler(w, &amp;slog.HandlerOptions{
                        Level: getLogLevel(l.config.LogLevel),
                })</span>
        case "text":<span class="cov0" title="0">
                handler = slog.NewTextHandler(w, &amp;slog.HandlerOptions{
                        Level: getLogLevel(l.config.LogLevel),
                })</span>
        default:<span class="cov0" title="0">
                handler = slog.NewJSONHandler(w, &amp;slog.HandlerOptions{
                        Level: getLogLevel(l.config.LogLevel),
                })</span>
        }

        <span class="cov0" title="0">l.Logger = slog.New(handler)</span>
}

// String returns a string representation of the logger configuration
func (l *Logger) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("Logger{level=%s, format=%s}", l.config.LogLevel, l.config.LogFormat)
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package observability

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/pcraw4d/business-verification/internal/config"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// Metrics wraps Prometheus metrics with additional functionality
type Metrics struct {
        config *config.ObservabilityConfig

        // HTTP metrics
        httpRequestsTotal    *prometheus.CounterVec
        httpRequestDuration  *prometheus.HistogramVec
        httpRequestsInFlight *prometheus.GaugeVec

        // Database metrics
        dbOperationsTotal   *prometheus.CounterVec
        dbOperationDuration *prometheus.HistogramVec
        dbConnectionsActive *prometheus.GaugeVec

        // Business metrics
        businessClassificationsTotal *prometheus.CounterVec
        classificationDuration       *prometheus.HistogramVec
        riskAssessmentsTotal         *prometheus.CounterVec
        complianceChecksTotal        *prometheus.CounterVec

        // External service metrics
        externalServiceCallsTotal   *prometheus.CounterVec
        externalServiceCallDuration *prometheus.HistogramVec

        // System metrics
        goroutinesActive *prometheus.GaugeVec
        memoryUsage      *prometheus.GaugeVec
        cpuUsage         *prometheus.GaugeVec

        // Custom metrics
        customMetrics map[string]prometheus.Collector
}

// NewMetrics creates a new metrics collector
func NewMetrics(cfg *config.ObservabilityConfig) (*Metrics, error) <span class="cov0" title="0">{
        if !cfg.MetricsEnabled </span><span class="cov0" title="0">{
                return &amp;Metrics{
                        config:        cfg,
                        customMetrics: make(map[string]prometheus.Collector),
                }, nil
        }</span>

        <span class="cov0" title="0">metrics := &amp;Metrics{
                config:        cfg,
                customMetrics: make(map[string]prometheus.Collector),
        }

        // Initialize HTTP metrics
        metrics.httpRequestsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "http_requests_total",
                        Help: "Total number of HTTP requests",
                },
                []string{"method", "path", "status_code"},
        )

        metrics.httpRequestDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_request_duration_seconds",
                        Help:    "HTTP request duration in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"method", "path"},
        )

        metrics.httpRequestsInFlight = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "http_requests_in_flight",
                        Help: "Current number of HTTP requests being processed",
                },
                []string{"method", "path"},
        )

        // Initialize database metrics
        metrics.dbOperationsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "db_operations_total",
                        Help: "Total number of database operations",
                },
                []string{"operation", "table", "status"},
        )

        metrics.dbOperationDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "db_operation_duration_seconds",
                        Help:    "Database operation duration in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"operation", "table"},
        )

        metrics.dbConnectionsActive = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "db_connections_active",
                        Help: "Current number of active database connections",
                },
                []string{"database"},
        )

        // Initialize business metrics
        metrics.businessClassificationsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "business_classifications_total",
                        Help: "Total number of business classifications",
                },
                []string{"status", "confidence_level"},
        )

        metrics.classificationDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "classification_duration_seconds",
                        Help:    "Duration of classification operations in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"type"}, // single|batch
        )

        metrics.riskAssessmentsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "risk_assessments_total",
                        Help: "Total number of risk assessments",
                },
                []string{"status", "risk_level"},
        )

        metrics.complianceChecksTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "compliance_checks_total",
                        Help: "Total number of compliance checks",
                },
                []string{"status", "compliance_type"},
        )

        // Initialize external service metrics
        metrics.externalServiceCallsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "external_service_calls_total",
                        Help: "Total number of external service calls",
                },
                []string{"service", "endpoint", "status_code"},
        )

        metrics.externalServiceCallDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "external_service_call_duration_seconds",
                        Help:    "External service call duration in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"service", "endpoint"},
        )

        // Initialize system metrics
        metrics.goroutinesActive = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "goroutines_active",
                        Help: "Current number of active goroutines",
                },
                []string{"component"},
        )

        metrics.memoryUsage = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "memory_usage_bytes",
                        Help: "Current memory usage in bytes",
                },
                []string{"type"},
        )

        metrics.cpuUsage = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cpu_usage_percent",
                        Help: "Current CPU usage percentage",
                },
                []string{"type"},
        )

        // Register all metrics
        collectors := []prometheus.Collector{
                metrics.httpRequestsTotal,
                metrics.httpRequestDuration,
                metrics.httpRequestsInFlight,
                metrics.dbOperationsTotal,
                metrics.dbOperationDuration,
                metrics.dbConnectionsActive,
                metrics.businessClassificationsTotal,
                metrics.classificationDuration,
                metrics.riskAssessmentsTotal,
                metrics.complianceChecksTotal,
                metrics.externalServiceCallsTotal,
                metrics.externalServiceCallDuration,
                metrics.goroutinesActive,
                metrics.memoryUsage,
                metrics.cpuUsage,
        }

        for _, collector := range collectors </span><span class="cov0" title="0">{
                if err := prometheus.Register(collector); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to register metric: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return metrics, nil</span>
}

// RecordHTTPRequest records an HTTP request
func (m *Metrics) RecordHTTPRequest(method, path string, statusCode int, duration time.Duration) <span class="cov0" title="0">{
        if !m.config.MetricsEnabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">m.httpRequestsTotal.WithLabelValues(method, path, fmt.Sprintf("%d", statusCode)).Inc()
        m.httpRequestDuration.WithLabelValues(method, path).Observe(duration.Seconds())</span>
}

// RecordHTTPRequestStart records the start of an HTTP request
func (m *Metrics) RecordHTTPRequestStart(method, path string) <span class="cov0" title="0">{
        if !m.config.MetricsEnabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">m.httpRequestsInFlight.WithLabelValues(method, path).Inc()</span>
}

// RecordHTTPRequestEnd records the end of an HTTP request
func (m *Metrics) RecordHTTPRequestEnd(method, path string) <span class="cov0" title="0">{
        if !m.config.MetricsEnabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">m.httpRequestsInFlight.WithLabelValues(method, path).Dec()</span>
}

// RecordDatabaseOperation records a database operation
func (m *Metrics) RecordDatabaseOperation(operation, table string, status string, duration time.Duration) <span class="cov0" title="0">{
        if !m.config.MetricsEnabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">m.dbOperationsTotal.WithLabelValues(operation, table, status).Inc()
        m.dbOperationDuration.WithLabelValues(operation, table).Observe(duration.Seconds())</span>
}

// RecordDatabaseConnections records the number of active database connections
func (m *Metrics) RecordDatabaseConnections(database string, count int) <span class="cov0" title="0">{
        if !m.config.MetricsEnabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">m.dbConnectionsActive.WithLabelValues(database).Set(float64(count))</span>
}

// RecordBusinessClassification records a business classification
func (m *Metrics) RecordBusinessClassification(status, confidenceLevel string) <span class="cov0" title="0">{
        if !m.config.MetricsEnabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">m.businessClassificationsTotal.WithLabelValues(status, confidenceLevel).Inc()</span>
}

// RecordClassificationDuration records the duration of a classification operation
func (m *Metrics) RecordClassificationDuration(opType string, duration time.Duration) <span class="cov0" title="0">{
        if !m.config.MetricsEnabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">m.classificationDuration.WithLabelValues(opType).Observe(duration.Seconds())</span>
}

// RecordRiskAssessment records a risk assessment
func (m *Metrics) RecordRiskAssessment(status, riskLevel string) <span class="cov0" title="0">{
        if !m.config.MetricsEnabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">m.riskAssessmentsTotal.WithLabelValues(status, riskLevel).Inc()</span>
}

// RecordComplianceCheck records a compliance check
func (m *Metrics) RecordComplianceCheck(status, complianceType string) <span class="cov0" title="0">{
        if !m.config.MetricsEnabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">m.complianceChecksTotal.WithLabelValues(status, complianceType).Inc()</span>
}

// RecordExternalServiceCall records an external service call
func (m *Metrics) RecordExternalServiceCall(service, endpoint string, statusCode int, duration time.Duration) <span class="cov0" title="0">{
        if !m.config.MetricsEnabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">m.externalServiceCallsTotal.WithLabelValues(service, endpoint, fmt.Sprintf("%d", statusCode)).Inc()
        m.externalServiceCallDuration.WithLabelValues(service, endpoint).Observe(duration.Seconds())</span>
}

// RecordGoroutines records the number of active goroutines
func (m *Metrics) RecordGoroutines(component string, count int) <span class="cov0" title="0">{
        if !m.config.MetricsEnabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">m.goroutinesActive.WithLabelValues(component).Set(float64(count))</span>
}

// RecordMemoryUsage records memory usage
func (m *Metrics) RecordMemoryUsage(memoryType string, bytes int64) <span class="cov0" title="0">{
        if !m.config.MetricsEnabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">m.memoryUsage.WithLabelValues(memoryType).Set(float64(bytes))</span>
}

// RecordCPUUsage records CPU usage
func (m *Metrics) RecordCPUUsage(cpuType string, percentage float64) <span class="cov0" title="0">{
        if !m.config.MetricsEnabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">m.cpuUsage.WithLabelValues(cpuType).Set(percentage)</span>
}

// AddCustomMetric adds a custom metric
func (m *Metrics) AddCustomMetric(name string, collector prometheus.Collector) error <span class="cov0" title="0">{
        if !m.config.MetricsEnabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := prometheus.Register(collector); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register custom metric %s: %w", name, err)
        }</span>

        <span class="cov0" title="0">m.customMetrics[name] = collector
        return nil</span>
}

// RemoveCustomMetric removes a custom metric
func (m *Metrics) RemoveCustomMetric(name string) error <span class="cov0" title="0">{
        if !m.config.MetricsEnabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if collector, exists := m.customMetrics[name]; exists </span><span class="cov0" title="0">{
                if prometheus.Unregister(collector) </span><span class="cov0" title="0">{
                        delete(m.customMetrics, name)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ServeHTTP serves the metrics endpoint
func (m *Metrics) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !m.config.MetricsEnabled </span><span class="cov0" title="0">{
                http.Error(w, "Metrics disabled", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov0" title="0">promhttp.Handler().ServeHTTP(w, r)</span>
}

// StartMetricsServer starts the metrics server
func (m *Metrics) StartMetricsServer(ctx context.Context) error <span class="cov0" title="0">{
        if !m.config.MetricsEnabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">mux := http.NewServeMux()
        mux.Handle(m.config.MetricsPath, m)

        server := &amp;http.Server{
                Addr:    fmt.Sprintf(":%d", m.config.MetricsPort),
                Handler: mux,
        }

        go func() </span><span class="cov0" title="0">{
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        // Log error but don't return it since this is running in a goroutine
                        fmt.Printf("Metrics server error: %v\n", err)
                }</span>
        }()

        // Wait for context cancellation
        <span class="cov0" title="0">&lt;-ctx.Done()

        // Graceful shutdown
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        return server.Shutdown(shutdownCtx)</span>
}

// IsEnabled returns whether metrics are enabled
func (m *Metrics) IsEnabled() bool <span class="cov0" title="0">{
        return m.config.MetricsEnabled
}</span>

// String returns a string representation of the metrics configuration
func (m *Metrics) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Metrics{enabled=%t, port=%d, path=%s}", m.config.MetricsEnabled, m.config.MetricsPort, m.config.MetricsPath)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package observability

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "net/http"
        "strings"
        "time"
)

// RequestIDKey is the context key for request ID
const RequestIDKey = "request_id"

// RequestIDHeader is the HTTP header for request ID
const RequestIDHeader = "X-Request-ID"

// RequestIDMiddleware adds request ID to the context
func RequestIDMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Get request ID from header or generate new one
                requestID := r.Header.Get(RequestIDHeader)
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = GenerateRequestID()
                }</span>

                // Add request ID to context
                <span class="cov0" title="0">ctx := context.WithValue(r.Context(), RequestIDKey, requestID)

                // Add request ID to response headers
                w.Header().Set(RequestIDHeader, requestID)

                // Call next handler with updated context
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

// GenerateRequestID generates a new request ID
func GenerateRequestID() string <span class="cov0" title="0">{
        bytes := make([]byte, 16)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                // Fallback to timestamp-based ID if crypto/rand fails
                return fmt.Sprintf("req-%d", time.Now().UnixNano())
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes)</span>
}

// GetRequestID extracts request ID from context
func GetRequestID(ctx context.Context) string <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if requestID, ok := ctx.Value(RequestIDKey).(string); ok </span><span class="cov0" title="0">{
                return requestID
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// WithRequestID adds request ID to context
func WithRequestID(ctx context.Context, requestID string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, RequestIDKey, requestID)
}</span>

// ExtractRequestIDFromHeaders extracts request ID from HTTP headers
func ExtractRequestIDFromHeaders(headers map[string]string) string <span class="cov0" title="0">{
        for key, value := range headers </span><span class="cov0" title="0">{
                if strings.EqualFold(key, RequestIDHeader) </span><span class="cov0" title="0">{
                        return value
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// InjectRequestIDIntoHeaders injects request ID into HTTP headers
func InjectRequestIDIntoHeaders(headers map[string]string, requestID string) <span class="cov0" title="0">{
        headers[RequestIDHeader] = requestID
}</span>

// PropagateRequestID propagates request ID through context
func PropagateRequestID(ctx context.Context, requestID string) context.Context <span class="cov0" title="0">{
        if requestID == "" </span><span class="cov0" title="0">{
                requestID = GenerateRequestID()
        }</span>
        <span class="cov0" title="0">return WithRequestID(ctx, requestID)</span>
}

// RequestIDFromContext extracts request ID from context with fallback
func RequestIDFromContext(ctx context.Context) string <span class="cov0" title="0">{
        requestID := GetRequestID(ctx)
        if requestID == "" </span><span class="cov0" title="0">{
                requestID = GenerateRequestID()
        }</span>
        <span class="cov0" title="0">return requestID</span>
}

// RequestIDMiddlewareWithLogger adds request ID to the context and logs it
func RequestIDMiddlewareWithLogger(logger *Logger) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Get request ID from header or generate new one
                        requestID := r.Header.Get(RequestIDHeader)
                        if requestID == "" </span><span class="cov0" title="0">{
                                requestID = GenerateRequestID()
                        }</span>

                        // Add request ID to context
                        <span class="cov0" title="0">ctx := context.WithValue(r.Context(), RequestIDKey, requestID)

                        // Add request ID to response headers
                        w.Header().Set(RequestIDHeader, requestID)

                        // Log request with request ID
                        logger.WithContext(ctx).WithFields(map[string]interface{}{
                                "method":      r.Method,
                                "path":        r.URL.Path,
                                "user_agent":  r.UserAgent(),
                                "remote_addr": r.RemoteAddr,
                        }).Info("Request started")

                        // Call next handler with updated context
                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                })
        }
}

// RequestIDMiddlewareWithTracer adds request ID to the context and traces it
// TODO: Re-enable when tracing is fully implemented
func RequestIDMiddlewareWithTracer(tracer interface{}) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Get request ID from header or generate new one
                        requestID := r.Header.Get(RequestIDHeader)
                        if requestID == "" </span><span class="cov0" title="0">{
                                requestID = GenerateRequestID()
                        }</span>

                        // Add request ID to context
                        <span class="cov0" title="0">ctx := context.WithValue(r.Context(), RequestIDKey, requestID)

                        // TODO: Re-enable tracing when tracer is fully implemented
                        // Start span with request information
                        // spanCtx, span := tracer.StartSpanWithRequest(ctx, r.Method, r.URL.Path, r.UserAgent())
                        // defer span.End()

                        // Add request ID to span attributes
                        // tracer.SetAttributes(spanCtx, map[string]interface{}{
                        //         "request_id": requestID,
                        // })

                        // Add request ID to response headers
                        w.Header().Set(RequestIDHeader, requestID)

                        // Call next handler with updated context
                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                })
        }
}

// RequestIDMiddlewareWithMetrics adds request ID to the context and records metrics
func RequestIDMiddlewareWithMetrics(metrics *Metrics) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Get request ID from header or generate new one
                        requestID := r.Header.Get(RequestIDHeader)
                        if requestID == "" </span><span class="cov0" title="0">{
                                requestID = GenerateRequestID()
                        }</span>

                        // Add request ID to context
                        <span class="cov0" title="0">ctx := context.WithValue(r.Context(), RequestIDKey, requestID)

                        // Record request start
                        metrics.RecordHTTPRequestStart(r.Method, r.URL.Path)

                        // Create response writer wrapper to capture status code
                        wrappedWriter := &amp;responseWriter{ResponseWriter: w, statusCode: 200}

                        // Call next handler with updated context
                        next.ServeHTTP(wrappedWriter, r.WithContext(ctx))

                        // Record request end
                        metrics.RecordHTTPRequestEnd(r.Method, r.URL.Path)</span>
                })
        }
}

// responseWriter wraps http.ResponseWriter to capture status code
type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

// RequestIDMiddlewareWithAll adds request ID to the context with logging, tracing, and metrics
func RequestIDMiddlewareWithAll(logger *Logger, tracer interface{}, metrics *Metrics) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        start := time.Now()

                        // Get request ID from header or generate new one
                        requestID := r.Header.Get(RequestIDHeader)
                        if requestID == "" </span><span class="cov0" title="0">{
                                requestID = GenerateRequestID()
                        }</span>

                        // Add request ID to context
                        <span class="cov0" title="0">ctx := context.WithValue(r.Context(), RequestIDKey, requestID)

                        // TODO: Re-enable tracing when tracer is fully implemented
                        // Start span with request information
                        // spanCtx, span := tracer.StartSpanWithRequest(ctx, r.Method, r.URL.Path, r.UserAgent())
                        // defer span.End()

                        // Add request ID to span attributes
                        // tracer.SetAttributes(spanCtx, map[string]interface{}{
                        //         "request_id": requestID,
                        // })

                        // Log request start with request ID
                        logger.WithContext(ctx).WithFields(map[string]interface{}{
                                "method":      r.Method,
                                "path":        r.URL.Path,
                                "user_agent":  r.UserAgent(),
                                "remote_addr": r.RemoteAddr,
                        }).Info("Request started")

                        // Record request start
                        metrics.RecordHTTPRequestStart(r.Method, r.URL.Path)

                        // Create response writer wrapper to capture status code
                        wrappedWriter := &amp;responseWriter{ResponseWriter: w, statusCode: 200}

                        // Call next handler with updated context
                        next.ServeHTTP(wrappedWriter, r.WithContext(ctx))

                        // Calculate duration
                        duration := time.Since(start)

                        // Record request end
                        metrics.RecordHTTPRequestEnd(r.Method, r.URL.Path)

                        // Record HTTP request metrics
                        metrics.RecordHTTPRequest(r.Method, r.URL.Path, wrappedWriter.statusCode, duration)

                        // Log request completion
                        logger.WithContext(ctx).WithRequest(r.Method, r.URL.Path, r.UserAgent(), wrappedWriter.statusCode).
                                WithDuration(duration).
                                Info("Request completed")

                        // Add request ID to response headers
                        w.Header().Set(RequestIDHeader, requestID)</span>
                })
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
