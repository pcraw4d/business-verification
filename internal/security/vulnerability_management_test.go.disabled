package security

import (
	"context"
	"encoding/json"
	"testing"
	"time"
)

func TestNewVulnerabilityManagementSystem(t *testing.T) {
	logger := createTestLogger()
	config := VulnerabilityManagementConfig{
		AutoAssignmentEnabled: true,
		DefaultPriority:       PriorityMedium,
		ResolutionTimeframes: map[SecuritySeverity]time.Duration{
			SeverityCritical: 24 * time.Hour,
			SeverityHigh:     72 * time.Hour,
			SeverityMedium:   7 * 24 * time.Hour,
		},
		RiskScoringEnabled: true,
		RetentionDays:      90,
	}

	vms := NewVulnerabilityManagementSystem(logger, config)

	if vms == nil {
		t.Fatal("Expected vulnerability management system to be created, got nil")
	}

	if vms.logger != logger {
		t.Error("Expected logger to be set correctly")
	}

	if vms.config.DefaultPriority != PriorityMedium {
		t.Error("Expected default priority to be set correctly")
	}
}

func TestRegisterVulnerability(t *testing.T) {
	logger := createTestLogger()
	config := VulnerabilityManagementConfig{
		AutoAssignmentEnabled: true,
		DefaultPriority:       PriorityMedium,
		RiskScoringEnabled:    true,
		RetentionDays:         90,
	}

	vms := NewVulnerabilityManagementSystem(logger, config)

	vuln := &Vulnerability{
		Title:        "Test Vulnerability",
		Description:  "This is a test vulnerability",
		Severity:     SeverityHigh,
		CVE:          "CVE-2023-1234",
		Package:      "test-package",
		Version:      "1.0.0",
		FixedVersion: "1.0.1",
		Remediation:  "Update to version 1.0.1",
	}

	err := vms.RegisterVulnerability(context.Background(), vuln)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	if vuln.ID == "" {
		t.Error("Expected vulnerability ID to be generated")
	}

	if vuln.PublishedDate == nil {
		t.Error("Expected published date to be set")
	}
}

func TestCreateVulnerabilityInstance(t *testing.T) {
	logger := createTestLogger()
	config := VulnerabilityManagementConfig{
		AutoAssignmentEnabled: true,
		DefaultPriority:       PriorityMedium,
		ResolutionTimeframes: map[SecuritySeverity]time.Duration{
			SeverityCritical: 24 * time.Hour,
			SeverityHigh:     72 * time.Hour,
		},
		RiskScoringEnabled: true,
		RetentionDays:      90,
	}

	vms := NewVulnerabilityManagementSystem(logger, config)

	// Register a vulnerability first
	vuln := &Vulnerability{
		Title:        "Test Vulnerability",
		Description:  "This is a test vulnerability",
		Severity:     SeverityHigh,
		CVE:          "CVE-2023-1234",
		Package:      "test-package",
		Version:      "1.0.0",
		FixedVersion: "1.0.1",
		Remediation:  "Update to version 1.0.1",
	}

	err := vms.RegisterVulnerability(context.Background(), vuln)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	// Create vulnerability instance
	instance, err := vms.CreateVulnerabilityInstance(context.Background(), vuln.ID, "authentication", "api/auth.go", "production")
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	if instance.ID == "" {
		t.Error("Expected instance ID to be generated")
	}

	if instance.VulnerabilityID != vuln.ID {
		t.Error("Expected vulnerability ID to match")
	}

	if instance.Component != "authentication" {
		t.Error("Expected component to match")
	}

	if instance.Environment != "production" {
		t.Error("Expected environment to match")
	}

	if instance.Status != VulnStatusOpen {
		t.Error("Expected status to be open")
	}

	if instance.Priority != PriorityHigh {
		t.Error("Expected priority to match vulnerability severity")
	}

	if instance.RiskScore <= 0 {
		t.Error("Expected risk score to be calculated")
	}

	if instance.DueDate == nil {
		t.Error("Expected due date to be set for high severity vulnerability")
	}
}

func TestUpdateVulnerabilityInstance(t *testing.T) {
	logger := createTestLogger()
	config := VulnerabilityManagementConfig{
		AutoAssignmentEnabled: true,
		DefaultPriority:       PriorityMedium,
		RiskScoringEnabled:    true,
		RetentionDays:         90,
	}

	vms := NewVulnerabilityManagementSystem(logger, config)

	// Register a vulnerability
	vuln := &Vulnerability{
		Title:        "Test Vulnerability",
		Description:  "This is a test vulnerability",
		Severity:     SeverityMedium,
		CVE:          "CVE-2023-1234",
		Package:      "test-package",
		Version:      "1.0.0",
		FixedVersion: "1.0.1",
		Remediation:  "Update to version 1.0.1",
	}

	err := vms.RegisterVulnerability(context.Background(), vuln)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	// Create vulnerability instance
	instance, err := vms.CreateVulnerabilityInstance(context.Background(), vuln.ID, "database", "db/connection.go", "staging")
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	// Update the instance
	updates := map[string]interface{}{
		"status":           VulnStatusInProgress,
		"assigned_to":      "security-team",
		"resolution_notes": "Working on fix",
	}

	err = vms.UpdateVulnerabilityInstance(context.Background(), instance.ID, updates)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	// Verify updates
	instances, err := vms.GetVulnerabilityInstances(context.Background(), map[string]interface{}{
		"status": VulnStatusInProgress,
	})
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	if len(instances) != 1 {
		t.Fatalf("Expected 1 instance, got %d", len(instances))
	}

	updatedInstance := instances[0]
	if updatedInstance.Status != VulnStatusInProgress {
		t.Error("Expected status to be updated")
	}

	if updatedInstance.AssignedTo != "security-team" {
		t.Error("Expected assignee to be updated")
	}

	if updatedInstance.ResolutionNotes != "Working on fix" {
		t.Error("Expected resolution notes to be updated")
	}
}

func TestGetVulnerabilityInstancesWithFilters(t *testing.T) {
	logger := createTestLogger()
	config := VulnerabilityManagementConfig{
		AutoAssignmentEnabled: true,
		DefaultPriority:       PriorityMedium,
		RiskScoringEnabled:    true,
		RetentionDays:         90,
	}

	vms := NewVulnerabilityManagementSystem(logger, config)

	// Register vulnerabilities
	vulns := []*Vulnerability{
		{
			Title:       "Critical Vulnerability",
			Description: "Critical test vulnerability",
			Severity:    SeverityCritical,
			CVE:         "CVE-2023-1234",
		},
		{
			Title:       "High Vulnerability",
			Description: "High test vulnerability",
			Severity:    SeverityHigh,
			CVE:         "CVE-2023-5678",
		},
		{
			Title:       "Medium Vulnerability",
			Description: "Medium test vulnerability",
			Severity:    SeverityMedium,
			CVE:         "CVE-2023-9012",
		},
	}

	for _, vuln := range vulns {
		err := vms.RegisterVulnerability(context.Background(), vuln)
		if err != nil {
			t.Fatalf("Expected no error, got %v", err)
		}
	}

	// Create instances
	components := []string{"authentication", "database", "api"}
	environments := []string{"production", "staging", "development"}

	for i, vuln := range vulns {
		_, err := vms.CreateVulnerabilityInstance(context.Background(), vuln.ID, components[i], "test.go", environments[i])
		if err != nil {
			t.Fatalf("Expected no error, got %v", err)
		}
	}

	// Test filtering by environment
	instances, err := vms.GetVulnerabilityInstances(context.Background(), map[string]interface{}{
		"environment": "production",
	})
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	if len(instances) != 1 {
		t.Fatalf("Expected 1 production instance, got %d", len(instances))
	}

	// Test filtering by component
	instances, err = vms.GetVulnerabilityInstances(context.Background(), map[string]interface{}{
		"component": "authentication",
	})
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	if len(instances) != 1 {
		t.Fatalf("Expected 1 authentication instance, got %d", len(instances))
	}

	// Test filtering by status
	instances, err = vms.GetVulnerabilityInstances(context.Background(), map[string]interface{}{
		"status": VulnStatusOpen,
	})
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	if len(instances) != 3 {
		t.Fatalf("Expected 3 open instances, got %d", len(instances))
	}
}

func TestVulnerabilityWorkflow(t *testing.T) {
	logger := createTestLogger()
	config := VulnerabilityManagementConfig{
		AutoAssignmentEnabled: true,
		DefaultPriority:       PriorityMedium,
		RiskScoringEnabled:    true,
		RetentionDays:         90,
	}

	vms := NewVulnerabilityManagementSystem(logger, config)

	// Register a critical vulnerability
	vuln := &Vulnerability{
		Title:       "Critical Vulnerability",
		Description: "Critical test vulnerability",
		Severity:    SeverityCritical,
		CVE:         "CVE-2023-1234",
	}

	err := vms.RegisterVulnerability(context.Background(), vuln)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	// Create vulnerability instance (should create workflow)
	instance, err := vms.CreateVulnerabilityInstance(context.Background(), vuln.ID, "authentication", "api/auth.go", "production")
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	// Get workflows
	workflows, err := vms.GetVulnerabilityWorkflows(context.Background(), instance.ID)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	if len(workflows) != 1 {
		t.Fatalf("Expected 1 workflow, got %d", len(workflows))
	}

	workflow := workflows[0]
	if workflow.InstanceID != instance.ID {
		t.Error("Expected workflow instance ID to match")
	}

	if len(workflow.Steps) != 4 {
		t.Fatalf("Expected 4 workflow steps for critical vulnerability, got %d", len(workflow.Steps))
	}

	// Update workflow step
	err = vms.UpdateWorkflowStep(context.Background(), workflow.ID, "step-1", StepStatusCompleted, "Assessment completed")
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	// Verify workflow status was updated
	workflows, err = vms.GetVulnerabilityWorkflows(context.Background(), instance.ID)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	updatedWorkflow := workflows[0]
	if updatedWorkflow.Steps[0].Status != StepStatusCompleted {
		t.Error("Expected step status to be updated")
	}

	if updatedWorkflow.Status != VulnStatusInProgress {
		t.Error("Expected workflow status to be in progress")
	}
}

func TestGetVulnerabilityMetrics(t *testing.T) {
	logger := createTestLogger()
	config := VulnerabilityManagementConfig{
		AutoAssignmentEnabled: true,
		DefaultPriority:       PriorityMedium,
		RiskScoringEnabled:    true,
		RetentionDays:         90,
	}

	vms := NewVulnerabilityManagementSystem(logger, config)

	// Register vulnerabilities
	vulns := []*Vulnerability{
		{
			Title:       "Critical Vulnerability",
			Description: "Critical test vulnerability",
			Severity:    SeverityCritical,
			CVE:         "CVE-2023-1234",
		},
		{
			Title:       "High Vulnerability",
			Description: "High test vulnerability",
			Severity:    SeverityHigh,
			CVE:         "CVE-2023-5678",
		},
		{
			Title:       "Medium Vulnerability",
			Description: "Medium test vulnerability",
			Severity:    SeverityMedium,
			CVE:         "CVE-2023-9012",
		},
	}

	for _, vuln := range vulns {
		err := vms.RegisterVulnerability(context.Background(), vuln)
		if err != nil {
			t.Fatalf("Expected no error, got %v", err)
		}
	}

	// Create instances
	for _, vuln := range vulns {
		_, err := vms.CreateVulnerabilityInstance(context.Background(), vuln.ID, "test-component", "test.go", "test-env")
		if err != nil {
			t.Fatalf("Expected no error, got %v", err)
		}
	}

	// Get metrics
	metrics, err := vms.GetVulnerabilityMetrics(context.Background())
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	if metrics.TotalVulnerabilities != 3 {
		t.Errorf("Expected 3 total vulnerabilities, got %d", metrics.TotalVulnerabilities)
	}

	if metrics.OpenVulnerabilities != 3 {
		t.Errorf("Expected 3 open vulnerabilities, got %d", metrics.OpenVulnerabilities)
	}

	if metrics.ResolvedVulnerabilities != 0 {
		t.Errorf("Expected 0 resolved vulnerabilities, got %d", metrics.ResolvedVulnerabilities)
	}

	if metrics.VulnsBySeverity[SeverityCritical] != 1 {
		t.Errorf("Expected 1 critical vulnerability, got %d", metrics.VulnsBySeverity[SeverityCritical])
	}

	if metrics.VulnsBySeverity[SeverityHigh] != 1 {
		t.Errorf("Expected 1 high vulnerability, got %d", metrics.VulnsBySeverity[SeverityHigh])
	}

	if metrics.VulnsBySeverity[SeverityMedium] != 1 {
		t.Errorf("Expected 1 medium vulnerability, got %d", metrics.VulnsBySeverity[SeverityMedium])
	}

	if metrics.ResolutionRate != 0.0 {
		t.Errorf("Expected 0.0 resolution rate, got %f", metrics.ResolutionRate)
	}
}

func TestExportVulnerabilities(t *testing.T) {
	logger := createTestLogger()
	config := VulnerabilityManagementConfig{
		AutoAssignmentEnabled: true,
		DefaultPriority:       PriorityMedium,
		RiskScoringEnabled:    true,
		RetentionDays:         90,
	}

	vms := NewVulnerabilityManagementSystem(logger, config)

	// Register and create vulnerability instance
	vuln := &Vulnerability{
		Title:       "Test Vulnerability",
		Description: "Test vulnerability",
		Severity:    SeverityMedium,
		CVE:         "CVE-2023-1234",
	}

	err := vms.RegisterVulnerability(context.Background(), vuln)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	_, err = vms.CreateVulnerabilityInstance(context.Background(), vuln.ID, "test-component", "test.go", "test-env")
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	// Export vulnerabilities
	exported, err := vms.ExportVulnerabilities(context.Background(), nil)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	if len(exported) == 0 {
		t.Error("Expected exported data to not be empty")
	}

	// Verify it's valid JSON
	if !isValidJSON(exported) {
		t.Error("Expected exported data to be valid JSON")
	}
}

func TestExportWorkflows(t *testing.T) {
	logger := createTestLogger()
	config := VulnerabilityManagementConfig{
		AutoAssignmentEnabled: true,
		DefaultPriority:       PriorityMedium,
		RiskScoringEnabled:    true,
		RetentionDays:         90,
	}

	vms := NewVulnerabilityManagementSystem(logger, config)

	// Register critical vulnerability and create instance
	vuln := &Vulnerability{
		Title:       "Critical Vulnerability",
		Description: "Critical test vulnerability",
		Severity:    SeverityCritical,
		CVE:         "CVE-2023-1234",
	}

	err := vms.RegisterVulnerability(context.Background(), vuln)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	instance, err := vms.CreateVulnerabilityInstance(context.Background(), vuln.ID, "authentication", "api/auth.go", "production")
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	// Export workflows
	exported, err := vms.ExportWorkflows(context.Background(), instance.ID)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	if len(exported) == 0 {
		t.Error("Expected exported data to not be empty")
	}

	// Verify it's valid JSON
	if !isValidJSON(exported) {
		t.Error("Expected exported data to be valid JSON")
	}
}

// Helper function to check if data is valid JSON
