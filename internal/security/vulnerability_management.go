package security

import (
	"context"
	"encoding/json"
	"fmt"
	"sort"
	"sync"
	"time"

	"github.com/pcraw4d/business-verification/internal/observability"
)

// VulnerabilityInfo represents a security vulnerability
type VulnerabilityInfo struct {
	ID               string                 `json:"id"`
	Title            string                 `json:"title"`
	Description      string                 `json:"description"`
	Severity         Severity               `json:"severity"`
	CVSS             *VulnCVSSScore         `json:"cvss,omitempty"`
	CVE              string                 `json:"cve,omitempty"`
	Package          string                 `json:"package,omitempty"`
	Version          string                 `json:"version,omitempty"`
	FixedVersion     string                 `json:"fixed_version,omitempty"`
	PublishedDate    *time.Time             `json:"published_date,omitempty"`
	LastModifiedDate *time.Time             `json:"last_modified_date,omitempty"`
	References       []string               `json:"references,omitempty"`
	Remediation      string                 `json:"remediation,omitempty"`
	Metadata         map[string]interface{} `json:"metadata,omitempty"`
}

// VulnCVSSScore represents a CVSS score for vulnerability management
type VulnCVSSScore struct {
	Version   string  `json:"version"`
	BaseScore float64 `json:"base_score"`
	Vector    string  `json:"vector"`
	Severity  string  `json:"severity"`
}

// VulnerabilityInstance represents a specific instance of a vulnerability
type VulnerabilityInstance struct {
	ID              string                 `json:"id"`
	VulnerabilityID string                 `json:"vulnerability_id"`
	Component       string                 `json:"component"`
	Location        string                 `json:"location"`
	Environment     string                 `json:"environment"`
	Status          VulnerabilityStatus    `json:"status"`
	Priority        VulnerabilityPriority  `json:"priority"`
	RiskScore       float64                `json:"risk_score"`
	DiscoveredAt    time.Time              `json:"discovered_at"`
	AssignedTo      string                 `json:"assigned_to,omitempty"`
	DueDate         *time.Time             `json:"due_date,omitempty"`
	ResolvedAt      *time.Time             `json:"resolved_at,omitempty"`
	ResolutionNotes string                 `json:"resolution_notes,omitempty"`
	Metadata        map[string]interface{} `json:"metadata,omitempty"`
}

// VulnerabilityStatus defines the status of a vulnerability
type VulnerabilityStatus string

const (
	VulnStatusOpen          VulnerabilityStatus = "open"
	VulnStatusInProgress    VulnerabilityStatus = "in_progress"
	VulnStatusResolved      VulnerabilityStatus = "resolved"
	VulnStatusClosed        VulnerabilityStatus = "closed"
	VulnStatusAccepted      VulnerabilityStatus = "accepted"
	VulnStatusFalsePositive VulnerabilityStatus = "false_positive"
)

// VulnerabilityPriority defines the priority of a vulnerability
type VulnerabilityPriority string

const (
	PriorityCritical VulnerabilityPriority = "critical"
	PriorityHigh     VulnerabilityPriority = "high"
	PriorityMedium   VulnerabilityPriority = "medium"
	PriorityLow      VulnerabilityPriority = "low"
	PriorityInfo     VulnerabilityPriority = "info"
)

// VulnerabilityWorkflow represents a vulnerability remediation workflow
type VulnerabilityWorkflow struct {
	ID          string                 `json:"id"`
	InstanceID  string                 `json:"instance_id"`
	Status      VulnerabilityStatus    `json:"status"`
	Steps       []WorkflowStep         `json:"steps"`
	CurrentStep int                    `json:"current_step"`
	StartedAt   time.Time              `json:"started_at"`
	UpdatedAt   time.Time              `json:"updated_at"`
	CompletedAt *time.Time             `json:"completed_at,omitempty"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// WorkflowStep represents a step in the vulnerability remediation workflow
type WorkflowStep struct {
	ID          string                 `json:"id"`
	Title       string                 `json:"title"`
	Description string                 `json:"description"`
	Status      StepStatus             `json:"status"`
	AssignedTo  string                 `json:"assigned_to,omitempty"`
	DueDate     *time.Time             `json:"due_date,omitempty"`
	StartedAt   *time.Time             `json:"started_at,omitempty"`
	CompletedAt *time.Time             `json:"completed_at,omitempty"`
	Notes       string                 `json:"notes,omitempty"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// StepStatus defines the status of a workflow step
type StepStatus string

const (
	StepStatusPending    StepStatus = "pending"
	StepStatusInProgress StepStatus = "in_progress"
	StepStatusCompleted  StepStatus = "completed"
	StepStatusSkipped    StepStatus = "skipped"
	StepStatusFailed     StepStatus = "failed"
)

// VulnerabilityMetrics represents vulnerability management metrics
type VulnerabilityMetrics struct {
	TotalVulnerabilities    int                           `json:"total_vulnerabilities"`
	OpenVulnerabilities     int                           `json:"open_vulnerabilities"`
	ResolvedVulnerabilities int                           `json:"resolved_vulnerabilities"`
	VulnsBySeverity         map[Severity]int              `json:"vulns_by_severity"`
	VulnsByStatus           map[VulnerabilityStatus]int   `json:"vulns_by_status"`
	VulnsByPriority         map[VulnerabilityPriority]int `json:"vulns_by_priority"`
	MeanTimeToResolve       time.Duration                 `json:"mean_time_to_resolve"`
	ResolutionRate          float64                       `json:"resolution_rate"`
	LastUpdated             time.Time                     `json:"last_updated"`
}

// VulnerabilityManagementSystem provides vulnerability management capabilities
type VulnerabilityManagementSystem struct {
	logger          *observability.Logger
	vulnerabilities map[string]*VulnerabilityInfo
	instances       map[string]*VulnerabilityInstance
	workflows       map[string]*VulnerabilityWorkflow
	mutex           sync.RWMutex
	config          VulnerabilityManagementConfig
}

// VulnerabilityManagementConfig defines configuration for vulnerability management
type VulnerabilityManagementConfig struct {
	AutoAssignmentEnabled bool                       `json:"auto_assignment_enabled"`
	DefaultPriority       VulnerabilityPriority      `json:"default_priority"`
	ResolutionTimeframes  map[Severity]time.Duration `json:"resolution_timeframes"`
	RiskScoringEnabled    bool                       `json:"risk_scoring_enabled"`
	NotificationChannels  []string                   `json:"notification_channels"`
	RetentionDays         int                        `json:"retention_days"`
}

// NewVulnerabilityManagementSystem creates a new vulnerability management system
func NewVulnerabilityManagementSystem(logger *observability.Logger, config VulnerabilityManagementConfig) *VulnerabilityManagementSystem {
	vms := &VulnerabilityManagementSystem{
		logger:          logger,
		vulnerabilities: make(map[string]*VulnerabilityInfo),
		instances:       make(map[string]*VulnerabilityInstance),
		workflows:       make(map[string]*VulnerabilityWorkflow),
		config:          config,
	}

	// Start background cleanup
	go vms.cleanupRoutine()

	return vms
}

// RegisterVulnerability registers a new vulnerability
func (vms *VulnerabilityManagementSystem) RegisterVulnerability(ctx context.Context, vuln *VulnerabilityInfo) error {
	vms.mutex.Lock()
	defer vms.mutex.Unlock()

	// Generate ID if not provided
	if vuln.ID == "" {
		vuln.ID = observability.GenerateRequestID()
	}

	// Set timestamps if not provided
	if vuln.PublishedDate == nil {
		now := time.Now()
		vuln.PublishedDate = &now
	}
	if vuln.LastModifiedDate == nil {
		vuln.LastModifiedDate = vuln.PublishedDate
	}

	// Store vulnerability
	vms.vulnerabilities[vuln.ID] = vuln

	vms.logger.Info("Vulnerability registered",
		"vulnerability_id", vuln.ID,
		"title", vuln.Title,
		"severity", vuln.Severity,
		"cve", vuln.CVE,
	)

	return nil
}

// CreateVulnerabilityInstance creates a new vulnerability instance
func (vms *VulnerabilityManagementSystem) CreateVulnerabilityInstance(ctx context.Context, vulnID, component, location, environment string) (*VulnerabilityInstance, error) {
	vms.mutex.Lock()
	defer vms.mutex.Unlock()

	// Check if vulnerability exists
	vuln, exists := vms.vulnerabilities[vulnID]
	if !exists {
		return nil, fmt.Errorf("vulnerability not found: %s", vulnID)
	}

	instance := &VulnerabilityInstance{
		ID:              observability.GenerateRequestID(),
		VulnerabilityID: vulnID,
		Component:       component,
		Location:        location,
		Environment:     environment,
		Status:          VulnStatusOpen,
		Priority:        vms.calculatePriority(vuln),
		RiskScore:       vms.calculateRiskScore(vuln, component, environment),
		DiscoveredAt:    time.Now(),
		Metadata:        make(map[string]interface{}),
	}

	// Set due date based on severity
	if timeframe, exists := vms.config.ResolutionTimeframes[vuln.Severity]; exists {
		dueDate := time.Now().Add(timeframe)
		instance.DueDate = &dueDate
	}

	// Auto-assign if enabled
	if vms.config.AutoAssignmentEnabled {
		instance.AssignedTo = vms.getDefaultAssignee(vuln.Severity)
	}

	// Store instance
	vms.instances[instance.ID] = instance

	vms.logger.Info("Vulnerability instance created",
		"instance_id", instance.ID,
		"vulnerability_id", vulnID,
		"component", component,
		"environment", environment,
		"priority", instance.Priority,
		"risk_score", instance.RiskScore,
	)

	// Create workflow if needed
	if vms.shouldCreateWorkflow(instance) {
		workflow := vms.createWorkflow(instance)
		vms.workflows[workflow.ID] = workflow
	}

	return instance, nil
}

// UpdateVulnerabilityInstance updates a vulnerability instance
func (vms *VulnerabilityManagementSystem) UpdateVulnerabilityInstance(ctx context.Context, instanceID string, updates map[string]interface{}) error {
	vms.mutex.Lock()
	defer vms.mutex.Unlock()

	instance, exists := vms.instances[instanceID]
	if !exists {
		return fmt.Errorf("vulnerability instance not found: %s", instanceID)
	}

	// Apply updates
	for key, value := range updates {
		switch key {
		case "status":
			if status, ok := value.(VulnerabilityStatus); ok {
				instance.Status = status
				if status == VulnStatusResolved || status == VulnStatusClosed {
					now := time.Now()
					instance.ResolvedAt = &now
				}
			}
		case "assigned_to":
			if assignedTo, ok := value.(string); ok {
				instance.AssignedTo = assignedTo
			}
		case "due_date":
			if dueDate, ok := value.(*time.Time); ok {
				instance.DueDate = dueDate
			}
		case "resolution_notes":
			if notes, ok := value.(string); ok {
				instance.ResolutionNotes = notes
			}
		case "priority":
			if priority, ok := value.(VulnerabilityPriority); ok {
				instance.Priority = priority
			}
		}
	}

	vms.logger.Info("Vulnerability instance updated",
		"instance_id", instanceID,
		"updates", updates,
	)

	return nil
}

// GetVulnerabilityInstances retrieves vulnerability instances with optional filtering
func (vms *VulnerabilityManagementSystem) GetVulnerabilityInstances(ctx context.Context, filters map[string]interface{}) ([]*VulnerabilityInstance, error) {
	vms.mutex.RLock()
	defer vms.mutex.RUnlock()

	var filteredInstances []*VulnerabilityInstance

	for _, instance := range vms.instances {
		if vms.matchesInstanceFilters(instance, filters) {
			filteredInstances = append(filteredInstances, instance)
		}
	}

	// Sort by priority and discovery date
	sort.Slice(filteredInstances, func(i, j int) bool {
		if filteredInstances[i].Priority != filteredInstances[j].Priority {
			return vms.priorityWeight(filteredInstances[i].Priority) > vms.priorityWeight(filteredInstances[j].Priority)
		}
		return filteredInstances[i].DiscoveredAt.Before(filteredInstances[j].DiscoveredAt)
	})

	return filteredInstances, nil
}

// GetVulnerabilityWorkflows retrieves vulnerability workflows
func (vms *VulnerabilityManagementSystem) GetVulnerabilityWorkflows(ctx context.Context, instanceID string) ([]*VulnerabilityWorkflow, error) {
	vms.mutex.RLock()
	defer vms.mutex.RUnlock()

	var workflows []*VulnerabilityWorkflow

	for _, workflow := range vms.workflows {
		if workflow.InstanceID == instanceID {
			workflows = append(workflows, workflow)
		}
	}

	return workflows, nil
}

// UpdateWorkflowStep updates a workflow step
func (vms *VulnerabilityManagementSystem) UpdateWorkflowStep(ctx context.Context, workflowID, stepID string, status StepStatus, notes string) error {
	vms.mutex.Lock()
	defer vms.mutex.Unlock()

	workflow, exists := vms.workflows[workflowID]
	if !exists {
		return fmt.Errorf("workflow not found: %s", workflowID)
	}

	for i, step := range workflow.Steps {
		if step.ID == stepID {
			workflow.Steps[i].Status = status
			workflow.Steps[i].Notes = notes

			if status == StepStatusInProgress && step.StartedAt == nil {
				now := time.Now()
				workflow.Steps[i].StartedAt = &now
			} else if status == StepStatusCompleted && step.CompletedAt == nil {
				now := time.Now()
				workflow.Steps[i].CompletedAt = &now
			}

			workflow.UpdatedAt = time.Now()

			// Update workflow status
			vms.updateWorkflowStatus(workflow)

			vms.logger.Info("Workflow step updated",
				"workflow_id", workflowID,
				"step_id", stepID,
				"status", status,
			)

			return nil
		}
	}

	return fmt.Errorf("step not found: %s", stepID)
}

// GetVulnerabilityMetrics retrieves vulnerability management metrics
func (vms *VulnerabilityManagementSystem) GetVulnerabilityMetrics(ctx context.Context) (*VulnerabilityMetrics, error) {
	vms.mutex.RLock()
	defer vms.mutex.RUnlock()

	metrics := &VulnerabilityMetrics{
		VulnsBySeverity: make(map[Severity]int),
		VulnsByStatus:   make(map[VulnerabilityStatus]int),
		VulnsByPriority: make(map[VulnerabilityPriority]int),
		LastUpdated:     time.Now(),
	}

	// Count instances
	for _, instance := range vms.instances {
		metrics.TotalVulnerabilities++

		// Get vulnerability details
		if vuln, exists := vms.vulnerabilities[instance.VulnerabilityID]; exists {
			metrics.VulnsBySeverity[vuln.Severity]++
		}

		metrics.VulnsByStatus[instance.Status]++
		metrics.VulnsByPriority[instance.Priority]++

		if instance.Status == VulnStatusOpen || instance.Status == VulnStatusInProgress {
			metrics.OpenVulnerabilities++
		} else if instance.Status == VulnStatusResolved || instance.Status == VulnStatusClosed {
			metrics.ResolvedVulnerabilities++
		}
	}

	// Calculate resolution rate
	if metrics.TotalVulnerabilities > 0 {
		metrics.ResolutionRate = float64(metrics.ResolvedVulnerabilities) / float64(metrics.TotalVulnerabilities) * 100
	}

	// Calculate mean time to resolve
	metrics.MeanTimeToResolve = vms.calculateMeanTimeToResolve()

	return metrics, nil
}

// calculatePriority calculates the priority based on vulnerability severity and context
func (vms *VulnerabilityManagementSystem) calculatePriority(vuln *VulnerabilityInfo) VulnerabilityPriority {
	switch vuln.Severity {
	case SeverityCritical:
		return PriorityCritical
	case SeverityHigh:
		return PriorityHigh
	case SeverityMedium:
		return PriorityMedium
	case SeverityLow:
		return PriorityLow
	default:
		return vms.config.DefaultPriority
	}
}

// calculateRiskScore calculates a risk score for the vulnerability instance
func (vms *VulnerabilityManagementSystem) calculateRiskScore(vuln *VulnerabilityInfo, component, environment string) float64 {
	if !vms.config.RiskScoringEnabled {
		return 0.0
	}

	score := 0.0

	// Base score from CVSS
	if vuln.CVSS != nil {
		score += vuln.CVSS.BaseScore
	} else {
		// Fallback based on severity
		switch vuln.Severity {
		case SeverityCritical:
			score += 9.0
		case SeverityHigh:
			score += 7.0
		case SeverityMedium:
			score += 4.0
		case SeverityLow:
			score += 2.0
		}
	}

	// Environment multiplier
	switch environment {
	case "production":
		score *= 1.5
	case "staging":
		score *= 1.2
	case "development":
		score *= 0.8
	}

	// Component multiplier (critical components get higher scores)
	if vms.isCriticalComponent(component) {
		score *= 1.3
	}

	// Cap at 10.0
	if score > 10.0 {
		score = 10.0
	}

	return score
}

// isCriticalComponent checks if a component is critical
func (vms *VulnerabilityManagementSystem) isCriticalComponent(component string) bool {
	criticalComponents := []string{
		"authentication",
		"authorization",
		"database",
		"payment",
		"encryption",
		"api-gateway",
	}

	for _, critical := range criticalComponents {
		if component == critical {
			return true
		}
	}
	return false
}

// getDefaultAssignee gets the default assignee for a severity level
func (vms *VulnerabilityManagementSystem) getDefaultAssignee(severity Severity) string {
	// In a real implementation, this would use team assignments
	switch severity {
	case SeverityCritical, SeverityHigh:
		return "security-team"
	case SeverityMedium:
		return "devops-team"
	case SeverityLow:
		return "development-team"
	default:
		return "development-team"
	}
}

// shouldCreateWorkflow determines if a workflow should be created
func (vms *VulnerabilityManagementSystem) shouldCreateWorkflow(instance *VulnerabilityInstance) bool {
	return instance.Priority == PriorityCritical || instance.Priority == PriorityHigh
}

// createWorkflow creates a vulnerability remediation workflow
func (vms *VulnerabilityManagementSystem) createWorkflow(instance *VulnerabilityInstance) *VulnerabilityWorkflow {
	workflow := &VulnerabilityWorkflow{
		ID:          observability.GenerateRequestID(),
		InstanceID:  instance.ID,
		Status:      VulnStatusOpen,
		CurrentStep: 0,
		StartedAt:   time.Now(),
		UpdatedAt:   time.Now(),
		Metadata:    make(map[string]interface{}),
	}

	// Create workflow steps based on priority
	switch instance.Priority {
	case PriorityCritical:
		workflow.Steps = []WorkflowStep{
			{
				ID:          "step-1",
				Title:       "Immediate Assessment",
				Description: "Assess the immediate impact and exposure",
				Status:      StepStatusPending,
				AssignedTo:  "security-team",
			},
			{
				ID:          "step-2",
				Title:       "Emergency Mitigation",
				Description: "Implement immediate mitigation measures",
				Status:      StepStatusPending,
				AssignedTo:  "devops-team",
			},
			{
				ID:          "step-3",
				Title:       "Root Cause Analysis",
				Description: "Analyze root cause and implement permanent fix",
				Status:      StepStatusPending,
				AssignedTo:  "development-team",
			},
			{
				ID:          "step-4",
				Title:       "Verification",
				Description: "Verify that the vulnerability is resolved",
				Status:      StepStatusPending,
				AssignedTo:  "security-team",
			},
		}
	case PriorityHigh:
		workflow.Steps = []WorkflowStep{
			{
				ID:          "step-1",
				Title:       "Assessment",
				Description: "Assess the vulnerability impact",
				Status:      StepStatusPending,
				AssignedTo:  "security-team",
			},
			{
				ID:          "step-2",
				Title:       "Remediation",
				Description: "Implement remediation measures",
				Status:      StepStatusPending,
				AssignedTo:  "development-team",
			},
			{
				ID:          "step-3",
				Title:       "Testing",
				Description: "Test the remediation",
				Status:      StepStatusPending,
				AssignedTo:  "qa-team",
			},
		}
	}

	return workflow
}

// updateWorkflowStatus updates the workflow status based on step completion
func (vms *VulnerabilityManagementSystem) updateWorkflowStatus(workflow *VulnerabilityWorkflow) {
	completedSteps := 0
	totalSteps := len(workflow.Steps)

	for _, step := range workflow.Steps {
		if step.Status == StepStatusCompleted {
			completedSteps++
		}
	}

	if completedSteps == totalSteps {
		workflow.Status = VulnStatusResolved
		now := time.Now()
		workflow.CompletedAt = &now
	} else if completedSteps > 0 {
		workflow.Status = VulnStatusInProgress
		workflow.CurrentStep = completedSteps
	}
}

// matchesInstanceFilters checks if an instance matches the given filters
func (vms *VulnerabilityManagementSystem) matchesInstanceFilters(instance *VulnerabilityInstance, filters map[string]interface{}) bool {
	for key, value := range filters {
		switch key {
		case "status":
			if status, ok := value.(VulnerabilityStatus); ok && instance.Status != status {
				return false
			}
		case "priority":
			if priority, ok := value.(VulnerabilityPriority); ok && instance.Priority != priority {
				return false
			}
		case "environment":
			if env, ok := value.(string); ok && instance.Environment != env {
				return false
			}
		case "component":
			if comp, ok := value.(string); ok && instance.Component != comp {
				return false
			}
		case "assigned_to":
			if assignedTo, ok := value.(string); ok && instance.AssignedTo != assignedTo {
				return false
			}
		}
	}
	return true
}

// priorityWeight returns the weight of a priority for sorting
func (vms *VulnerabilityManagementSystem) priorityWeight(priority VulnerabilityPriority) int {
	switch priority {
	case PriorityCritical:
		return 5
	case PriorityHigh:
		return 4
	case PriorityMedium:
		return 3
	case PriorityLow:
		return 2
	case PriorityInfo:
		return 1
	default:
		return 0
	}
}

// calculateMeanTimeToResolve calculates the mean time to resolve vulnerabilities
func (vms *VulnerabilityManagementSystem) calculateMeanTimeToResolve() time.Duration {
	var totalDuration time.Duration
	resolvedCount := 0

	for _, instance := range vms.instances {
		if instance.Status == VulnStatusResolved || instance.Status == VulnStatusClosed {
			if instance.ResolvedAt != nil {
				totalDuration += instance.ResolvedAt.Sub(instance.DiscoveredAt)
				resolvedCount++
			}
		}
	}

	if resolvedCount == 0 {
		return 0
	}

	return totalDuration / time.Duration(resolvedCount)
}

// cleanupRoutine periodically cleans up old data
func (vms *VulnerabilityManagementSystem) cleanupRoutine() {
	ticker := time.NewTicker(24 * time.Hour) // Run daily
	defer ticker.Stop()

	for range ticker.C {
		vms.cleanup()
	}
}

// cleanup removes old data based on retention policy
func (vms *VulnerabilityManagementSystem) cleanup() {
	vms.mutex.Lock()
	defer vms.mutex.Unlock()

	cutoff := time.Now().AddDate(0, 0, -vms.config.RetentionDays)

	// Clean up old resolved instances
	for id, instance := range vms.instances {
		if (instance.Status == VulnStatusResolved || instance.Status == VulnStatusClosed) &&
			instance.ResolvedAt != nil && instance.ResolvedAt.Before(cutoff) {
			delete(vms.instances, id)
		}
	}

	// Clean up old workflows
	for id, workflow := range vms.workflows {
		if workflow.CompletedAt != nil && workflow.CompletedAt.Before(cutoff) {
			delete(vms.workflows, id)
		}
	}
}

// ExportVulnerabilities exports vulnerabilities to JSON format
func (vms *VulnerabilityManagementSystem) ExportVulnerabilities(ctx context.Context, filters map[string]interface{}) ([]byte, error) {
	instances, err := vms.GetVulnerabilityInstances(ctx, filters)
	if err != nil {
		return nil, err
	}

	return json.MarshalIndent(instances, "", "  ")
}

// ExportWorkflows exports workflows to JSON format
func (vms *VulnerabilityManagementSystem) ExportWorkflows(ctx context.Context, instanceID string) ([]byte, error) {
	workflows, err := vms.GetVulnerabilityWorkflows(ctx, instanceID)
	if err != nil {
		return nil, err
	}

	return json.MarshalIndent(workflows, "", "  ")
}
