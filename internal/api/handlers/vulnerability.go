package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/pcraw4d/business-verification/internal/observability"
	"github.com/pcraw4d/business-verification/internal/security"
	"github.com/pcraw4d/business-verification/pkg/validators"
)

// VulnerabilityHandler handles vulnerability management API requests
type VulnerabilityHandler struct {
	vulnManager *security.VulnerabilityManagementSystem
	logger      *observability.Logger
}

// NewVulnerabilityHandler creates a new vulnerability handler
func NewVulnerabilityHandler(vulnManager *security.VulnerabilityManagementSystem, logger *observability.Logger) *VulnerabilityHandler {
	return &VulnerabilityHandler{
		vulnManager: vulnManager,
		logger:      logger,
	}
}

// RegisterVulnerabilityRequest represents a request to register a vulnerability
type RegisterVulnerabilityRequest struct {
	Title        string                 `json:"title" validate:"required"`
	Description  string                 `json:"description" validate:"required"`
	Severity     security.Severity      `json:"severity" validate:"required"`
	CVSS         *security.CVSSScore    `json:"cvss,omitempty"`
	CVE          string                 `json:"cve,omitempty"`
	Package      string                 `json:"package,omitempty"`
	Version      string                 `json:"version,omitempty"`
	FixedVersion string                 `json:"fixed_version,omitempty"`
	References   []string               `json:"references,omitempty"`
	Remediation  string                 `json:"remediation,omitempty"`
	Metadata     map[string]interface{} `json:"metadata,omitempty"`
}

// CreateVulnerabilityInstanceRequest represents a request to create a vulnerability instance
type CreateVulnerabilityInstanceRequest struct {
	VulnerabilityID string `json:"vulnerability_id" validate:"required"`
	Component       string `json:"component" validate:"required"`
	Location        string `json:"location" validate:"required"`
	Environment     string `json:"environment" validate:"required"`
}

// UpdateVulnerabilityInstanceRequest represents a request to update a vulnerability instance
type UpdateVulnerabilityInstanceRequest struct {
	Status          *security.VulnerabilityStatus   `json:"status,omitempty"`
	AssignedTo      *string                         `json:"assigned_to,omitempty"`
	DueDate         *time.Time                      `json:"due_date,omitempty"`
	ResolutionNotes *string                         `json:"resolution_notes,omitempty"`
	Priority        *security.VulnerabilityPriority `json:"priority,omitempty"`
}

// UpdateWorkflowStepRequest represents a request to update a workflow step
type UpdateWorkflowStepRequest struct {
	Status security.StepStatus `json:"status" validate:"required"`
	Notes  string              `json:"notes,omitempty"`
}

// VulnerabilityResponse represents a vulnerability response
type VulnerabilityResponse struct {
	ID               string                 `json:"id"`
	Title            string                 `json:"title"`
	Description      string                 `json:"description"`
	Severity         security.Severity      `json:"severity"`
	CVSS             *security.CVSSScore    `json:"cvss,omitempty"`
	CVE              string                 `json:"cve,omitempty"`
	Package          string                 `json:"package,omitempty"`
	Version          string                 `json:"version,omitempty"`
	FixedVersion     string                 `json:"fixed_version,omitempty"`
	PublishedDate    *time.Time             `json:"published_date,omitempty"`
	LastModifiedDate *time.Time             `json:"last_modified_date,omitempty"`
	References       []string               `json:"references,omitempty"`
	Remediation      string                 `json:"remediation,omitempty"`
	Metadata         map[string]interface{} `json:"metadata,omitempty"`
}

// VulnerabilityInstanceResponse represents a vulnerability instance response
type VulnerabilityInstanceResponse struct {
	ID              string                         `json:"id"`
	VulnerabilityID string                         `json:"vulnerability_id"`
	Component       string                         `json:"component"`
	Location        string                         `json:"location"`
	Environment     string                         `json:"environment"`
	Status          security.VulnerabilityStatus   `json:"status"`
	Priority        security.VulnerabilityPriority `json:"priority"`
	RiskScore       float64                        `json:"risk_score"`
	DiscoveredAt    time.Time                      `json:"discovered_at"`
	AssignedTo      string                         `json:"assigned_to,omitempty"`
	DueDate         *time.Time                     `json:"due_date,omitempty"`
	ResolvedAt      *time.Time                     `json:"resolved_at,omitempty"`
	ResolutionNotes string                         `json:"resolution_notes,omitempty"`
	Metadata        map[string]interface{}         `json:"metadata,omitempty"`
}

// VulnerabilityMetricsResponse represents vulnerability metrics response
type VulnerabilityMetricsResponse struct {
	TotalVulnerabilities    int                                    `json:"total_vulnerabilities"`
	OpenVulnerabilities     int                                    `json:"open_vulnerabilities"`
	ResolvedVulnerabilities int                                    `json:"resolved_vulnerabilities"`
	VulnsBySeverity         map[security.Severity]int              `json:"vulns_by_severity"`
	VulnsByStatus           map[security.VulnerabilityStatus]int   `json:"vulns_by_status"`
	VulnsByPriority         map[security.VulnerabilityPriority]int `json:"vulns_by_priority"`
	MeanTimeToResolve       string                                 `json:"mean_time_to_resolve"`
	ResolutionRate          float64                                `json:"resolution_rate"`
	LastUpdated             time.Time                              `json:"last_updated"`
}

// RegisterVulnerability handles POST /v1/vulnerabilities
func (h *VulnerabilityHandler) RegisterVulnerability(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var req RegisterVulnerabilityRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.logger.Error("Failed to decode request body", map[string]interface{}{
			"error": err.Error(),
		})
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Validate request
	if err := validators.Validate(&req); err != nil {
		h.logger.Error("Request validation failed", map[string]interface{}{
			"error": err.Error(),
		})
		http.Error(w, fmt.Sprintf("Validation failed: %v", err), http.StatusBadRequest)
		return
	}

	// Create vulnerability
	vuln := &security.Vulnerability{
		ID:          "", // ID will be generated by the system
		Title:       req.Title,
		Description: req.Description,
		Severity:    req.Severity,
		CVSS:        req.CVSS.BaseScore, // Extract base score from CVSSScore struct
		References:  req.References,
	}

	// Register vulnerability using the simplified Vulnerability struct

	if err := h.vulnManager.RegisterVulnerability(ctx, vuln); err != nil {
		h.logger.Error("Failed to register vulnerability", map[string]interface{}{
			"error": err.Error(),
		})
		http.Error(w, "Failed to register vulnerability", http.StatusInternalServerError)
		return
	}

	// Create response
	response := VulnerabilityResponse{
		ID:          vuln.ID,
		Title:       vuln.Title,
		Description: vuln.Description,
		Severity:    vuln.Severity,
		CVSS:        &security.CVSSScore{BaseScore: vuln.CVSS}, // Convert float64 to CVSSScore
		References:  vuln.References,
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(response)
}

// CreateVulnerabilityInstance handles POST /v1/vulnerabilities/{vulnID}/instances
func (h *VulnerabilityHandler) CreateVulnerabilityInstance(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Extract vulnerability ID from URL
	vulnID := r.URL.Query().Get("vulnerability_id")
	if vulnID == "" {
		http.Error(w, "Vulnerability ID is required", http.StatusBadRequest)
		return
	}

	var req CreateVulnerabilityInstanceRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.logger.Error("Failed to decode request body", map[string]interface{}{
			"error": err.Error(),
		})
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Validate request
	if err := validators.Validate(&req); err != nil {
		h.logger.Error("Request validation failed", map[string]interface{}{
			"error": err.Error(),
		})
		http.Error(w, fmt.Sprintf("Validation failed: %v", err), http.StatusBadRequest)
		return
	}

	// Create vulnerability instance
	instance, err := h.vulnManager.CreateVulnerabilityInstance(ctx, req.VulnerabilityID, req.Component, req.Location, req.Environment)
	if err != nil {
		h.logger.Error("Failed to create vulnerability instance", map[string]interface{}{
			"error": err.Error(),
		})
		http.Error(w, "Failed to create vulnerability instance", http.StatusInternalServerError)
		return
	}

	// Create response
	response := VulnerabilityInstanceResponse{
		ID:              instance.ID,
		VulnerabilityID: instance.VulnerabilityID,
		Component:       instance.Component,
		Location:        instance.Location,
		Environment:     instance.Environment,
		Status:          security.VulnerabilityStatus(instance.Status),
		Priority:        security.VulnerabilityPriority(instance.Priority),
		RiskScore:       instance.RiskScore,
		DiscoveredAt:    instance.DiscoveredAt,
		AssignedTo:      instance.AssignedTo,
		DueDate:         instance.DueDate,
		ResolvedAt:      instance.ResolvedAt,
		ResolutionNotes: instance.ResolutionNotes,
		Metadata:        instance.Metadata,
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(response)
}

// GetVulnerabilityInstances handles GET /v1/vulnerabilities/instances
func (h *VulnerabilityHandler) GetVulnerabilityInstances(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Parse query parameters for filtering
	filters := make(map[string]interface{})

	if status := r.URL.Query().Get("status"); status != "" {
		filters["status"] = security.VulnerabilityStatus(status)
	}

	if priority := r.URL.Query().Get("priority"); priority != "" {
		filters["priority"] = security.VulnerabilityPriority(priority)
	}

	if environment := r.URL.Query().Get("environment"); environment != "" {
		filters["environment"] = environment
	}

	if component := r.URL.Query().Get("component"); component != "" {
		filters["component"] = component
	}

	if assignedTo := r.URL.Query().Get("assigned_to"); assignedTo != "" {
		filters["assigned_to"] = assignedTo
	}

	// Get instances
	instances, err := h.vulnManager.GetVulnerabilityInstances(ctx, filters)
	if err != nil {
		h.logger.Error("Failed to get vulnerability instances", map[string]interface{}{
			"error": err.Error(),
		})
		http.Error(w, "Failed to get vulnerability instances", http.StatusInternalServerError)
		return
	}

	// Create response
	response := make([]VulnerabilityInstanceResponse, len(instances))
	for i, instance := range instances {
		response[i] = VulnerabilityInstanceResponse{
			ID:              instance.ID,
			VulnerabilityID: instance.VulnerabilityID,
			Component:       instance.Component,
			Location:        instance.Location,
			Environment:     instance.Environment,
			Status:          security.VulnerabilityStatus(instance.Status),
			Priority:        security.VulnerabilityPriority(instance.Priority),
			RiskScore:       instance.RiskScore,
			DiscoveredAt:    instance.DiscoveredAt,
			AssignedTo:      instance.AssignedTo,
			DueDate:         instance.DueDate,
			ResolvedAt:      instance.ResolvedAt,
			ResolutionNotes: instance.ResolutionNotes,
			Metadata:        instance.Metadata,
		}
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// UpdateVulnerabilityInstance handles PUT /v1/vulnerabilities/instances/{instanceID}
func (h *VulnerabilityHandler) UpdateVulnerabilityInstance(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Extract instance ID from URL
	instanceID := r.URL.Query().Get("instance_id")
	if instanceID == "" {
		http.Error(w, "Instance ID is required", http.StatusBadRequest)
		return
	}

	var req UpdateVulnerabilityInstanceRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.logger.Error("Failed to decode request body", map[string]interface{}{
			"error": err.Error(),
		})
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Build updates map
	updates := make(map[string]interface{})
	if req.Status != nil {
		updates["status"] = *req.Status
	}
	if req.AssignedTo != nil {
		updates["assigned_to"] = *req.AssignedTo
	}
	if req.DueDate != nil {
		updates["due_date"] = req.DueDate
	}
	if req.ResolutionNotes != nil {
		updates["resolution_notes"] = *req.ResolutionNotes
	}
	if req.Priority != nil {
		updates["priority"] = *req.Priority
	}

	// Update instance
	if err := h.vulnManager.UpdateVulnerabilityInstance(ctx, instanceID, updates); err != nil {
		h.logger.Error("Failed to update vulnerability instance", map[string]interface{}{
			"error": err.Error(),
		})
		http.Error(w, "Failed to update vulnerability instance", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
}

// GetVulnerabilityWorkflows handles GET /v1/vulnerabilities/instances/{instanceID}/workflows
func (h *VulnerabilityHandler) GetVulnerabilityWorkflows(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Extract instance ID from URL
	instanceID := r.URL.Query().Get("instance_id")
	if instanceID == "" {
		http.Error(w, "Instance ID is required", http.StatusBadRequest)
		return
	}

	// Get workflows
	workflows, err := h.vulnManager.GetVulnerabilityWorkflows(ctx, instanceID)
	if err != nil {
		h.logger.Error("Failed to get vulnerability workflows", map[string]interface{}{
			"error": err.Error(),
		})
		http.Error(w, "Failed to get vulnerability workflows", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(workflows)
}

// UpdateWorkflowStep handles PUT /v1/vulnerabilities/workflows/{workflowID}/steps/{stepID}
func (h *VulnerabilityHandler) UpdateWorkflowStep(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Extract workflow ID and step ID from URL
	workflowID := r.URL.Query().Get("workflow_id")
	if workflowID == "" {
		http.Error(w, "Workflow ID is required", http.StatusBadRequest)
		return
	}

	stepID := r.URL.Query().Get("step_id")
	if stepID == "" {
		http.Error(w, "Step ID is required", http.StatusBadRequest)
		return
	}

	var req UpdateWorkflowStepRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.logger.Error("Failed to decode request body", map[string]interface{}{
			"error": err.Error(),
		})
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Validate request
	if err := validators.Validate(&req); err != nil {
		h.logger.Error("Request validation failed", map[string]interface{}{
			"error": err.Error(),
		})
		http.Error(w, fmt.Sprintf("Validation failed: %v", err), http.StatusBadRequest)
		return
	}

	// Update workflow step
	if err := h.vulnManager.UpdateWorkflowStep(ctx, workflowID, stepID, req.Status, req.Notes); err != nil {
		h.logger.Error("Failed to update workflow step", map[string]interface{}{
			"error": err.Error(),
		})
		http.Error(w, "Failed to update workflow step", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
}

// GetVulnerabilityMetrics handles GET /v1/vulnerabilities/metrics
func (h *VulnerabilityHandler) GetVulnerabilityMetrics(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Get metrics
	metrics, err := h.vulnManager.GetVulnerabilityMetrics(ctx)
	if err != nil {
		h.logger.Error("Failed to get vulnerability metrics", map[string]interface{}{
			"error": err.Error(),
		})
		http.Error(w, "Failed to get vulnerability metrics", http.StatusInternalServerError)
		return
	}

	// Create response
	response := VulnerabilityMetricsResponse{
		TotalVulnerabilities:    metrics.TotalVulnerabilities,
		OpenVulnerabilities:     metrics.OpenVulnerabilities,
		ResolvedVulnerabilities: metrics.ResolvedVulnerabilities,
		VulnsBySeverity:         metrics.VulnsBySeverity,
		VulnsByStatus:           metrics.VulnsByStatus,
		VulnsByPriority:         metrics.VulnsByPriority,
		MeanTimeToResolve:       metrics.MeanTimeToResolve.String(),
		ResolutionRate:          metrics.ResolutionRate,
		LastUpdated:             metrics.LastUpdated,
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// ExportVulnerabilities handles GET /v1/vulnerabilities/export
func (h *VulnerabilityHandler) ExportVulnerabilities(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Parse query parameters for filtering
	filters := make(map[string]interface{})

	if status := r.URL.Query().Get("status"); status != "" {
		filters["status"] = security.VulnerabilityStatus(status)
	}

	if priority := r.URL.Query().Get("priority"); priority != "" {
		filters["priority"] = security.VulnerabilityPriority(priority)
	}

	if environment := r.URL.Query().Get("environment"); environment != "" {
		filters["environment"] = environment
	}

	if component := r.URL.Query().Get("component"); component != "" {
		filters["component"] = component
	}

	// Export vulnerabilities
	exported, err := h.vulnManager.ExportVulnerabilities(ctx, filters)
	if err != nil {
		h.logger.Error("Failed to export vulnerabilities", map[string]interface{}{
			"error": err.Error(),
		})
		http.Error(w, "Failed to export vulnerabilities", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Content-Disposition", "attachment; filename=vulnerabilities.json")
	w.Write(exported)
}

// ExportWorkflows handles GET /v1/vulnerabilities/workflows/export
func (h *VulnerabilityHandler) ExportWorkflows(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Extract instance ID from URL
	instanceID := r.URL.Query().Get("instance_id")
	if instanceID == "" {
		http.Error(w, "Instance ID is required", http.StatusBadRequest)
		return
	}

	// Export workflows
	exported, err := h.vulnManager.ExportWorkflows(ctx, instanceID)
	if err != nil {
		h.logger.Error("Failed to export workflows", map[string]interface{}{
			"error": err.Error(),
		})
		http.Error(w, "Failed to export workflows", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Content-Disposition", "attachment; filename=workflows.json")
	w.Write(exported)
}

// GetVulnerabilityInstance handles GET /v1/vulnerabilities/instances/{instanceID}
func (h *VulnerabilityHandler) GetVulnerabilityInstance(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Extract instance ID from URL
	instanceID := r.URL.Query().Get("instance_id")
	if instanceID == "" {
		http.Error(w, "Instance ID is required", http.StatusBadRequest)
		return
	}

	// Get instance
	instances, err := h.vulnManager.GetVulnerabilityInstances(ctx, map[string]interface{}{
		"id": instanceID,
	})
	if err != nil {
		h.logger.Error("Failed to get vulnerability instance", map[string]interface{}{
			"error": err.Error(),
		})
		http.Error(w, "Failed to get vulnerability instance", http.StatusInternalServerError)
		return
	}

	if len(instances) == 0 {
		http.Error(w, "Vulnerability instance not found", http.StatusNotFound)
		return
	}

	instance := instances[0]

	// Create response
	response := VulnerabilityInstanceResponse{
		ID:              instance.ID,
		VulnerabilityID: instance.VulnerabilityID,
		Component:       instance.Component,
		Location:        instance.Location,
		Environment:     instance.Environment,
		Status:          security.VulnerabilityStatus(instance.Status),
		Priority:        security.VulnerabilityPriority(instance.Priority),
		RiskScore:       instance.RiskScore,
		DiscoveredAt:    instance.DiscoveredAt,
		AssignedTo:      instance.AssignedTo,
		DueDate:         instance.DueDate,
		ResolvedAt:      instance.ResolvedAt,
		ResolutionNotes: instance.ResolutionNotes,
		Metadata:        instance.Metadata,
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}
