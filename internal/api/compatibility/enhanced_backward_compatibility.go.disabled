package compatibility

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/pcraw4d/business-verification/internal/classification"
	"github.com/pcraw4d/business-verification/internal/config"
	"github.com/pcraw4d/business-verification/pkg/validators"
	"go.uber.org/zap"
)

// EnhancedBackwardCompatibilityLayer provides comprehensive backward compatibility
type EnhancedBackwardCompatibilityLayer struct {
	versionManager     *VersionManager
	featureFlagManager *config.FeatureFlagManager
	logger             *zap.Logger
	validator          *validators.Validator
	compatibilityMode  string // "strict", "flexible", "legacy"
}

// CompatibilityConfig holds configuration for backward compatibility
type CompatibilityConfig struct {
	Mode                      string        `json:"mode"` // "strict", "flexible", "legacy"
	EnableVersionNegotiation  bool          `json:"enable_version_negotiation"`
	EnableDeprecationWarnings bool          `json:"enable_deprecation_warnings"`
	EnableMigrationGuides     bool          `json:"enable_migration_guides"`
	EnableCompatibilityChecks bool          `json:"enable_compatibility_checks"`
	GracefulDegradation       bool          `json:"graceful_degradation"`
	ResponseTransformation    bool          `json:"response_transformation"`
	RequestTransformation     bool          `json:"request_transformation"`
	Timeout                   time.Duration `json:"timeout"`
	MaxRetries                int           `json:"max_retries"`
}

// CompatibilityRequest represents a request with compatibility information
type CompatibilityRequest struct {
	OriginalRequest   interface{} `json:"original_request"`
	RequestedVersion  string      `json:"requested_version"`
	NegotiatedVersion string      `json:"negotiated_version"`
	ClientVersion     string      `json:"client_version,omitempty"`
	CompatibilityMode string      `json:"compatibility_mode"`
	Timestamp         time.Time   `json:"timestamp"`
}

// CompatibilityResponse represents a response with compatibility information
type CompatibilityResponse struct {
	OriginalResponse    interface{}        `json:"original_response"`
	TransformedResponse interface{}        `json:"transformed_response,omitempty"`
	ResponseVersion     string             `json:"response_version"`
	CompatibilityInfo   *CompatibilityInfo `json:"compatibility_info,omitempty"`
	DeprecationInfo     *DeprecationInfo   `json:"deprecation_info,omitempty"`
	MigrationInfo       *MigrationInfo     `json:"migration_info,omitempty"`
	Timestamp           time.Time          `json:"timestamp"`
}

// CompatibilityInfo provides information about compatibility
type CompatibilityInfo struct {
	IsCompatible       bool     `json:"is_compatible"`
	CompatibilityLevel string   `json:"compatibility_level"`
	BreakingChanges    []string `json:"breaking_changes,omitempty"`
	Warnings           []string `json:"warnings,omitempty"`
	Suggestions        []string `json:"suggestions,omitempty"`
}

// DeprecationInfo provides information about deprecation
type DeprecationInfo struct {
	IsDeprecated       bool      `json:"is_deprecated"`
	DeprecatedAt       time.Time `json:"deprecated_at"`
	SunsetDate         time.Time `json:"sunset_date"`
	DeprecationMessage string    `json:"deprecation_message"`
	MigrationGuide     string    `json:"migration_guide,omitempty"`
}

// MigrationInfo provides information about migration
type MigrationInfo struct {
	MigrationRequired bool     `json:"migration_required"`
	MigrationSteps    []string `json:"migration_steps,omitempty"`
	MigrationPath     []string `json:"migration_path,omitempty"`
	EstimatedEffort   string   `json:"estimated_effort,omitempty"`
	BreakingChanges   []string `json:"breaking_changes,omitempty"`
}

// NewEnhancedBackwardCompatibilityLayer creates a new enhanced backward compatibility layer
func NewEnhancedBackwardCompatibilityLayer(
	versionManager *VersionManager,
	featureFlagManager *config.FeatureFlagManager,
	logger *zap.Logger,
	validator *validators.Validator,
	config *CompatibilityConfig,
) *EnhancedBackwardCompatibilityLayer {
	if config == nil {
		config = &CompatibilityConfig{
			Mode:                      "flexible",
			EnableVersionNegotiation:  true,
			EnableDeprecationWarnings: true,
			EnableMigrationGuides:     true,
			EnableCompatibilityChecks: true,
			GracefulDegradation:       true,
			ResponseTransformation:    true,
			RequestTransformation:     true,
			Timeout:                   30 * time.Second,
			MaxRetries:                3,
		}
	}

	return &EnhancedBackwardCompatibilityLayer{
		versionManager:     versionManager,
		featureFlagManager: featureFlagManager,
		logger:             logger,
		validator:          validator,
		compatibilityMode:  config.Mode,
	}
}

// HandleRequestWithCompatibility handles requests with full backward compatibility
func (ebcl *EnhancedBackwardCompatibilityLayer) HandleRequestWithCompatibility(
	w http.ResponseWriter,
	r *http.Request,
	processor ClassificationProcessor,
) {
	start := time.Now()
	ctx := r.Context()

	// Create compatibility request
	compatReq := &CompatibilityRequest{
		Timestamp: start,
	}

	// Negotiate version
	negotiatedVersion, err := ebcl.versionManager.NegotiateVersion(ctx, r)
	if err != nil {
		ebcl.logger.Error("Version negotiation failed", zap.Error(err))
		http.Error(w, `{"error":"version_negotiation_failed","message":"Failed to negotiate API version"}`, http.StatusBadRequest)
		return
	}
	compatReq.NegotiatedVersion = negotiatedVersion

	// Extract client version
	clientVersion := r.Header.Get("X-Client-Version")
	compatReq.ClientVersion = clientVersion

	// Validate client version
	if clientVersion != "" {
		if err := ebcl.versionManager.ValidateClientVersion(ctx, negotiatedVersion, clientVersion); err != nil {
			ebcl.logger.Warn("Client version validation failed",
				zap.String("client_version", clientVersion),
				zap.String("api_version", negotiatedVersion),
				zap.Error(err))
		}
	}

	// Check if version is deprecated
	if ebcl.versionManager.IsVersionDeprecated(ctx, negotiatedVersion) {
		ebcl.addDeprecationHeaders(w, negotiatedVersion)
	}

	// Parse request based on version
	var originalRequest interface{}
	var err2 error

	switch negotiatedVersion {
	case "v1":
		originalRequest, err2 = ebcl.parseV1Request(r)
	case "v2":
		originalRequest, err2 = ebcl.parseV2Request(r)
	case "v3":
		originalRequest, err2 = ebcl.parseV3Request(r)
	default:
		err2 = fmt.Errorf("unsupported version: %s", negotiatedVersion)
	}

	if err2 != nil {
		ebcl.logger.Error("Request parsing failed",
			zap.String("version", negotiatedVersion),
			zap.Error(err2))
		http.Error(w, fmt.Sprintf(`{"error":"request_parsing_failed","message":"%v"}`, err2), http.StatusBadRequest)
		return
	}

	compatReq.OriginalRequest = originalRequest

	// Transform request to internal format
	internalReq, err := ebcl.transformRequestToInternal(ctx, originalRequest, negotiatedVersion)
	if err != nil {
		ebcl.logger.Error("Request transformation failed",
			zap.String("version", negotiatedVersion),
			zap.Error(err))
		http.Error(w, fmt.Sprintf(`{"error":"request_transformation_failed","message":"%v"}`, err), http.StatusInternalServerError)
		return
	}

	// Process classification
	response, err := processor.ProcessClassification(ctx, internalReq)
	if err != nil {
		ebcl.logger.Error("Classification processing failed",
			zap.String("version", negotiatedVersion),
			zap.Error(err))
		ebcl.handleProcessingError(w, err, negotiatedVersion)
		return
	}

	// Transform response to requested version
	transformedResponse, err := ebcl.transformResponseToVersion(ctx, response, negotiatedVersion)
	if err != nil {
		ebcl.logger.Error("Response transformation failed",
			zap.String("version", negotiatedVersion),
			zap.Error(err))
		http.Error(w, fmt.Sprintf(`{"error":"response_transformation_failed","message":"%v"}`, err), http.StatusInternalServerError)
		return
	}

	// Create compatibility response
	compatResp := &CompatibilityResponse{
		OriginalResponse:    response,
		TransformedResponse: transformedResponse,
		ResponseVersion:     negotiatedVersion,
		Timestamp:           time.Now(),
	}

	// Add compatibility information
	if ebcl.shouldAddCompatibilityInfo(negotiatedVersion) {
		compatResp.CompatibilityInfo = ebcl.generateCompatibilityInfo(ctx, negotiatedVersion)
	}

	// Add deprecation information
	if ebcl.versionManager.IsVersionDeprecated(ctx, negotiatedVersion) {
		compatResp.DeprecationInfo = ebcl.generateDeprecationInfo(ctx, negotiatedVersion)
	}

	// Add migration information
	if ebcl.shouldAddMigrationInfo(negotiatedVersion) {
		compatResp.MigrationInfo = ebcl.generateMigrationInfo(ctx, negotiatedVersion)
	}

	// Set response headers
	ebcl.setCompatibilityHeaders(w, negotiatedVersion, compatResp)

	// Return response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(transformedResponse)

	// Log success
	ebcl.logger.Info("Compatibility request processed successfully",
		zap.String("version", negotiatedVersion),
		zap.String("client_version", clientVersion),
		zap.Duration("processing_time", time.Since(start)),
		zap.String("business_id", response.BusinessID))
}

// parseV1Request parses a v1 request
func (ebcl *EnhancedBackwardCompatibilityLayer) parseV1Request(r *http.Request) (*LegacyClassificationRequest, error) {
	var req LegacyClassificationRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		return nil, fmt.Errorf("failed to parse v1 request: %w", err)
	}

	if err := ebcl.validator.ValidateStruct(&req); err != nil {
		return nil, fmt.Errorf("v1 request validation failed: %w", err)
	}

	return &req, nil
}

// parseV2Request parses a v2 request
func (ebcl *EnhancedBackwardCompatibilityLayer) parseV2Request(r *http.Request) (*EnhancedClassificationRequest, error) {
	var req EnhancedClassificationRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		return nil, fmt.Errorf("failed to parse v2 request: %w", err)
	}

	if err := ebcl.validator.ValidateStruct(&req); err != nil {
		return nil, fmt.Errorf("v2 request validation failed: %w", err)
	}

	return &req, nil
}

// parseV3Request parses a v3 request
func (ebcl *EnhancedBackwardCompatibilityLayer) parseV3Request(r *http.Request) (*classification.ClassificationRequest, error) {
	var req classification.ClassificationRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		return nil, fmt.Errorf("failed to parse v3 request: %w", err)
	}

	if err := ebcl.validator.ValidateStruct(&req); err != nil {
		return nil, fmt.Errorf("v3 request validation failed: %w", err)
	}

	return &req, nil
}

// transformRequestToInternal transforms a request to internal format
func (ebcl *EnhancedBackwardCompatibilityLayer) transformRequestToInternal(
	ctx context.Context,
	originalRequest interface{},
	version string,
) (*classification.ClassificationRequest, error) {
	switch req := originalRequest.(type) {
	case *LegacyClassificationRequest:
		return &classification.ClassificationRequest{
			BusinessName: req.BusinessName,
			BusinessType: req.BusinessType,
			Industry:     req.Industry,
			Description:  req.Description,
			Keywords:     req.Keywords,
		}, nil

	case *EnhancedClassificationRequest:
		return &classification.ClassificationRequest{
			BusinessName: req.BusinessName,
			BusinessType: req.BusinessType,
			Industry:     req.Industry,
			Description:  req.Description,
			Keywords:     req.Keywords,
		}, nil

	case *classification.ClassificationRequest:
		return req, nil

	default:
		return nil, fmt.Errorf("unsupported request type for version %s", version)
	}
}

// transformResponseToVersion transforms a response to the requested version
func (ebcl *EnhancedBackwardCompatibilityLayer) transformResponseToVersion(
	ctx context.Context,
	response *classification.ClassificationResponse,
	version string,
) (interface{}, error) {
	switch version {
	case "v1":
		return ebcl.convertToLegacyResponse(response), nil
	case "v2":
		return ebcl.convertToEnhancedResponse(response), nil
	case "v3":
		return response, nil
	default:
		return nil, fmt.Errorf("unsupported version for response transformation: %s", version)
	}
}

// convertToLegacyResponse converts to v1 response format
func (ebcl *EnhancedBackwardCompatibilityLayer) convertToLegacyResponse(
	response *classification.ClassificationResponse,
) *LegacyClassificationResponse {
	// Extract primary classification info
	var primaryCode, primaryName string
	if response.PrimaryClassification != nil {
		primaryCode = response.PrimaryClassification.IndustryCode
		primaryName = response.PrimaryClassification.IndustryName
	}

	return &LegacyClassificationResponse{
		Success:              true,
		BusinessID:           response.BusinessID,
		PrimaryIndustryCode:  primaryCode,
		PrimaryIndustryName:  primaryName,
		OverallConfidence:    response.ConfidenceScore,
		ClassificationMethod: response.ClassificationMethod,
		ProcessingTimeMS:     response.ProcessingTime.Milliseconds(),
		Timestamp:            time.Now(),
		DeprecationWarning:   "This API version is deprecated. Please migrate to v2 or v3 for enhanced features.",
	}
}

// convertToEnhancedResponse converts to v2 response format
func (ebcl *EnhancedBackwardCompatibilityLayer) convertToEnhancedResponse(
	response *classification.ClassificationResponse,
) *EnhancedClassificationResponse {
	// Extract primary classification info
	var primaryCode, primaryName string
	if response.PrimaryClassification != nil {
		primaryCode = response.PrimaryClassification.IndustryCode
		primaryName = response.PrimaryClassification.IndustryName
	}

	// Extract geographic region from raw data if available
	var geographicRegion string
	if response.RawData != nil {
		if region, ok := response.RawData["geographic_region"].(string); ok {
			geographicRegion = region
		}
	}

	return &EnhancedClassificationResponse{
		Success:               true,
		APIVersion:            "v2",
		BusinessID:            response.BusinessID,
		PrimaryIndustryCode:   primaryCode,
		PrimaryIndustryName:   primaryName,
		OverallConfidence:     response.ConfidenceScore,
		ClassificationMethod:  response.ClassificationMethod,
		ProcessingTimeMS:      response.ProcessingTime.Milliseconds(),
		GeographicRegion:      geographicRegion,
		RegionConfidenceScore: nil, // Not available in current response
		EnhancedMetadata:      response.RawData,
		IndustrySpecificData:  nil, // Not available in current response
		Timestamp:             time.Now(),
	}
}

// handleProcessingError handles processing errors with version-specific error responses
func (ebcl *EnhancedBackwardCompatibilityLayer) handleProcessingError(
	w http.ResponseWriter,
	err error,
	version string,
) {
	errorResponse := map[string]interface{}{
		"error":   "classification_failed",
		"message": "Failed to process classification request",
	}

	// Add version-specific error information
	switch version {
	case "v1":
		errorResponse["deprecation_warning"] = "This API version is deprecated. Please migrate to v2 or v3."
	case "v2":
		errorResponse["deprecation_warning"] = "Consider migrating to v3 for enhanced features."
	}

	w.WriteHeader(http.StatusInternalServerError)
	json.NewEncoder(w).Encode(errorResponse)
}

// shouldAddCompatibilityInfo determines if compatibility info should be added
func (ebcl *EnhancedBackwardCompatibilityLayer) shouldAddCompatibilityInfo(version string) bool {
	return version != "v3" // Add compatibility info for older versions
}

// shouldAddMigrationInfo determines if migration info should be added
func (ebcl *EnhancedBackwardCompatibilityLayer) shouldAddMigrationInfo(version string) bool {
	return version == "v1" || version == "v2" // Add migration info for deprecated versions
}

// generateCompatibilityInfo generates compatibility information
func (ebcl *EnhancedBackwardCompatibilityLayer) generateCompatibilityInfo(
	ctx context.Context,
	version string,
) *CompatibilityInfo {
	currentVersion := ebcl.versionManager.GetCurrentVersion(ctx)
	compatibility, err := ebcl.versionManager.GetCompatibility(ctx, version, currentVersion)

	info := &CompatibilityInfo{
		IsCompatible:       true,
		CompatibilityLevel: "full",
	}

	if err == nil {
		info.IsCompatible = compatibility.IsCompatible
		info.CompatibilityLevel = compatibility.CompatibilityLevel
		info.BreakingChanges = compatibility.BreakingChanges
	}

	if version != currentVersion {
		info.Warnings = append(info.Warnings,
			fmt.Sprintf("Using version %s, current version is %s", version, currentVersion))
		info.Suggestions = append(info.Suggestions,
			fmt.Sprintf("Consider upgrading to version %s for latest features", currentVersion))
	}

	return info
}

// generateDeprecationInfo generates deprecation information
func (ebcl *EnhancedBackwardCompatibilityLayer) generateDeprecationInfo(
	ctx context.Context,
	version string,
) *DeprecationInfo {
	apiVersion, err := ebcl.versionManager.GetVersion(ctx, version)
	if err != nil {
		return nil
	}

	if apiVersion.DeprecatedAt == nil {
		return nil
	}

	sunsetDate := apiVersion.DeprecatedAt.Add(ebcl.versionManager.deprecationPeriod)

	return &DeprecationInfo{
		IsDeprecated:       true,
		DeprecatedAt:       *apiVersion.DeprecatedAt,
		SunsetDate:         sunsetDate,
		DeprecationMessage: apiVersion.DeprecationMessage,
		MigrationGuide:     apiVersion.MigrationGuide,
	}
}

// generateMigrationInfo generates migration information
func (ebcl *EnhancedBackwardCompatibilityLayer) generateMigrationInfo(
	ctx context.Context,
	version string,
) *MigrationInfo {
	currentVersion := ebcl.versionManager.GetCurrentVersion(ctx)
	compatibility, err := ebcl.versionManager.GetCompatibility(ctx, version, currentVersion)

	info := &MigrationInfo{
		MigrationRequired: false,
		EstimatedEffort:   "low",
	}

	if err == nil {
		info.MigrationRequired = compatibility.MigrationRequired
		info.MigrationSteps = compatibility.MigrationSteps
		info.BreakingChanges = compatibility.BreakingChanges
	}

	// Generate migration path
	migrationPath, err := ebcl.versionManager.GetMigrationPath(ctx, version, currentVersion)
	if err == nil {
		info.MigrationPath = migrationPath
	}

	return info
}

// setCompatibilityHeaders sets compatibility-related headers
func (ebcl *EnhancedBackwardCompatibilityLayer) setCompatibilityHeaders(
	w http.ResponseWriter,
	version string,
	compatResp *CompatibilityResponse,
) {
	w.Header().Set("X-API-Version", version)
	w.Header().Set("X-API-Current-Version", ebcl.versionManager.GetCurrentVersion(context.Background()))
	w.Header().Set("X-API-Default-Version", ebcl.versionManager.GetDefaultVersion(context.Background()))

	// Add deprecation headers
	ebcl.versionManager.AddDeprecationHeaders(context.Background(), w, version)

	// Add compatibility headers
	if compatResp.CompatibilityInfo != nil {
		w.Header().Set("X-API-Compatibility-Level", compatResp.CompatibilityInfo.CompatibilityLevel)
		if len(compatResp.CompatibilityInfo.Warnings) > 0 {
			w.Header().Set("X-API-Compatibility-Warnings", strings.Join(compatResp.CompatibilityInfo.Warnings, "; "))
		}
	}

	// Add migration headers
	if compatResp.MigrationInfo != nil && compatResp.MigrationInfo.MigrationRequired {
		w.Header().Set("X-API-Migration-Required", "true")
		if len(compatResp.MigrationInfo.MigrationPath) > 0 {
			w.Header().Set("X-API-Migration-Path", strings.Join(compatResp.MigrationInfo.MigrationPath, " -> "))
		}
	}
}

// addDeprecationHeaders adds deprecation headers to response
func (ebcl *EnhancedBackwardCompatibilityLayer) addDeprecationHeaders(w http.ResponseWriter, version string) {
	ebcl.versionManager.AddDeprecationHeaders(context.Background(), w, version)
}
