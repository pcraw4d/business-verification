package compatibility

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/pcraw4d/business-verification/internal/classification"
	"github.com/pcraw4d/business-verification/internal/config"
	"github.com/pcraw4d/business-verification/pkg/validators"
)

// BackwardCompatibilityLayer handles backward compatibility for API endpoints
type BackwardCompatibilityLayer struct {
	featureFlagManager *config.FeatureFlagManager
	logger             interface {
		WithComponent(component string) interface {
			WithError(err error) interface {
				Error(msg string)
			}
			LogBusinessEvent(ctx context.Context, event string, businessID string, metadata map[string]interface{})
		}
	}
	metrics interface {
		RecordBusinessClassification(metric string, value string)
	}
	validator *validators.Validator
}

// NewBackwardCompatibilityLayer creates a new backward compatibility layer
func NewBackwardCompatibilityLayer(
	featureFlagManager *config.FeatureFlagManager,
	logger interface {
		WithComponent(component string) interface {
			WithError(err error) interface {
				Error(msg string)
			}
			LogBusinessEvent(ctx context.Context, event string, businessID string, metadata map[string]interface{})
		}
	},
	metrics interface {
		RecordBusinessClassification(metric string, value string)
	},
	validator *validators.Validator,
) *BackwardCompatibilityLayer {
	return &BackwardCompatibilityLayer{
		featureFlagManager: featureFlagManager,
		logger:             logger,
		metrics:            metrics,
		validator:          validator,
	}
}

// LegacyClassificationRequest represents the legacy v1 API request format
type LegacyClassificationRequest struct {
	BusinessName string `json:"business_name" validate:"required"`
	BusinessType string `json:"business_type,omitempty"`
	Industry     string `json:"industry,omitempty"`
	Description  string `json:"description,omitempty"`
	Keywords     string `json:"keywords,omitempty"`
}

// LegacyClassificationResponse represents the legacy v1 API response format
type LegacyClassificationResponse struct {
	Success              bool      `json:"success"`
	BusinessID           string    `json:"business_id"`
	PrimaryIndustryCode  string    `json:"primary_industry_code"`
	PrimaryIndustryName  string    `json:"primary_industry_name"`
	OverallConfidence    float64   `json:"overall_confidence"`
	ClassificationMethod string    `json:"classification_method"`
	ProcessingTimeMS     int64     `json:"processing_time_ms"`
	Timestamp            time.Time `json:"timestamp"`
	DeprecationWarning   string    `json:"deprecation_warning,omitempty"`
}

// LegacyBatchClassificationRequest represents the legacy v1 batch API request format
type LegacyBatchClassificationRequest struct {
	Businesses []LegacyClassificationRequest `json:"businesses" validate:"required,min=1,max=100"`
}

// LegacyBatchClassificationResponse represents the legacy v1 batch API response format
type LegacyBatchClassificationResponse struct {
	Success            bool                           `json:"success"`
	TotalCount         int                            `json:"total_count"`
	SuccessCount       int                            `json:"success_count"`
	ErrorCount         int                            `json:"error_count"`
	Results            []LegacyClassificationResponse `json:"results"`
	ProcessingTimeMS   int64                          `json:"processing_time_ms"`
	DeprecationWarning string                         `json:"deprecation_warning,omitempty"`
}

// EnhancedClassificationRequest represents the enhanced v2 API request format
type EnhancedClassificationRequest struct {
	BusinessName     string `json:"business_name" validate:"required"`
	BusinessType     string `json:"business_type,omitempty"`
	Industry         string `json:"industry,omitempty"`
	Description      string `json:"description,omitempty"`
	Keywords         string `json:"keywords,omitempty"`
	GeographicRegion string `json:"geographic_region,omitempty"`
	APIVersion       string `json:"api_version,omitempty"`
}

// EnhancedClassificationResponse represents the enhanced v2 API response format
type EnhancedClassificationResponse struct {
	Success               bool                   `json:"success"`
	APIVersion            string                 `json:"api_version"`
	BusinessID            string                 `json:"business_id"`
	PrimaryIndustryCode   string                 `json:"primary_industry_code"`
	PrimaryIndustryName   string                 `json:"primary_industry_name"`
	OverallConfidence     float64                `json:"overall_confidence"`
	ClassificationMethod  string                 `json:"classification_method"`
	ProcessingTimeMS      int64                  `json:"processing_time_ms"`
	GeographicRegion      string                 `json:"geographic_region,omitempty"`
	RegionConfidenceScore *float64               `json:"region_confidence_score,omitempty"`
	EnhancedMetadata      map[string]interface{} `json:"enhanced_metadata,omitempty"`
	IndustrySpecificData  map[string]interface{} `json:"industry_specific_data,omitempty"`
	Timestamp             time.Time              `json:"timestamp"`
}

// ClassificationProcessor defines the interface for classification processing
type ClassificationProcessor interface {
	ProcessClassification(ctx context.Context, request *classification.ClassificationRequest) (*classification.ClassificationResponse, error)
	ProcessBatchClassification(ctx context.Context, requests []*classification.ClassificationRequest) ([]*classification.ClassificationResponse, error)
}

// HandleLegacyClassification handles legacy v1 classification requests
func (bcl *BackwardCompatibilityLayer) HandleLegacyClassification(
	w http.ResponseWriter,
	r *http.Request,
	processor ClassificationProcessor,
) {
	// Set response headers for legacy API
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-API-Version", "v1")
	w.Header().Set("X-Deprecation-Warning", "This API version is deprecated. Please migrate to v2.")

	// Parse request
	var legacyReq LegacyClassificationRequest
	if err := json.NewDecoder(r.Body).Decode(&legacyReq); err != nil {
		bcl.logger.WithComponent("compatibility").WithError(err).Error("Failed to parse legacy request")
		http.Error(w, `{"error":"invalid_json","message":"Invalid JSON format"}`, http.StatusBadRequest)
		return
	}

	// Validate request
	if err := bcl.validator.ValidateStruct(&legacyReq); err != nil {
		bcl.logger.WithComponent("compatibility").WithError(err).Error("Legacy request validation failed")
		http.Error(w, fmt.Sprintf(`{"error":"validation_failed","message":"%v"}`, err), http.StatusBadRequest)
		return
	}

	// Convert to internal format
	internalReq := &classification.ClassificationRequest{
		BusinessName: legacyReq.BusinessName,
		BusinessType: legacyReq.BusinessType,
		Industry:     legacyReq.Industry,
		Description:  legacyReq.Description,
		Keywords:     legacyReq.Keywords,
	}

	// Process classification
	ctx := r.Context()
	response, err := processor.ProcessClassification(ctx, internalReq)
	if err != nil {
		bcl.logger.WithComponent("compatibility").WithError(err).Error("Classification processing failed")
		bcl.metrics.RecordBusinessClassification("error", "legacy_classification_failed")

		errorResponse := map[string]interface{}{
			"error":               "classification_failed",
			"message":             "Failed to process classification request",
			"deprecation_warning": "This API version is deprecated. Please migrate to v2.",
		}
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(errorResponse)
		return
	}

	// Convert to legacy response format
	legacyResponse := bcl.convertToLegacyResponse(response)
	legacyResponse.DeprecationWarning = "This API version is deprecated. Please migrate to v2."

	// Log success
	bcl.logger.WithComponent("compatibility").LogBusinessEvent(ctx, "legacy_classification_success", response.BusinessID, map[string]interface{}{
		"business_name":      legacyReq.BusinessName,
		"api_version":        "v1",
		"processing_time_ms": response.ProcessingTime.Milliseconds(),
	})

	bcl.metrics.RecordBusinessClassification("success", "legacy_classification")

	// Return response
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(legacyResponse)
}

// HandleLegacyBatchClassification handles legacy v1 batch classification requests
func (bcl *BackwardCompatibilityLayer) HandleLegacyBatchClassification(
	w http.ResponseWriter,
	r *http.Request,
	processor ClassificationProcessor,
) {
	// Set response headers for legacy API
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-API-Version", "v1")
	w.Header().Set("X-Deprecation-Warning", "This API version is deprecated. Please migrate to v2.")

	// Parse request
	var legacyBatchReq LegacyBatchClassificationRequest
	if err := json.NewDecoder(r.Body).Decode(&legacyBatchReq); err != nil {
		bcl.logger.WithComponent("compatibility").WithError(err).Error("Failed to parse legacy batch request")
		http.Error(w, `{"error":"invalid_json","message":"Invalid JSON format"}`, http.StatusBadRequest)
		return
	}

	// Validate request
	if err := bcl.validator.ValidateStruct(&legacyBatchReq); err != nil {
		bcl.logger.WithComponent("compatibility").WithError(err).Error("Legacy batch request validation failed")
		http.Error(w, fmt.Sprintf(`{"error":"validation_failed","message":"%v"}`, err), http.StatusBadRequest)
		return
	}

	// Convert to internal format
	var internalReqs []*classification.ClassificationRequest
	for _, legacyReq := range legacyBatchReq.Businesses {
		internalReq := &classification.ClassificationRequest{
			BusinessName: legacyReq.BusinessName,
			BusinessType: legacyReq.BusinessType,
			Industry:     legacyReq.Industry,
			Description:  legacyReq.Description,
			Keywords:     legacyReq.Keywords,
		}
		internalReqs = append(internalReqs, internalReq)
	}

	// Process batch classification
	ctx := r.Context()
	responses, err := processor.ProcessBatchClassification(ctx, internalReqs)
	if err != nil {
		bcl.logger.WithComponent("compatibility").WithError(err).Error("Batch classification processing failed")
		bcl.metrics.RecordBusinessClassification("error", "legacy_batch_classification_failed")

		errorResponse := map[string]interface{}{
			"error":               "batch_classification_failed",
			"message":             "Failed to process batch classification request",
			"deprecation_warning": "This API version is deprecated. Please migrate to v2.",
		}
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(errorResponse)
		return
	}

	// Convert to legacy response format
	var legacyResults []LegacyClassificationResponse
	successCount := 0
	errorCount := 0

	for _, response := range responses {
		if response != nil {
			legacyResult := bcl.convertToLegacyResponse(response)
			legacyResult.DeprecationWarning = "This API version is deprecated. Please migrate to v2."
			legacyResults = append(legacyResults, *legacyResult)
			successCount++
		} else {
			errorCount++
		}
	}

	legacyBatchResponse := LegacyBatchClassificationResponse{
		Success:            true,
		TotalCount:         len(legacyBatchReq.Businesses),
		SuccessCount:       successCount,
		ErrorCount:         errorCount,
		Results:            legacyResults,
		ProcessingTimeMS:   time.Since(time.Now()).Milliseconds(), // This should be calculated properly
		DeprecationWarning: "This API version is deprecated. Please migrate to v2.",
	}

	// Log success
	bcl.logger.WithComponent("compatibility").LogBusinessEvent(ctx, "legacy_batch_classification_success", "", map[string]interface{}{
		"total_count":   len(legacyBatchReq.Businesses),
		"success_count": successCount,
		"error_count":   errorCount,
		"api_version":   "v1",
	})

	bcl.metrics.RecordBusinessClassification("success", "legacy_batch_classification")

	// Return response
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(legacyBatchResponse)
}

// HandleEnhancedClassification handles enhanced v2 classification requests
func (bcl *BackwardCompatibilityLayer) HandleEnhancedClassification(
	w http.ResponseWriter,
	r *http.Request,
	processor ClassificationProcessor,
) {
	apiVersion := bcl.getAPIVersion(r)

	// Set response headers for enhanced API
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-API-Version", apiVersion)

	// Parse request
	var enhancedReq EnhancedClassificationRequest
	if err := json.NewDecoder(r.Body).Decode(&enhancedReq); err != nil {
		bcl.logger.WithComponent("compatibility").WithError(err).Error("Failed to parse enhanced request")
		http.Error(w, `{"error":"invalid_json","message":"Invalid JSON format"}`, http.StatusBadRequest)
		return
	}

	// Validate request
	if err := bcl.validator.ValidateStruct(&enhancedReq); err != nil {
		bcl.logger.WithComponent("compatibility").WithError(err).Error("Enhanced request validation failed")
		http.Error(w, fmt.Sprintf(`{"error":"validation_failed","message":"%v"}`, err), http.StatusBadRequest)
		return
	}

	// Convert to internal format
	internalReq := &classification.ClassificationRequest{
		BusinessName: enhancedReq.BusinessName,
		BusinessType: enhancedReq.BusinessType,
		Industry:     enhancedReq.Industry,
		Description:  enhancedReq.Description,
		Keywords:     enhancedReq.Keywords,
	}

	// Process classification
	ctx := r.Context()
	response, err := processor.ProcessClassification(ctx, internalReq)
	if err != nil {
		bcl.logger.WithComponent("compatibility").WithError(err).Error("Enhanced classification processing failed")
		bcl.metrics.RecordBusinessClassification("error", "enhanced_classification_failed")

		errorResponse := map[string]interface{}{
			"error":   "classification_failed",
			"message": "Failed to process classification request",
		}
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(errorResponse)
		return
	}

	// Convert to enhanced response format
	enhancedResponse := bcl.convertToEnhancedResponse(response, apiVersion)

	// Log success
	bcl.logger.WithComponent("compatibility").LogBusinessEvent(ctx, "enhanced_classification_success", response.BusinessID, map[string]interface{}{
		"business_name":      enhancedReq.BusinessName,
		"api_version":        apiVersion,
		"processing_time_ms": response.ProcessingTime.Milliseconds(),
	})

	bcl.metrics.RecordBusinessClassification("success", "enhanced_classification")

	// Return response
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(enhancedResponse)
}

// getAPIVersion determines the API version from request headers or query parameters
func (bcl *BackwardCompatibilityLayer) getAPIVersion(r *http.Request) string {
	// Check Accept header first
	if accept := r.Header.Get("Accept"); accept != "" {
		if version := extractVersionFromAccept(accept); version != "" {
			return version
		}
	}

	// Check X-API-Version header
	if version := r.Header.Get("X-API-Version"); version != "" {
		return version
	}

	// Check query parameter
	if version := r.URL.Query().Get("api_version"); version != "" {
		return version
	}

	// Default to v2
	return "v2"
}

// extractVersionFromAccept extracts version from Accept header
func extractVersionFromAccept(accept string) string {
	// Simple extraction - look for version in format like "application/vnd.kyb.v2+json"
	// This is a simplified implementation
	if len(accept) > 0 {
		// Look for version pattern
		for i := 0; i < len(accept)-1; i++ {
			if accept[i] == 'v' && i+1 < len(accept) && accept[i+1] >= '0' && accept[i+1] <= '9' {
				// Found version, extract it
				version := "v"
				for j := i + 1; j < len(accept) && accept[j] >= '0' && accept[j] <= '9'; j++ {
					version += string(accept[j])
				}
				return version
			}
		}
	}
	return ""
}

// convertToLegacyResponse converts internal response to legacy v1 format
func (bcl *BackwardCompatibilityLayer) convertToLegacyResponse(response *classification.ClassificationResponse) *LegacyClassificationResponse {
	legacyResponse := &LegacyClassificationResponse{
		Success:              true,
		BusinessID:           response.BusinessID,
		OverallConfidence:    response.ConfidenceScore,
		ClassificationMethod: response.ClassificationMethod,
		ProcessingTimeMS:     response.ProcessingTime.Milliseconds(),
		Timestamp:            time.Now(),
	}

	// Set primary industry information
	if response.PrimaryClassification != nil {
		legacyResponse.PrimaryIndustryCode = response.PrimaryClassification.IndustryCode
		legacyResponse.PrimaryIndustryName = response.PrimaryClassification.IndustryName
	} else if len(response.Classifications) > 0 {
		// Fallback to first classification
		legacyResponse.PrimaryIndustryCode = response.Classifications[0].IndustryCode
		legacyResponse.PrimaryIndustryName = response.Classifications[0].IndustryName
	}

	return legacyResponse
}

// convertToEnhancedResponse converts internal response to enhanced v2 format
func (bcl *BackwardCompatibilityLayer) convertToEnhancedResponse(response *classification.ClassificationResponse, apiVersion string) *EnhancedClassificationResponse {
	enhancedResponse := &EnhancedClassificationResponse{
		Success:              true,
		APIVersion:           apiVersion,
		BusinessID:           response.BusinessID,
		OverallConfidence:    response.ConfidenceScore,
		ClassificationMethod: response.ClassificationMethod,
		ProcessingTimeMS:     response.ProcessingTime.Milliseconds(),
		Timestamp:            time.Now(),
	}

	// Set primary industry information
	if response.PrimaryClassification != nil {
		enhancedResponse.PrimaryIndustryCode = response.PrimaryClassification.IndustryCode
		enhancedResponse.PrimaryIndustryName = response.PrimaryClassification.IndustryName
	} else if len(response.Classifications) > 0 {
		// Fallback to first classification
		enhancedResponse.PrimaryIndustryCode = response.Classifications[0].IndustryCode
		enhancedResponse.PrimaryIndustryName = response.Classifications[0].IndustryName
	}

	// Extract enhanced data from RawData
	if response.RawData != nil {
		if geographicRegion, ok := response.RawData["geographic_region"].(string); ok {
			enhancedResponse.GeographicRegion = geographicRegion
			// Calculate region confidence
			regionConfidence := bcl.calculateRegionConfidence(geographicRegion, response)
			enhancedResponse.RegionConfidenceScore = &regionConfidence
		}

		if enhancedMetadata, ok := response.RawData["enhanced_metadata"].(map[string]interface{}); ok {
			enhancedResponse.EnhancedMetadata = enhancedMetadata
		}

		if industrySpecificData, ok := response.RawData["industry_specific_data"].(map[string]interface{}); ok {
			enhancedResponse.IndustrySpecificData = industrySpecificData
		}
	}

	return enhancedResponse
}

// calculateRegionConfidence calculates confidence score adjusted for geographic region
func (bcl *BackwardCompatibilityLayer) calculateRegionConfidence(region string, response *classification.ClassificationResponse) float64 {
	baseConfidence := response.ConfidenceScore

	// Simple region-based confidence adjustment
	// In a real implementation, this would use more sophisticated logic
	regionBoosts := map[string]float64{
		"North America": 0.05,
		"Europe":        0.03,
		"Asia":          0.02,
		"Australia":     0.03,
		"South America": 0.01,
		"Africa":        0.01,
	}

	if boost, exists := regionBoosts[region]; exists {
		adjustedConfidence := baseConfidence + boost
		// Ensure confidence doesn't exceed 1.0
		if adjustedConfidence > 1.0 {
			return 1.0
		}
		return adjustedConfidence
	}

	return baseConfidence
}

// HandleAPIVersionInfo handles API version information endpoint
func (bcl *BackwardCompatibilityLayer) HandleAPIVersionInfo(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	versionInfo := map[string]interface{}{
		"current_version":    "v2",
		"supported_versions": []string{"v1", "v2"},
		"deprecation_schedule": map[string]interface{}{
			"v1": map[string]interface{}{
				"deprecated_since": "2024-01-01",
				"sunset_date":      "2024-12-31",
				"migration_guide":  "/docs/migration/v1-to-v2",
			},
		},
		"feature_flags": map[string]interface{}{
			"modular_architecture": bcl.featureFlagManager.IsEnabled("modular_architecture"),
			"intelligent_routing":  bcl.featureFlagManager.IsEnabled("intelligent_routing"),
			"ab_testing":           bcl.featureFlagManager.IsEnabled("ab_testing"),
		},
		"endpoints": map[string]interface{}{
			"v1": []string{
				"POST /v1/classify",
				"POST /v1/classify/batch",
			},
			"v2": []string{
				"POST /v2/classify",
				"POST /v2/classify/batch",
				"GET /v2/versions",
			},
		},
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(versionInfo)
}
