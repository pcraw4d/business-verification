package middleware

import (
	"encoding/json"
	"net/http"
	"testing"
	"time"
)

func TestDefaultLoadTestConfig(t *testing.T) {
	config := DefaultLoadTestConfig()

	if config.ConcurrentUsers != 50 {
		t.Errorf("Expected 50 concurrent users, got %d", config.ConcurrentUsers)
	}

	if config.RequestsPerUser != 10 {
		t.Errorf("Expected 10 requests per user, got %d", config.RequestsPerUser)
	}

	if config.TestDuration != 5*time.Minute {
		t.Errorf("Expected 5 minute test duration, got %v", config.TestDuration)
	}

	if config.TargetEndpoint != "/v1/classify" {
		t.Errorf("Expected /v1/classify endpoint, got %s", config.TargetEndpoint)
	}
}

func TestNewLoadTester(t *testing.T) {
	config := &LoadTestConfig{
		ConcurrentUsers: 10,
		RequestsPerUser: 5,
		TestDuration:    1 * time.Minute,
	}

	loadTester := NewLoadTester(config)

	if loadTester.config != config {
		t.Error("LoadTester config not set correctly")
	}

	if loadTester.httpClient.Timeout != config.RequestTimeout {
		t.Errorf("Expected timeout %v, got %v", config.RequestTimeout, loadTester.httpClient.Timeout)
	}
}

func TestLoadTester_RunLoadTest(t *testing.T) {
	// Create a simple test handler
	testHandler := func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": true,
			"message": "test response",
		})
	}

	// Create load test configuration
	config := &LoadTestConfig{
		ConcurrentUsers: 5,                // Small number for testing
		RequestsPerUser: 3,                // Small number for testing
		TestDuration:    10 * time.Second, // Short duration for testing
		RampUpTime:      2 * time.Second,  // Short ramp up
		RampDownTime:    2 * time.Second,  // Short ramp down
		RequestTimeout:  5 * time.Second,  // Short timeout
		TargetEndpoint:  "/v1/classify",
		EnableMetrics:   true,
	}

	loadTester := NewLoadTester(config)

	// Run the load test
	result, err := loadTester.RunLoadTest(testHandler)
	if err != nil {
		t.Fatalf("Load test failed: %v", err)
	}

	// Verify basic results
	if result.TotalRequests == 0 {
		t.Error("Expected non-zero total requests")
	}

	if result.SuccessfulRequests == 0 {
		t.Error("Expected non-zero successful requests")
	}

	if result.RequestsPerSecond <= 0 {
		t.Error("Expected positive requests per second")
	}

	if result.AverageResponseTime <= 0 {
		t.Error("Expected positive average response time")
	}
}

func TestLoadTestResult_CalculateResponseTimeStats(t *testing.T) {
	result := &LoadTestResult{}

	// Test with empty times slice
	result.calculateResponseTimeStats([]time.Duration{})
	if result.MinResponseTime != 0 || result.MaxResponseTime != 0 {
		t.Error("Expected zero response times for empty slice")
	}

	// Test with single time
	times := []time.Duration{100 * time.Millisecond}
	result.calculateResponseTimeStats(times)
	if result.MinResponseTime != 100*time.Millisecond {
		t.Errorf("Expected min response time 100ms, got %v", result.MinResponseTime)
	}
	if result.MaxResponseTime != 100*time.Millisecond {
		t.Errorf("Expected max response time 100ms, got %v", result.MaxResponseTime)
	}
	if result.AverageResponseTime != 100*time.Millisecond {
		t.Errorf("Expected average response time 100ms, got %v", result.AverageResponseTime)
	}

	// Test with multiple times
	times = []time.Duration{
		100 * time.Millisecond,
		200 * time.Millisecond,
		300 * time.Millisecond,
		400 * time.Millisecond,
		500 * time.Millisecond,
	}
	result.calculateResponseTimeStats(times)
	if result.MinResponseTime != 100*time.Millisecond {
		t.Errorf("Expected min response time 100ms, got %v", result.MinResponseTime)
	}
	if result.MaxResponseTime != 500*time.Millisecond {
		t.Errorf("Expected max response time 500ms, got %v", result.MaxResponseTime)
	}
	if result.AverageResponseTime != 300*time.Millisecond {
		t.Errorf("Expected average response time 300ms, got %v", result.AverageResponseTime)
	}
	if result.P50ResponseTime != 300*time.Millisecond {
		t.Errorf("Expected P50 response time 300ms, got %v", result.P50ResponseTime)
	}
	if result.P95ResponseTime != 500*time.Millisecond {
		t.Errorf("Expected P95 response time 500ms, got %v", result.P95ResponseTime)
	}
	if result.P99ResponseTime != 500*time.Millisecond {
		t.Errorf("Expected P99 response time 500ms, got %v", result.P99ResponseTime)
	}
}

func TestLoadTester_AnalyzeCapacity(t *testing.T) {
	loadTester := NewLoadTester(nil)

	// Test with high error rate
	result := &LoadTestResult{
		TestConfig: &LoadTestConfig{
			ConcurrentUsers: 100,
		},
		ErrorRate: 0.1, // 10% error rate
	}

	analysis := loadTester.analyzeCapacity(result)
	if analysis.BottleneckType != "Queue" {
		t.Errorf("Expected Queue bottleneck, got %s", analysis.BottleneckType)
	}
	if analysis.BottleneckSeverity != "High" {
		t.Errorf("Expected High severity, got %s", analysis.BottleneckSeverity)
	}
	if analysis.MaxConcurrentUsers != 80 {
		t.Errorf("Expected 80 max concurrent users, got %d", analysis.MaxConcurrentUsers)
	}

	// Test with slow response time
	result = &LoadTestResult{
		TestConfig: &LoadTestConfig{
			ConcurrentUsers: 100,
		},
		ErrorRate:           0.01,            // 1% error rate
		AverageResponseTime: 6 * time.Second, // 6 second response time
	}

	analysis = loadTester.analyzeCapacity(result)
	if analysis.BottleneckType != "Processing" {
		t.Errorf("Expected Processing bottleneck, got %s", analysis.BottleneckType)
	}
	if analysis.BottleneckSeverity != "Medium" {
		t.Errorf("Expected Medium severity, got %s", analysis.BottleneckSeverity)
	}
	if analysis.MaxConcurrentUsers != 90 {
		t.Errorf("Expected 90 max concurrent users, got %d", analysis.MaxConcurrentUsers)
	}

	// Test with good performance
	result = &LoadTestResult{
		TestConfig: &LoadTestConfig{
			ConcurrentUsers: 100,
		},
		ErrorRate:           0.01,            // 1% error rate
		AverageResponseTime: 2 * time.Second, // 2 second response time
	}

	analysis = loadTester.analyzeCapacity(result)
	if analysis.BottleneckType != "None" {
		t.Errorf("Expected None bottleneck, got %s", analysis.BottleneckType)
	}
	if analysis.BottleneckSeverity != "Low" {
		t.Errorf("Expected Low severity, got %s", analysis.BottleneckSeverity)
	}
	if analysis.MaxConcurrentUsers != 120 {
		t.Errorf("Expected 120 max concurrent users, got %d", analysis.MaxConcurrentUsers)
	}
}

func TestLoadTester_EstimateResourceUtilization(t *testing.T) {
	loadTester := NewLoadTester(nil)

	result := &LoadTestResult{
		TestConfig: &LoadTestConfig{
			ConcurrentUsers: 50,
		},
		TotalRequests:     1000,
		RequestsPerSecond: 100.0,
	}

	// Test CPU utilization estimation
	cpuUtil := loadTester.estimateCPUUtilization(result)
	if cpuUtil <= 0 {
		t.Error("Expected positive CPU utilization")
	}
	if cpuUtil > 100 {
		t.Error("Expected CPU utilization <= 100%")
	}

	// Test memory utilization estimation
	memoryUtil := loadTester.estimateMemoryUtilization(result)
	if memoryUtil <= 0 {
		t.Error("Expected positive memory utilization")
	}
	if memoryUtil > 100 {
		t.Error("Expected memory utilization <= 100%")
	}

	// Test network utilization estimation
	networkUtil := loadTester.estimateNetworkUtilization(result)
	if networkUtil <= 0 {
		t.Error("Expected positive network utilization")
	}
	if networkUtil > 100 {
		t.Error("Expected network utilization <= 100%")
	}
}

func TestCapacityAnalysis_AddCapacityRecommendations(t *testing.T) {
	analysis := &CapacityAnalysis{
		ResourceUtilization: map[string]float64{
			"CPU":    85.0,
			"Memory": 75.0,
		},
	}

	result := &LoadTestResult{
		ErrorRate:           0.15,            // 15% error rate
		TimeoutRate:         0.08,            // 8% timeout rate
		RateLimitRate:       0.12,            // 12% rate limit rate
		AverageResponseTime: 4 * time.Second, // 4 second response time
	}

	analysis.addCapacityRecommendations(result)

	if len(analysis.Recommendations) == 0 {
		t.Error("Expected recommendations to be added")
	}

	// Check for specific recommendations
	hasErrorRateRecommendation := false
	hasTimeoutRecommendation := false
	hasRateLimitRecommendation := false
	hasResponseTimeRecommendation := false
	hasCPURecommendation := false

	for _, rec := range analysis.Recommendations {
		if containsLoadTest(rec, "circuit breakers") {
			hasErrorRateRecommendation = true
		}
		if containsLoadTest(rec, "timeout") {
			hasTimeoutRecommendation = true
		}
		if containsLoadTest(rec, "rate limits") {
			hasRateLimitRecommendation = true
		}
		if containsLoadTest(rec, "database queries") {
			hasResponseTimeRecommendation = true
		}
		if containsLoadTest(rec, "horizontal scaling") {
			hasCPURecommendation = true
		}
	}

	if !hasErrorRateRecommendation {
		t.Error("Expected error rate recommendation")
	}
	if !hasTimeoutRecommendation {
		t.Error("Expected timeout recommendation")
	}
	if !hasRateLimitRecommendation {
		t.Error("Expected rate limit recommendation")
	}
	if !hasResponseTimeRecommendation {
		t.Error("Expected response time recommendation")
	}
	if !hasCPURecommendation {
		t.Error("Expected CPU recommendation")
	}
}

func TestLoadTester_GetTestHistory(t *testing.T) {
	loadTester := NewLoadTester(nil)

	// Initially should be empty
	history := loadTester.GetTestHistory()
	if len(history) != 0 {
		t.Error("Expected empty history initially")
	}

	// Add a test result
	result := &LoadTestResult{
		TestConfig: &LoadTestConfig{
			ConcurrentUsers: 10,
		},
		TotalRequests: 100,
	}

	loadTester.mu.Lock()
	loadTester.results = append(loadTester.results, result)
	loadTester.mu.Unlock()

	// Should now have one result
	history = loadTester.GetTestHistory()
	if len(history) != 1 {
		t.Errorf("Expected 1 result in history, got %d", len(history))
	}
}

func TestLoadTester_GenerateCapacityReport(t *testing.T) {
	loadTester := NewLoadTester(nil)

	// Test with no history
	report := loadTester.GenerateCapacityReport()
	if report != "No load test results available" {
		t.Errorf("Expected 'No load test results available', got %s", report)
	}

	// Add a test result
	result := &LoadTestResult{
		TestConfig: &LoadTestConfig{
			ConcurrentUsers: 50,
		},
		StartTime:           time.Now().Add(-5 * time.Minute),
		EndTime:             time.Now(),
		TotalRequests:       1000,
		SuccessfulRequests:  950,
		FailedRequests:      50,
		RequestsPerSecond:   100.0,
		ErrorRate:           0.05,
		AverageResponseTime: 2 * time.Second,
		P95ResponseTime:     3 * time.Second,
		P99ResponseTime:     4 * time.Second,
		CapacityAnalysis: &CapacityAnalysis{
			MaxConcurrentUsers:     60,
			OptimalConcurrentUsers: 48,
			BottleneckType:         "Processing",
			BottleneckSeverity:     "Medium",
			ScalingFactor:          1.2,
			ResourceUtilization: map[string]float64{
				"CPU":     70.0,
				"Memory":  60.0,
				"Network": 40.0,
			},
			Recommendations: []string{
				"Optimize request processing",
				"Consider horizontal scaling",
			},
		},
	}

	loadTester.mu.Lock()
	loadTester.results = append(loadTester.results, result)
	loadTester.mu.Unlock()

	// Generate report
	report = loadTester.GenerateCapacityReport()

	// Check that report contains expected sections
	if !containsLoadTest(report, "Capacity Planning Report") {
		t.Error("Expected 'Capacity Planning Report' in report")
	}
	if !containsLoadTest(report, "Test Summary") {
		t.Error("Expected 'Test Summary' in report")
	}
	if !containsLoadTest(report, "Latest Test Analysis") {
		t.Error("Expected 'Latest Test Analysis' in report")
	}
	if !containsLoadTest(report, "Capacity Analysis") {
		t.Error("Expected 'Capacity Analysis' in report")
	}
	if !containsLoadTest(report, "Resource Utilization") {
		t.Error("Expected 'Resource Utilization' in report")
	}
	if !containsLoadTest(report, "Recommendations") {
		t.Error("Expected 'Recommendations' in report")
	}
}

func TestLoadTester_CalculateAverages(t *testing.T) {
	loadTester := NewLoadTester(nil)

	// Test with empty history
	history := []*LoadTestResult{}
	avgRPS := loadTester.calculateAverageRPS(history)
	if avgRPS != 0 {
		t.Errorf("Expected 0 average RPS, got %f", avgRPS)
	}

	avgErrorRate := loadTester.calculateAverageErrorRate(history)
	if avgErrorRate != 0 {
		t.Errorf("Expected 0 average error rate, got %f", avgErrorRate)
	}

	avgResponseTime := loadTester.calculateAverageResponseTime(history)
	if avgResponseTime != 0 {
		t.Errorf("Expected 0 average response time, got %v", avgResponseTime)
	}

	// Test with history
	history = []*LoadTestResult{
		{
			RequestsPerSecond:   100.0,
			ErrorRate:           0.05,
			AverageResponseTime: 2 * time.Second,
		},
		{
			RequestsPerSecond:   200.0,
			ErrorRate:           0.10,
			AverageResponseTime: 3 * time.Second,
		},
		{
			RequestsPerSecond:   150.0,
			ErrorRate:           0.07,
			AverageResponseTime: 2500 * time.Millisecond,
		},
	}

	avgRPS = loadTester.calculateAverageRPS(history)
	expectedRPS := 150.0
	if avgRPS != expectedRPS {
		t.Errorf("Expected %f average RPS, got %f", expectedRPS, avgRPS)
	}

	avgErrorRate = loadTester.calculateAverageErrorRate(history)
	expectedErrorRate := 0.07333333333333333
	if avgErrorRate != expectedErrorRate {
		t.Errorf("Expected %f average error rate, got %f", expectedErrorRate, avgErrorRate)
	}

	avgResponseTime = loadTester.calculateAverageResponseTime(history)
	expectedResponseTime := 2500 * time.Millisecond
	if avgResponseTime != expectedResponseTime {
		t.Errorf("Expected %v average response time, got %v", expectedResponseTime, avgResponseTime)
	}
}

// Helper function to check if a string contains a substring
func containsLoadTest(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || (len(s) > len(substr) && (s[:len(substr)] == substr || s[len(s)-len(substr):] == substr || containsSubstringLoadTest(s, substr))))
}

func containsSubstringLoadTest(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
