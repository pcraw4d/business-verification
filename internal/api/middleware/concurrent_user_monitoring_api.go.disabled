package middleware

import (
	"encoding/json"
	"net/http"
	"strconv"
	"time"
)

// ConcurrentUserMonitoringAPI provides HTTP endpoints for concurrent user monitoring
type ConcurrentUserMonitoringAPI struct {
	monitor *ConcurrentUserMonitor
}

// NewConcurrentUserMonitoringAPI creates a new concurrent user monitoring API
func NewConcurrentUserMonitoringAPI(monitor *ConcurrentUserMonitor) *ConcurrentUserMonitoringAPI {
	return &ConcurrentUserMonitoringAPI{
		monitor: monitor,
	}
}

// MonitoringMetricsResponse represents monitoring metrics response
type MonitoringMetricsResponse struct {
	Success bool                   `json:"success"`
	Metrics *ConcurrentUserMetrics `json:"metrics"`
	Error   string                 `json:"error,omitempty"`
}

// OptimizationHistoryResponse represents optimization history response
type OptimizationHistoryResponse struct {
	Success bool                `json:"success"`
	History []OptimizationEvent `json:"history"`
	Count   int                 `json:"count"`
	Error   string              `json:"error,omitempty"`
}

// AlertHistoryResponse represents alert history response
type AlertHistoryResponse struct {
	Success bool         `json:"success"`
	Alerts  []AlertEvent `json:"alerts"`
	Count   int          `json:"count"`
	Error   string       `json:"error,omitempty"`
}

// SystemStatusResponse represents system status response
type SystemStatusResponse struct {
	Success bool                   `json:"success"`
	Status  map[string]interface{} `json:"status"`
	Error   string                 `json:"error,omitempty"`
}

// GetMonitoringMetricsHandler returns current monitoring metrics
func (api *ConcurrentUserMonitoringAPI) GetMonitoringMetricsHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	metrics := api.monitor.GetMetrics()

	response := MonitoringMetricsResponse{
		Success: true,
		Metrics: metrics,
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(response)
}

// GetOptimizationHistoryHandler returns optimization history
func (api *ConcurrentUserMonitoringAPI) GetOptimizationHistoryHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Get query parameters for pagination
	limitStr := r.URL.Query().Get("limit")
	offsetStr := r.URL.Query().Get("offset")

	limit := 50 // Default limit
	if limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 && l <= 1000 {
			limit = l
		}
	}

	offset := 0 // Default offset
	if offsetStr != "" {
		if o, err := strconv.Atoi(offsetStr); err == nil && o >= 0 {
			offset = o
		}
	}

	// Get optimization history
	history := api.monitor.GetOptimizationHistory()

	// Apply pagination
	totalCount := len(history)
	var paginatedHistory []OptimizationEvent

	if offset >= totalCount {
		paginatedHistory = []OptimizationEvent{}
	} else {
		end := offset + limit
		if end > totalCount {
			end = totalCount
		}
		paginatedHistory = history[offset:end]
	}

	response := OptimizationHistoryResponse{
		Success: true,
		History: paginatedHistory,
		Count:   len(paginatedHistory),
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(response)
}

// GetAlertHistoryHandler returns alert history
func (api *ConcurrentUserMonitoringAPI) GetAlertHistoryHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Get query parameters for filtering
	level := r.URL.Query().Get("level")
	resolved := r.URL.Query().Get("resolved")
	limitStr := r.URL.Query().Get("limit")
	offsetStr := r.URL.Query().Get("offset")

	limit := 50 // Default limit
	if limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 && l <= 1000 {
			limit = l
		}
	}

	offset := 0 // Default offset
	if offsetStr != "" {
		if o, err := strconv.Atoi(offsetStr); err == nil && o >= 0 {
			offset = o
		}
	}

	// Get alert history
	alerts := api.monitor.GetAlertHistory()

	// Apply filters
	var filteredAlerts []AlertEvent
	for _, alert := range alerts {
		// Filter by level
		if level != "" && alert.Level != level {
			continue
		}

		// Filter by resolved status
		if resolved != "" {
			resolvedBool := resolved == "true"
			if alert.Resolved != resolvedBool {
				continue
			}
		}

		filteredAlerts = append(filteredAlerts, alert)
	}

	// Apply pagination
	totalCount := len(filteredAlerts)
	var paginatedAlerts []AlertEvent

	if offset >= totalCount {
		paginatedAlerts = []AlertEvent{}
	} else {
		end := offset + limit
		if end > totalCount {
			end = totalCount
		}
		paginatedAlerts = filteredAlerts[offset:end]
	}

	response := AlertHistoryResponse{
		Success: true,
		Alerts:  paginatedAlerts,
		Count:   len(paginatedAlerts),
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(response)
}

// ResolveAlertHandler resolves an alert
func (api *ConcurrentUserMonitoringAPI) ResolveAlertHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Parse request body
	var req struct {
		AlertIndex int `json:"alert_index"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		response := map[string]interface{}{
			"success": false,
			"error":   "Invalid JSON in request body",
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(response)
		return
	}

	// Resolve alert
	success := api.monitor.alerts.ResolveAlert(req.AlertIndex)

	response := map[string]interface{}{
		"success": success,
		"message": "Alert resolved successfully",
	}

	if !success {
		response["message"] = "Failed to resolve alert"
		w.WriteHeader(http.StatusNotFound)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// GetSystemStatusHandler returns comprehensive system status
func (api *ConcurrentUserMonitoringAPI) GetSystemStatusHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Get current metrics
	metrics := api.monitor.GetMetrics()

	// Get optimization history
	optimizationHistory := api.monitor.GetOptimizationHistory()

	// Get alert history
	alertHistory := api.monitor.GetAlertHistory()

	// Calculate alert statistics
	criticalAlerts := 0
	warningAlerts := 0
	infoAlerts := 0
	unresolvedAlerts := 0

	for _, alert := range alertHistory {
		switch alert.Level {
		case "critical":
			criticalAlerts++
		case "warning":
			warningAlerts++
		case "info":
			infoAlerts++
		}

		if !alert.Resolved {
			unresolvedAlerts++
		}
	}

	// Calculate optimization statistics
	successfulOptimizations := 0
	failedOptimizations := 0

	for _, opt := range optimizationHistory {
		if opt.Success {
			successfulOptimizations++
		} else {
			failedOptimizations++
		}
	}

	// Determine overall system health
	systemHealth := "healthy"
	if metrics.PerformanceScore < 50 {
		systemHealth = "critical"
	} else if metrics.PerformanceScore < 80 {
		systemHealth = "warning"
	}

	// Determine system status
	systemStatus := "operational"
	if criticalAlerts > 0 {
		systemStatus = "degraded"
	}
	if metrics.BottleneckSeverity == "Critical" {
		systemStatus = "critical"
	}

	status := map[string]interface{}{
		"system_health":     systemHealth,
		"system_status":     systemStatus,
		"performance_score": metrics.PerformanceScore,
		"active_users":      metrics.ActiveUsers,
		"total_requests":    metrics.TotalRequests,
		"error_rate":        metrics.ErrorRate,
		"cpu_usage":         metrics.CPUUsage,
		"memory_usage":      metrics.MemoryUsage,
		"queue_size":        metrics.QueueSize,
		"bottleneck": map[string]interface{}{
			"type":     metrics.BottleneckType,
			"severity": metrics.BottleneckSeverity,
		},
		"alerts": map[string]interface{}{
			"total":      len(alertHistory),
			"critical":   criticalAlerts,
			"warning":    warningAlerts,
			"info":       infoAlerts,
			"unresolved": unresolvedAlerts,
			"resolved":   len(alertHistory) - unresolvedAlerts,
		},
		"optimizations": map[string]interface{}{
			"total":        len(optimizationHistory),
			"successful":   successfulOptimizations,
			"failed":       failedOptimizations,
			"success_rate": float64(successfulOptimizations) / float64(len(optimizationHistory)) * 100,
		},
		"thresholds": map[string]interface{}{
			"max_response_time":    api.monitor.config.PerformanceThresholds.MaxResponseTime.String(),
			"max_error_rate":       api.monitor.config.PerformanceThresholds.MaxErrorRate,
			"max_cpu_usage":        api.monitor.config.PerformanceThresholds.MaxCPUUsage,
			"max_memory_usage":     api.monitor.config.PerformanceThresholds.MaxMemoryUsage,
			"max_queue_size":       api.monitor.config.PerformanceThresholds.MaxQueueSize,
			"min_throughput":       api.monitor.config.PerformanceThresholds.MinThroughput,
			"max_concurrent_users": api.monitor.config.PerformanceThresholds.MaxConcurrentUsers,
		},
		"configuration": map[string]interface{}{
			"monitoring_interval":      api.monitor.config.MonitoringInterval.String(),
			"optimization_interval":    api.monitor.config.OptimizationInterval.String(),
			"alert_check_interval":     api.monitor.config.AlertCheckInterval.String(),
			"enable_real_time_metrics": api.monitor.config.EnableRealTimeMetrics,
			"enable_auto_optimization": api.monitor.config.EnableAutoOptimization,
			"enable_alerting":          api.monitor.config.EnableAlerting,
		},
		"timestamp": time.Now().UTC().Format(time.RFC3339),
	}

	response := SystemStatusResponse{
		Success: true,
		Status:  status,
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(response)
}

// GetPerformanceReportHandler returns detailed performance report
func (api *ConcurrentUserMonitoringAPI) GetPerformanceReportHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Get query parameters
	reportType := r.URL.Query().Get("type")
	if reportType == "" {
		reportType = "summary" // Default report type
	}

	metrics := api.monitor.GetMetrics()
	optimizationHistory := api.monitor.GetOptimizationHistory()
	alertHistory := api.monitor.GetAlertHistory()

	var report map[string]interface{}

	switch reportType {
	case "detailed":
		report = api.generateDetailedReport(metrics, optimizationHistory, alertHistory)
	case "performance":
		report = api.generatePerformanceReport(metrics)
	case "alerts":
		report = api.generateAlertsReport(alertHistory)
	case "optimizations":
		report = api.generateOptimizationsReport(optimizationHistory)
	default:
		report = api.generateSummaryReport(metrics, optimizationHistory, alertHistory)
	}

	response := map[string]interface{}{
		"success":   true,
		"report":    report,
		"type":      reportType,
		"timestamp": time.Now().UTC().Format(time.RFC3339),
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(response)
}

// generateSummaryReport generates a summary performance report
func (api *ConcurrentUserMonitoringAPI) generateSummaryReport(metrics *ConcurrentUserMetrics, optimizationHistory []OptimizationEvent, alertHistory []AlertEvent) map[string]interface{} {
	return map[string]interface{}{
		"performance_summary": map[string]interface{}{
			"score":         metrics.PerformanceScore,
			"active_users":  metrics.ActiveUsers,
			"throughput":    metrics.RequestsPerSecond,
			"error_rate":    metrics.ErrorRate,
			"response_time": metrics.AverageResponseTime.String(),
			"bottleneck":    metrics.BottleneckType,
			"severity":      metrics.BottleneckSeverity,
		},
		"system_health": map[string]interface{}{
			"cpu_usage":    metrics.CPUUsage,
			"memory_usage": metrics.MemoryUsage,
			"queue_size":   metrics.QueueSize,
		},
		"alerts_summary": map[string]interface{}{
			"total":      len(alertHistory),
			"unresolved": len(alertHistory) - countResolvedAlerts(alertHistory),
		},
		"optimizations_summary": map[string]interface{}{
			"total":      len(optimizationHistory),
			"successful": countSuccessfulOptimizations(optimizationHistory),
		},
	}
}

// generateDetailedReport generates a detailed performance report
func (api *ConcurrentUserMonitoringAPI) generateDetailedReport(metrics *ConcurrentUserMetrics, optimizationHistory []OptimizationEvent, alertHistory []AlertEvent) map[string]interface{} {
	return map[string]interface{}{
		"metrics": map[string]interface{}{
			"timestamp":             metrics.Timestamp.Format(time.RFC3339),
			"active_users":          metrics.ActiveUsers,
			"total_requests":        metrics.TotalRequests,
			"successful_requests":   metrics.SuccessfulRequests,
			"failed_requests":       metrics.FailedRequests,
			"average_response_time": metrics.AverageResponseTime.String(),
			"p95_response_time":     metrics.P95ResponseTime.String(),
			"p99_response_time":     metrics.P99ResponseTime.String(),
			"requests_per_second":   metrics.RequestsPerSecond,
			"error_rate":            metrics.ErrorRate,
			"cpu_usage":             metrics.CPUUsage,
			"memory_usage":          metrics.MemoryUsage,
			"queue_size":            metrics.QueueSize,
			"active_sessions":       metrics.ActiveSessions,
			"user_activity_score":   metrics.UserActivityScore,
			"performance_score":     metrics.PerformanceScore,
			"bottleneck_type":       metrics.BottleneckType,
			"bottleneck_severity":   metrics.BottleneckSeverity,
		},
		"optimization_history": optimizationHistory,
		"alert_history":        alertHistory,
	}
}

// generatePerformanceReport generates a performance-focused report
func (api *ConcurrentUserMonitoringAPI) generatePerformanceReport(metrics *ConcurrentUserMetrics) map[string]interface{} {
	return map[string]interface{}{
		"performance_metrics": map[string]interface{}{
			"score":      metrics.PerformanceScore,
			"throughput": metrics.RequestsPerSecond,
			"response_times": map[string]interface{}{
				"average": metrics.AverageResponseTime.String(),
				"p95":     metrics.P95ResponseTime.String(),
				"p99":     metrics.P99ResponseTime.String(),
			},
			"error_rate": metrics.ErrorRate,
			"bottleneck": map[string]interface{}{
				"type":     metrics.BottleneckType,
				"severity": metrics.BottleneckSeverity,
			},
		},
		"resource_utilization": map[string]interface{}{
			"cpu_usage":    metrics.CPUUsage,
			"memory_usage": metrics.MemoryUsage,
			"queue_size":   metrics.QueueSize,
		},
		"user_activity": map[string]interface{}{
			"active_users":        metrics.ActiveUsers,
			"active_sessions":     metrics.ActiveSessions,
			"user_activity_score": metrics.UserActivityScore,
		},
	}
}

// generateAlertsReport generates an alerts-focused report
func (api *ConcurrentUserMonitoringAPI) generateAlertsReport(alertHistory []AlertEvent) map[string]interface{} {
	alertsByLevel := make(map[string][]AlertEvent)
	alertsByType := make(map[string][]AlertEvent)

	for _, alert := range alertHistory {
		alertsByLevel[alert.Level] = append(alertsByLevel[alert.Level], alert)
		alertsByType[alert.Type] = append(alertsByType[alert.Type], alert)
	}

	return map[string]interface{}{
		"alerts_summary": map[string]interface{}{
			"total":      len(alertHistory),
			"resolved":   countResolvedAlerts(alertHistory),
			"unresolved": len(alertHistory) - countResolvedAlerts(alertHistory),
		},
		"alerts_by_level": alertsByLevel,
		"alerts_by_type":  alertsByType,
		"recent_alerts":   getRecentAlerts(alertHistory, 10),
	}
}

// generateOptimizationsReport generates an optimizations-focused report
func (api *ConcurrentUserMonitoringAPI) generateOptimizationsReport(optimizationHistory []OptimizationEvent) map[string]interface{} {
	optimizationsByType := make(map[string][]OptimizationEvent)
	optimizationsByImpact := make(map[string][]OptimizationEvent)

	for _, opt := range optimizationHistory {
		optimizationsByType[opt.Type] = append(optimizationsByType[opt.Type], opt)
		optimizationsByImpact[opt.Impact] = append(optimizationsByImpact[opt.Impact], opt)
	}

	return map[string]interface{}{
		"optimizations_summary": map[string]interface{}{
			"total":        len(optimizationHistory),
			"successful":   countSuccessfulOptimizations(optimizationHistory),
			"failed":       len(optimizationHistory) - countSuccessfulOptimizations(optimizationHistory),
			"success_rate": float64(countSuccessfulOptimizations(optimizationHistory)) / float64(len(optimizationHistory)) * 100,
		},
		"optimizations_by_type":   optimizationsByType,
		"optimizations_by_impact": optimizationsByImpact,
		"recent_optimizations":    getRecentOptimizations(optimizationHistory, 10),
	}
}

// Helper functions for report generation
func countResolvedAlerts(alerts []AlertEvent) int {
	count := 0
	for _, alert := range alerts {
		if alert.Resolved {
			count++
		}
	}
	return count
}

func countSuccessfulOptimizations(optimizations []OptimizationEvent) int {
	count := 0
	for _, opt := range optimizations {
		if opt.Success {
			count++
		}
	}
	return count
}

func getRecentAlerts(alerts []AlertEvent, limit int) []AlertEvent {
	if len(alerts) <= limit {
		return alerts
	}
	return alerts[len(alerts)-limit:]
}

func getRecentOptimizations(optimizations []OptimizationEvent, limit int) []OptimizationEvent {
	if len(optimizations) <= limit {
		return optimizations
	}
	return optimizations[len(optimizations)-limit:]
}

// RegisterConcurrentUserMonitoringRoutes registers all monitoring routes
func (api *ConcurrentUserMonitoringAPI) RegisterConcurrentUserMonitoringRoutes(mux *http.ServeMux) {
	mux.HandleFunc("GET /v1/monitoring/metrics", api.GetMonitoringMetricsHandler)
	mux.HandleFunc("GET /v1/monitoring/optimizations", api.GetOptimizationHistoryHandler)
	mux.HandleFunc("GET /v1/monitoring/alerts", api.GetAlertHistoryHandler)
	mux.HandleFunc("POST /v1/monitoring/alerts/resolve", api.ResolveAlertHandler)
	mux.HandleFunc("GET /v1/monitoring/status", api.GetSystemStatusHandler)
	mux.HandleFunc("GET /v1/monitoring/report", api.GetPerformanceReportHandler)
}
