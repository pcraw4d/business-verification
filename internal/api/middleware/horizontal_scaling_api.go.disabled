package middleware

import (
	"encoding/json"
	"net/http"
	"time"
)

// HorizontalScalingAPI provides RESTful API endpoints for horizontal scaling and load distribution
type HorizontalScalingAPI struct {
	manager *HorizontalScalingManager
}

// NewHorizontalScalingAPI creates a new API handler
func NewHorizontalScalingAPI(manager *HorizontalScalingManager) *HorizontalScalingAPI {
	return &HorizontalScalingAPI{
		manager: manager,
	}
}

// RegisterHorizontalScalingRoutes registers all API routes
func (api *HorizontalScalingAPI) RegisterHorizontalScalingRoutes(mux *http.ServeMux) {
	// Load balancer endpoints
	mux.HandleFunc("GET /v1/loadbalancer/instances", api.GetInstancesHandler)
	mux.HandleFunc("POST /v1/loadbalancer/instances", api.AddInstanceHandler)
	mux.HandleFunc("DELETE /v1/loadbalancer/instances/{id}", api.RemoveInstanceHandler)
	mux.HandleFunc("GET /v1/loadbalancer/stats", api.GetLoadBalancerStatsHandler)
	mux.HandleFunc("PUT /v1/loadbalancer/strategy", api.UpdateLoadBalancingStrategyHandler)

	// Service discovery endpoints
	mux.HandleFunc("GET /v1/discovery/services", api.GetDiscoveredServicesHandler)
	mux.HandleFunc("POST /v1/discovery/register", api.RegisterServiceHandler)
	mux.HandleFunc("DELETE /v1/discovery/deregister/{id}", api.DeregisterServiceHandler)
	mux.HandleFunc("GET /v1/discovery/health", api.GetServiceDiscoveryHealthHandler)

	// Health check endpoints
	mux.HandleFunc("GET /v1/health/instances", api.GetHealthCheckResultsHandler)
	mux.HandleFunc("POST /v1/health/check/{id}", api.PerformHealthCheckHandler)
	mux.HandleFunc("GET /v1/health/config", api.GetHealthCheckConfigHandler)
	mux.HandleFunc("PUT /v1/health/config", api.UpdateHealthCheckConfigHandler)

	// Auto-scaling endpoints
	mux.HandleFunc("GET /v1/scaling/status", api.GetScalingStatusHandler)
	mux.HandleFunc("POST /v1/scaling/scale-up", api.ScaleUpHandler)
	mux.HandleFunc("POST /v1/scaling/scale-down", api.ScaleDownHandler)
	mux.HandleFunc("GET /v1/scaling/metrics", api.GetScalingMetricsHandler)
	mux.HandleFunc("GET /v1/scaling/history", api.GetScalingHistoryHandler)
	mux.HandleFunc("PUT /v1/scaling/config", api.UpdateScalingConfigHandler)

	// Configuration endpoints
	mux.HandleFunc("GET /v1/config", api.GetConfigHandler)
	mux.HandleFunc("PUT /v1/config", api.UpdateConfigHandler)
	mux.HandleFunc("GET /v1/status", api.GetStatusHandler)
}

// GetInstancesHandler returns all load balancer instances
func (api *HorizontalScalingAPI) GetInstancesHandler(w http.ResponseWriter, r *http.Request) {
	if api.manager.loadBalancer == nil {
		http.Error(w, "Load balancer not enabled", http.StatusServiceUnavailable)
		return
	}

	api.manager.loadBalancer.mu.RLock()
	instances := make([]*ServiceInstance, len(api.manager.loadBalancer.instances))
	copy(instances, api.manager.loadBalancer.instances)
	api.manager.loadBalancer.mu.RUnlock()

	response := map[string]interface{}{
		"instances": instances,
		"count":     len(instances),
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// AddInstanceHandler adds a new instance to the load balancer
func (api *HorizontalScalingAPI) AddInstanceHandler(w http.ResponseWriter, r *http.Request) {
	if api.manager.loadBalancer == nil {
		http.Error(w, "Load balancer not enabled", http.StatusServiceUnavailable)
		return
	}

	var request struct {
		URL      string            `json:"url"`
		Weight   int               `json:"weight"`
		Metadata map[string]string `json:"metadata"`
	}

	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	instance := &ServiceInstance{
		ID:           generateInstanceID(),
		URL:          request.URL,
		Weight:       request.Weight,
		HealthStatus: HealthStatusUnknown,
		Metadata:     request.Metadata,
	}

	api.manager.loadBalancer.AddInstance(instance)

	response := map[string]interface{}{
		"instance":  instance,
		"message":   "Instance added successfully",
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(response)
}

// RemoveInstanceHandler removes an instance from the load balancer
func (api *HorizontalScalingAPI) RemoveInstanceHandler(w http.ResponseWriter, r *http.Request) {
	if api.manager.loadBalancer == nil {
		http.Error(w, "Load balancer not enabled", http.StatusServiceUnavailable)
		return
	}

	instanceID := r.PathValue("id")
	if instanceID == "" {
		http.Error(w, "Instance ID required", http.StatusBadRequest)
		return
	}

	api.manager.loadBalancer.RemoveInstance(instanceID)

	response := map[string]interface{}{
		"message":   "Instance removed successfully",
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// GetLoadBalancerStatsHandler returns load balancer statistics
func (api *HorizontalScalingAPI) GetLoadBalancerStatsHandler(w http.ResponseWriter, r *http.Request) {
	if api.manager.loadBalancer == nil {
		http.Error(w, "Load balancer not enabled", http.StatusServiceUnavailable)
		return
	}

	stats := api.manager.loadBalancer.GetStats()

	response := map[string]interface{}{
		"stats":     stats,
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// UpdateLoadBalancingStrategyHandler updates the load balancing strategy
func (api *HorizontalScalingAPI) UpdateLoadBalancingStrategyHandler(w http.ResponseWriter, r *http.Request) {
	if api.manager.loadBalancer == nil {
		http.Error(w, "Load balancer not enabled", http.StatusServiceUnavailable)
		return
	}

	var request struct {
		Strategy string `json:"strategy"`
	}

	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Update strategy
	switch request.Strategy {
	case "round-robin":
		api.manager.loadBalancer.strategy = &RoundRobinStrategy{}
	case "weighted":
		api.manager.loadBalancer.strategy = &WeightedStrategy{}
	case "least-connections":
		api.manager.loadBalancer.strategy = &LeastConnectionsStrategy{}
	case "ip-hash":
		api.manager.loadBalancer.strategy = &IPHashStrategy{}
	case "random":
		api.manager.loadBalancer.strategy = &RandomStrategy{}
	default:
		http.Error(w, "Invalid strategy", http.StatusBadRequest)
		return
	}

	api.manager.loadBalancer.config.Strategy = request.Strategy

	response := map[string]interface{}{
		"message":   "Strategy updated successfully",
		"strategy":  request.Strategy,
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// GetDiscoveredServicesHandler returns discovered services
func (api *HorizontalScalingAPI) GetDiscoveredServicesHandler(w http.ResponseWriter, r *http.Request) {
	if api.manager.serviceDiscovery == nil {
		http.Error(w, "Service discovery not enabled", http.StatusServiceUnavailable)
		return
	}

	api.manager.serviceDiscovery.mu.RLock()
	instances := make([]*ServiceInstance, 0, len(api.manager.serviceDiscovery.instances))
	for _, instance := range api.manager.serviceDiscovery.instances {
		instances = append(instances, instance)
	}
	api.manager.serviceDiscovery.mu.RUnlock()

	response := map[string]interface{}{
		"services":  instances,
		"count":     len(instances),
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// RegisterServiceHandler registers a service
func (api *HorizontalScalingAPI) RegisterServiceHandler(w http.ResponseWriter, r *http.Request) {
	if api.manager.serviceDiscovery == nil {
		http.Error(w, "Service discovery not enabled", http.StatusServiceUnavailable)
		return
	}

	var request struct {
		ServiceName string            `json:"service_name"`
		URL         string            `json:"url"`
		Port        int               `json:"port"`
		Tags        []string          `json:"tags"`
		Metadata    map[string]string `json:"metadata"`
	}

	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	instance := &ServiceInstance{
		ID:           generateInstanceID(),
		URL:          request.URL,
		Weight:       1,
		HealthStatus: HealthStatusHealthy,
		Metadata:     request.Metadata,
	}

	if err := api.manager.serviceDiscovery.registry.Register(r.Context(), instance); err != nil {
		http.Error(w, "Failed to register service", http.StatusInternalServerError)
		return
	}

	response := map[string]interface{}{
		"instance":  instance,
		"message":   "Service registered successfully",
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(response)
}

// DeregisterServiceHandler deregisters a service
func (api *HorizontalScalingAPI) DeregisterServiceHandler(w http.ResponseWriter, r *http.Request) {
	if api.manager.serviceDiscovery == nil {
		http.Error(w, "Service discovery not enabled", http.StatusServiceUnavailable)
		return
	}

	instanceID := r.PathValue("id")
	if instanceID == "" {
		http.Error(w, "Instance ID required", http.StatusBadRequest)
		return
	}

	if err := api.manager.serviceDiscovery.registry.Deregister(r.Context(), instanceID); err != nil {
		http.Error(w, "Failed to deregister service", http.StatusInternalServerError)
		return
	}

	response := map[string]interface{}{
		"message":   "Service deregistered successfully",
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// GetServiceDiscoveryHealthHandler returns service discovery health
func (api *HorizontalScalingAPI) GetServiceDiscoveryHealthHandler(w http.ResponseWriter, r *http.Request) {
	if api.manager.serviceDiscovery == nil {
		http.Error(w, "Service discovery not enabled", http.StatusServiceUnavailable)
		return
	}

	response := map[string]interface{}{
		"status":    "healthy",
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// GetHealthCheckResultsHandler returns health check results
func (api *HorizontalScalingAPI) GetHealthCheckResultsHandler(w http.ResponseWriter, r *http.Request) {
	if api.manager.healthChecker == nil {
		http.Error(w, "Health checker not enabled", http.StatusServiceUnavailable)
		return
	}

	api.manager.healthChecker.mu.RLock()
	results := make([]*HealthCheckResult, 0, len(api.manager.healthChecker.instances))
	for _, result := range api.manager.healthChecker.instances {
		results = append(results, result)
	}
	api.manager.healthChecker.mu.RUnlock()

	response := map[string]interface{}{
		"results":   results,
		"count":     len(results),
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// PerformHealthCheckHandler performs a health check on a specific instance
func (api *HorizontalScalingAPI) PerformHealthCheckHandler(w http.ResponseWriter, r *http.Request) {
	if api.manager.healthChecker == nil {
		http.Error(w, "Health checker not enabled", http.StatusServiceUnavailable)
		return
	}

	instanceID := r.PathValue("id")
	if instanceID == "" {
		http.Error(w, "Instance ID required", http.StatusBadRequest)
		return
	}

	// Perform health check (simplified)
	result := &HealthCheckResult{
		InstanceID:          instanceID,
		Status:              HealthStatusHealthy,
		LastCheck:           time.Now(),
		ConsecutiveFailures: 0,
		ResponseTime:        100 * time.Millisecond,
	}

	response := map[string]interface{}{
		"result":    result,
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// GetHealthCheckConfigHandler returns health check configuration
func (api *HorizontalScalingAPI) GetHealthCheckConfigHandler(w http.ResponseWriter, r *http.Request) {
	if api.manager.healthChecker == nil {
		http.Error(w, "Health checker not enabled", http.StatusServiceUnavailable)
		return
	}

	response := map[string]interface{}{
		"config":    api.manager.healthChecker.config,
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// UpdateHealthCheckConfigHandler updates health check configuration
func (api *HorizontalScalingAPI) UpdateHealthCheckConfigHandler(w http.ResponseWriter, r *http.Request) {
	if api.manager.healthChecker == nil {
		http.Error(w, "Health checker not enabled", http.StatusServiceUnavailable)
		return
	}

	var config HealthCheckConfig
	if err := json.NewDecoder(r.Body).Decode(&config); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	api.manager.healthChecker.config = &config

	response := map[string]interface{}{
		"message":   "Health check configuration updated",
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// GetScalingStatusHandler returns auto-scaling status
func (api *HorizontalScalingAPI) GetScalingStatusHandler(w http.ResponseWriter, r *http.Request) {
	if api.manager.autoScaler == nil {
		http.Error(w, "Auto-scaler not enabled", http.StatusServiceUnavailable)
		return
	}

	response := map[string]interface{}{
		"status":    "active",
		"enabled":   api.manager.config.AutoScalingEnabled,
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// ScaleUpHandler manually triggers scale up
func (api *HorizontalScalingAPI) ScaleUpHandler(w http.ResponseWriter, r *http.Request) {
	if api.manager.autoScaler == nil {
		http.Error(w, "Auto-scaler not enabled", http.StatusServiceUnavailable)
		return
	}

	var request struct {
		Count int `json:"count"`
	}

	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		request.Count = 1 // Default to 1
	}

	if request.Count <= 0 {
		request.Count = 1
	}

	if err := api.manager.scaleUp(request.Count); err != nil {
		http.Error(w, "Failed to scale up", http.StatusInternalServerError)
		return
	}

	response := map[string]interface{}{
		"message":   "Scale up initiated",
		"count":     request.Count,
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// ScaleDownHandler manually triggers scale down
func (api *HorizontalScalingAPI) ScaleDownHandler(w http.ResponseWriter, r *http.Request) {
	if api.manager.autoScaler == nil {
		http.Error(w, "Auto-scaler not enabled", http.StatusServiceUnavailable)
		return
	}

	var request struct {
		Count int `json:"count"`
	}

	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		request.Count = 1 // Default to 1
	}

	if request.Count <= 0 {
		request.Count = 1
	}

	if err := api.manager.scaleDown(request.Count); err != nil {
		http.Error(w, "Failed to scale down", http.StatusInternalServerError)
		return
	}

	response := map[string]interface{}{
		"message":   "Scale down initiated",
		"count":     request.Count,
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// GetScalingMetricsHandler returns scaling metrics
func (api *HorizontalScalingAPI) GetScalingMetricsHandler(w http.ResponseWriter, r *http.Request) {
	if api.manager.autoScaler == nil {
		http.Error(w, "Auto-scaler not enabled", http.StatusServiceUnavailable)
		return
	}

	api.manager.autoScaler.mu.RLock()
	metrics := make([]*ScalingMetrics, 0, len(api.manager.autoScaler.instances))
	for _, metric := range api.manager.autoScaler.instances {
		metrics = append(metrics, metric)
	}
	api.manager.autoScaler.mu.RUnlock()

	response := map[string]interface{}{
		"metrics":   metrics,
		"count":     len(metrics),
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// GetScalingHistoryHandler returns scaling history
func (api *HorizontalScalingAPI) GetScalingHistoryHandler(w http.ResponseWriter, r *http.Request) {
	// This would return actual scaling history
	// For now, return mock data
	history := []map[string]interface{}{
		{
			"type":      "scale_up",
			"reason":    "High CPU usage",
			"instances": 1,
			"timestamp": time.Now().Add(-5 * time.Minute),
		},
		{
			"type":      "scale_down",
			"reason":    "Low resource usage",
			"instances": 1,
			"timestamp": time.Now().Add(-10 * time.Minute),
		},
	}

	response := map[string]interface{}{
		"history":   history,
		"count":     len(history),
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// UpdateScalingConfigHandler updates auto-scaling configuration
func (api *HorizontalScalingAPI) UpdateScalingConfigHandler(w http.ResponseWriter, r *http.Request) {
	if api.manager.autoScaler == nil {
		http.Error(w, "Auto-scaler not enabled", http.StatusServiceUnavailable)
		return
	}

	var config AutoScalingConfig
	if err := json.NewDecoder(r.Body).Decode(&config); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	api.manager.autoScaler.config = &config

	response := map[string]interface{}{
		"message":   "Auto-scaling configuration updated",
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// GetConfigHandler returns the current configuration
func (api *HorizontalScalingAPI) GetConfigHandler(w http.ResponseWriter, r *http.Request) {
	response := map[string]interface{}{
		"config":    api.manager.config,
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// UpdateConfigHandler updates the configuration
func (api *HorizontalScalingAPI) UpdateConfigHandler(w http.ResponseWriter, r *http.Request) {
	var config HorizontalScalingConfig
	if err := json.NewDecoder(r.Body).Decode(&config); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	api.manager.config = &config

	response := map[string]interface{}{
		"message":   "Configuration updated",
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// GetStatusHandler returns the overall status
func (api *HorizontalScalingAPI) GetStatusHandler(w http.ResponseWriter, r *http.Request) {
	status := map[string]interface{}{
		"load_balancer":     api.manager.loadBalancer != nil,
		"service_discovery": api.manager.serviceDiscovery != nil,
		"health_checker":    api.manager.healthChecker != nil,
		"auto_scaler":       api.manager.autoScaler != nil,
		"timestamp":         time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(status)
}
