package middleware

import (
	"context"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"
)

func TestDefaultSessionConfig(t *testing.T) {
	config := DefaultSessionConfig()

	if config.SessionTimeout != 24*time.Hour {
		t.Errorf("Expected 24 hour session timeout, got %v", config.SessionTimeout)
	}

	if config.CleanupInterval != 1*time.Hour {
		t.Errorf("Expected 1 hour cleanup interval, got %v", config.CleanupInterval)
	}

	if config.MaxSessions != 1000 {
		t.Errorf("Expected 1000 max sessions, got %d", config.MaxSessions)
	}

	if config.CookieName != "kyb_session_id" {
		t.Errorf("Expected cookie name 'kyb_session_id', got %s", config.CookieName)
	}
}

func TestNewSessionManager(t *testing.T) {
	sm := NewSessionManager(nil)
	defer sm.Shutdown()

	if sm.config == nil {
		t.Error("Expected config to be set")
	}

	if sm.sessions == nil {
		t.Error("Expected sessions map to be initialized")
	}

	if sm.metrics == nil {
		t.Error("Expected metrics to be initialized")
	}
}

func TestSessionManager_CreateSession(t *testing.T) {
	sm := NewSessionManager(nil)
	defer sm.Shutdown()

	// Create a test request
	req := httptest.NewRequest("GET", "/test", nil)
	req.RemoteAddr = "192.168.1.1:8080"
	req.Header.Set("User-Agent", "Test Agent")

	// Create session
	session, err := sm.CreateSession(req, "user123")
	if err != nil {
		t.Fatalf("Failed to create session: %v", err)
	}

	// Verify session properties
	if session.ID == "" {
		t.Error("Expected session ID to be set")
	}

	if session.UserID != "user123" {
		t.Errorf("Expected user ID 'user123', got %s", session.UserID)
	}

	if session.IPAddress == "" {
		t.Error("Expected IP address to be set")
	}

	if session.UserAgent != "Test Agent" {
		t.Errorf("Expected user agent 'Test Agent', got %s", session.UserAgent)
	}

	if !session.IsActive {
		t.Error("Expected session to be active")
	}

	if session.ExpiresAt.Before(time.Now()) {
		t.Error("Expected session to not be expired")
	}
}

func TestSessionManager_GetSession(t *testing.T) {
	sm := NewSessionManager(nil)
	defer sm.Shutdown()

	req := httptest.NewRequest("GET", "/test", nil)

	// Create session
	session, err := sm.CreateSession(req, "user123")
	if err != nil {
		t.Fatalf("Failed to create session: %v", err)
	}

	// Retrieve session
	retrievedSession, exists := sm.GetSession(session.ID)
	if !exists {
		t.Error("Expected session to exist")
	}

	if retrievedSession.ID != session.ID {
		t.Errorf("Expected session ID %s, got %s", session.ID, retrievedSession.ID)
	}

	// Try to get non-existent session
	_, exists = sm.GetSession("non-existent")
	if exists {
		t.Error("Expected non-existent session to not exist")
	}
}

func TestSessionManager_UpdateSessionActivity(t *testing.T) {
	sm := NewSessionManager(nil)
	defer sm.Shutdown()

	req := httptest.NewRequest("GET", "/test", nil)

	// Create session
	session, err := sm.CreateSession(req, "user123")
	if err != nil {
		t.Fatalf("Failed to create session: %v", err)
	}

	initialRequestCount := session.RequestCount

	// Update activity
	activity := ActivityEntry{
		Timestamp:    time.Now(),
		Action:       "request",
		Endpoint:     "/api/test",
		Method:       "GET",
		StatusCode:   200,
		Duration:     100 * time.Millisecond,
		RequestSize:  1024,
		ResponseSize: 2048,
	}

	err = sm.UpdateSessionActivity(session.ID, activity)
	if err != nil {
		t.Fatalf("Failed to update session activity: %v", err)
	}

	// Verify session was updated
	updatedSession, exists := sm.GetSession(session.ID)
	if !exists {
		t.Error("Expected session to exist after update")
	}

	if updatedSession.RequestCount != initialRequestCount+1 {
		t.Errorf("Expected request count %d, got %d", initialRequestCount+1, updatedSession.RequestCount)
	}

	if len(updatedSession.ActivityLog) == 0 {
		t.Error("Expected activity log to contain entries")
	}
}

func TestSessionManager_DeleteSession(t *testing.T) {
	sm := NewSessionManager(nil)
	defer sm.Shutdown()

	req := httptest.NewRequest("GET", "/test", nil)

	// Create session
	session, err := sm.CreateSession(req, "user123")
	if err != nil {
		t.Fatalf("Failed to create session: %v", err)
	}

	// Delete session
	deleted := sm.DeleteSession(session.ID)
	if !deleted {
		t.Error("Expected session to be deleted")
	}

	// Verify session is gone
	_, exists := sm.GetSession(session.ID)
	if exists {
		t.Error("Expected session to not exist after deletion")
	}

	// Try to delete non-existent session
	deleted = sm.DeleteSession("non-existent")
	if deleted {
		t.Error("Expected non-existent session deletion to return false")
	}
}

func TestSessionManager_GetActiveSessions(t *testing.T) {
	sm := NewSessionManager(nil)
	defer sm.Shutdown()

	req := httptest.NewRequest("GET", "/test", nil)

	// Create multiple sessions
	session1, _ := sm.CreateSession(req, "user1")
	session2, _ := sm.CreateSession(req, "user2")
	session3, _ := sm.CreateSession(req, "user3")

	// Get active sessions
	activeSessions := sm.GetActiveSessions()
	if len(activeSessions) != 3 {
		t.Errorf("Expected 3 active sessions, got %d", len(activeSessions))
	}

	// Delete one session
	sm.DeleteSession(session2.ID)

	// Get active sessions again
	activeSessions = sm.GetActiveSessions()
	if len(activeSessions) != 2 {
		t.Errorf("Expected 2 active sessions after deletion, got %d", len(activeSessions))
	}

	// Verify correct sessions remain
	sessionIDs := make(map[string]bool)
	for _, session := range activeSessions {
		sessionIDs[session.ID] = true
	}

	if !sessionIDs[session1.ID] {
		t.Error("Expected session1 to be active")
	}
	if !sessionIDs[session3.ID] {
		t.Error("Expected session3 to be active")
	}
}

func TestSessionManager_GetSessionsByUser(t *testing.T) {
	sm := NewSessionManager(nil)
	defer sm.Shutdown()

	req := httptest.NewRequest("GET", "/test", nil)

	// Create sessions for different users
	sm.CreateSession(req, "user1")
	sm.CreateSession(req, "user1") // Second session for user1
	sm.CreateSession(req, "user2")

	// Get sessions for user1
	user1Sessions := sm.GetSessionsByUser("user1")
	if len(user1Sessions) != 2 {
		t.Errorf("Expected 2 sessions for user1, got %d", len(user1Sessions))
	}

	// Get sessions for user2
	user2Sessions := sm.GetSessionsByUser("user2")
	if len(user2Sessions) != 1 {
		t.Errorf("Expected 1 session for user2, got %d", len(user2Sessions))
	}

	// Get sessions for non-existent user
	user3Sessions := sm.GetSessionsByUser("user3")
	if len(user3Sessions) != 0 {
		t.Errorf("Expected 0 sessions for user3, got %d", len(user3Sessions))
	}
}

func TestSessionManager_GetMetrics(t *testing.T) {
	sm := NewSessionManager(nil)
	defer sm.Shutdown()

	req := httptest.NewRequest("GET", "/test", nil)

	// Initial metrics
	metrics := sm.GetMetrics()
	if metrics.ActiveSessions != 0 {
		t.Errorf("Expected 0 active sessions initially, got %d", metrics.ActiveSessions)
	}

	// Create sessions
	session1, _ := sm.CreateSession(req, "user1")
	session2, _ := sm.CreateSession(req, "user2")

	// Update activity to trigger metrics update
	activity := ActivityEntry{
		Timestamp:  time.Now(),
		Action:     "request",
		Endpoint:   "/test",
		Method:     "GET",
		StatusCode: 200,
	}
	sm.UpdateSessionActivity(session1.ID, activity)
	sm.UpdateSessionActivity(session2.ID, activity)

	// Get updated metrics
	metrics = sm.GetMetrics()
	if metrics.ActiveSessions != 2 {
		t.Errorf("Expected 2 active sessions, got %d", metrics.ActiveSessions)
	}

	if metrics.TotalRequests != 2 {
		t.Errorf("Expected 2 total requests, got %d", metrics.TotalRequests)
	}
}

func TestSessionManager_SessionTimeout(t *testing.T) {
	// Create session manager with short timeout for testing
	config := DefaultSessionConfig()
	config.SessionTimeout = 100 * time.Millisecond
	config.CleanupInterval = 50 * time.Millisecond

	sm := NewSessionManager(config)
	defer sm.Shutdown()

	req := httptest.NewRequest("GET", "/test", nil)

	// Create session
	session, err := sm.CreateSession(req, "user123")
	if err != nil {
		t.Fatalf("Failed to create session: %v", err)
	}

	// Session should exist immediately
	_, exists := sm.GetSession(session.ID)
	if !exists {
		t.Error("Expected session to exist immediately after creation")
	}

	// Wait for session to expire
	time.Sleep(200 * time.Millisecond)

	// Session should be expired and cleaned up
	_, exists = sm.GetSession(session.ID)
	if exists {
		t.Error("Expected session to be expired and cleaned up")
	}
}

func TestSessionManager_MaxSessions(t *testing.T) {
	// Create session manager with low session limit
	config := DefaultSessionConfig()
	config.MaxSessions = 2

	sm := NewSessionManager(config)
	defer sm.Shutdown()

	req := httptest.NewRequest("GET", "/test", nil)

	// Create sessions up to limit
	_, err := sm.CreateSession(req, "user1")
	if err != nil {
		t.Fatalf("Failed to create first session: %v", err)
	}

	_, err = sm.CreateSession(req, "user2")
	if err != nil {
		t.Fatalf("Failed to create second session: %v", err)
	}

	// Third session should fail
	_, err = sm.CreateSession(req, "user3")
	if err == nil {
		t.Error("Expected third session creation to fail due to limit")
	}
}

func TestSessionMiddleware(t *testing.T) {
	sm := NewSessionManager(nil)
	defer sm.Shutdown()

	// Create test handler
	testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Verify session is in context
		session, exists := GetSessionFromContext(r.Context())
		if !exists {
			t.Error("Expected session to be in context")
			return
		}

		if session.ID == "" {
			t.Error("Expected session ID to be set")
		}

		w.WriteHeader(http.StatusOK)
		w.Write([]byte("OK"))
	})

	// Wrap handler with session middleware
	handler := sm.SessionMiddleware()(testHandler)

	// Create test request
	req := httptest.NewRequest("GET", "/test", nil)
	w := httptest.NewRecorder()

	// Execute request
	handler.ServeHTTP(w, req)

	// Verify response
	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	// Verify session cookie was set
	cookies := w.Result().Cookies()
	sessionCookieFound := false
	for _, cookie := range cookies {
		if cookie.Name == sm.config.CookieName {
			sessionCookieFound = true
			break
		}
	}

	if !sessionCookieFound {
		t.Error("Expected session cookie to be set")
	}
}

func TestGetSessionFromContext(t *testing.T) {
	// Test with session in context
	session := &UserSession{
		ID:     "test-session",
		UserID: "test-user",
	}

	ctx := context.WithValue(context.Background(), "session", session)
	retrievedSession, exists := GetSessionFromContext(ctx)

	if !exists {
		t.Error("Expected session to exist in context")
	}

	if retrievedSession.ID != session.ID {
		t.Errorf("Expected session ID %s, got %s", session.ID, retrievedSession.ID)
	}

	// Test with no session in context
	emptyCtx := context.Background()
	_, exists = GetSessionFromContext(emptyCtx)

	if exists {
		t.Error("Expected no session in empty context")
	}
}

func TestSessionManager_getClientIP(t *testing.T) {
	sm := NewSessionManager(nil)
	defer sm.Shutdown()

	// Test with X-Forwarded-For header
	req1 := httptest.NewRequest("GET", "/test", nil)
	req1.Header.Set("X-Forwarded-For", "192.168.1.100")
	req1.RemoteAddr = "192.168.1.1:8080"

	ip1 := sm.getClientIP(req1)
	if ip1 != "192.168.1.100" {
		t.Errorf("Expected IP from X-Forwarded-For: 192.168.1.100, got %s", ip1)
	}

	// Test with X-Real-IP header
	req2 := httptest.NewRequest("GET", "/test", nil)
	req2.Header.Set("X-Real-IP", "192.168.1.200")
	req2.RemoteAddr = "192.168.1.1:8080"

	ip2 := sm.getClientIP(req2)
	if ip2 != "192.168.1.200" {
		t.Errorf("Expected IP from X-Real-IP: 192.168.1.200, got %s", ip2)
	}

	// Test with RemoteAddr fallback
	req3 := httptest.NewRequest("GET", "/test", nil)
	req3.RemoteAddr = "192.168.1.1:8080"

	ip3 := sm.getClientIP(req3)
	if ip3 != "192.168.1.1:8080" {
		t.Errorf("Expected IP from RemoteAddr: 192.168.1.1:8080, got %s", ip3)
	}
}

func TestResponseRecorder(t *testing.T) {
	w := httptest.NewRecorder()
	rr := &responseRecorder{
		ResponseWriter: w,
		statusCode:     http.StatusOK,
		responseSize:   0,
	}

	// Test WriteHeader
	rr.WriteHeader(http.StatusCreated)
	if rr.statusCode != http.StatusCreated {
		t.Errorf("Expected status code 201, got %d", rr.statusCode)
	}

	// Test Write
	data := []byte("test response")
	n, err := rr.Write(data)
	if err != nil {
		t.Fatalf("Failed to write response: %v", err)
	}

	if n != len(data) {
		t.Errorf("Expected to write %d bytes, wrote %d", len(data), n)
	}

	if rr.responseSize != int64(len(data)) {
		t.Errorf("Expected response size %d, got %d", len(data), rr.responseSize)
	}
}
