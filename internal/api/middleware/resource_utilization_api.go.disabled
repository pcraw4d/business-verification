package middleware

import (
	"encoding/json"
	"net/http"
	"strconv"
	"time"
)

// ResourceUtilizationAPI provides HTTP endpoints for resource monitoring
type ResourceUtilizationAPI struct {
	manager *ResourceUtilizationManager
}

// NewResourceUtilizationAPI creates a new resource utilization API
func NewResourceUtilizationAPI(manager *ResourceUtilizationManager) *ResourceUtilizationAPI {
	return &ResourceUtilizationAPI{
		manager: manager,
	}
}

// ResourceMetricsResponse represents resource metrics in API responses
type ResourceMetricsResponse struct {
	Success   bool             `json:"success"`
	Metrics   *ResourceMetrics `json:"metrics"`
	Error     string           `json:"error,omitempty"`
	Timestamp time.Time        `json:"timestamp"`
}

// OptimizationHistoryResponse represents optimization history in API responses
type OptimizationHistoryResponse struct {
	Success bool                `json:"success"`
	History []OptimizationEvent `json:"history"`
	Error   string              `json:"error,omitempty"`
	Count   int                 `json:"count"`
}

// ResourceAlertsResponse represents resource alerts in API responses
type ResourceAlertsResponse struct {
	Success    bool            `json:"success"`
	Alerts     []ResourceAlert `json:"alerts"`
	Error      string          `json:"error,omitempty"`
	Count      int             `json:"count"`
	ActiveOnly bool            `json:"active_only"`
}

// OptimizationRequest represents a request to run optimization
type OptimizationRequest struct {
	Force      bool     `json:"force"`
	Strategies []string `json:"strategies,omitempty"`
}

// OptimizationResponse represents optimization result
type OptimizationResponse struct {
	Success   bool      `json:"success"`
	Message   string    `json:"message"`
	Error     string    `json:"error,omitempty"`
	Timestamp time.Time `json:"timestamp"`
}

// ResourceHealthResponse represents overall resource health
type ResourceHealthResponse struct {
	Success   bool                   `json:"success"`
	Health    string                 `json:"health"` // healthy, warning, critical
	Score     float64                `json:"score"`  // 0-100
	Summary   *ResourceHealthSummary `json:"summary"`
	Error     string                 `json:"error,omitempty"`
	Timestamp time.Time              `json:"timestamp"`
}

// ResourceHealthSummary provides a summary of resource health
type ResourceHealthSummary struct {
	CPUStatus       string     `json:"cpu_status"`
	MemoryStatus    string     `json:"memory_status"`
	GoroutineStatus string     `json:"goroutine_status"`
	AlertCount      int        `json:"alert_count"`
	LastOptimized   *time.Time `json:"last_optimized,omitempty"`
}

// RegisterResourceUtilizationRoutes registers all resource utilization routes
func (api *ResourceUtilizationAPI) RegisterResourceUtilizationRoutes(mux *http.ServeMux) {
	mux.HandleFunc("GET /v1/resource/metrics", api.GetResourceMetricsHandler)
	mux.HandleFunc("GET /v1/resource/health", api.GetResourceHealthHandler)
	mux.HandleFunc("GET /v1/resource/alerts", api.GetResourceAlertsHandler)
	mux.HandleFunc("POST /v1/resource/alerts/{id}/resolve", api.ResolveAlertHandler)
	mux.HandleFunc("GET /v1/resource/optimization/history", api.GetOptimizationHistoryHandler)
	mux.HandleFunc("POST /v1/resource/optimization/run", api.RunOptimizationHandler)
	mux.HandleFunc("GET /v1/resource/status", api.GetResourceStatusHandler)
}

// GetResourceMetricsHandler returns current resource metrics
func (api *ResourceUtilizationAPI) GetResourceMetricsHandler(w http.ResponseWriter, r *http.Request) {
	metrics := api.manager.GetResourceMetrics()

	response := ResourceMetricsResponse{
		Success:   true,
		Metrics:   metrics,
		Timestamp: time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(response)
}

// GetResourceHealthHandler returns overall resource health status
func (api *ResourceUtilizationAPI) GetResourceHealthHandler(w http.ResponseWriter, r *http.Request) {
	metrics := api.manager.GetResourceMetrics()
	alerts := api.manager.GetResourceAlerts()

	// Calculate health score and status
	health, score := api.calculateHealthStatus(metrics, alerts)

	summary := &ResourceHealthSummary{
		CPUStatus:       api.getResourceStatus(metrics.CPUUsage, api.manager.config.AlertThresholds.CPUWarning, api.manager.config.AlertThresholds.CPUCritical),
		MemoryStatus:    api.getResourceStatus(metrics.MemoryUsage, api.manager.config.AlertThresholds.MemoryWarning, api.manager.config.AlertThresholds.MemoryCritical),
		GoroutineStatus: api.getGoroutineStatus(metrics.GoroutineCount),
		AlertCount:      len(alerts),
	}

	if !api.manager.optimizer.lastOptimization.IsZero() {
		summary.LastOptimized = &api.manager.optimizer.lastOptimization
	}

	response := ResourceHealthResponse{
		Success:   true,
		Health:    health,
		Score:     score,
		Summary:   summary,
		Timestamp: time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(response)
}

// GetResourceAlertsHandler returns resource alerts
func (api *ResourceUtilizationAPI) GetResourceAlertsHandler(w http.ResponseWriter, r *http.Request) {
	activeOnly := r.URL.Query().Get("active") == "true"

	var alerts []ResourceAlert
	if activeOnly {
		alerts = api.manager.alerts.GetActiveAlerts()
	} else {
		alerts = api.manager.GetResourceAlerts()
	}

	response := ResourceAlertsResponse{
		Success:    true,
		Alerts:     alerts,
		Count:      len(alerts),
		ActiveOnly: activeOnly,
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(response)
}

// ResolveAlertHandler resolves a specific alert
func (api *ResourceUtilizationAPI) ResolveAlertHandler(w http.ResponseWriter, r *http.Request) {
	alertID := r.PathValue("id")
	if alertID == "" {
		http.Error(w, "Alert ID is required", http.StatusBadRequest)
		return
	}

	api.manager.alerts.ResolveAlert(alertID)

	response := map[string]interface{}{
		"success":   true,
		"message":   "Alert resolved successfully",
		"alert_id":  alertID,
		"timestamp": time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(response)
}

// GetOptimizationHistoryHandler returns optimization history
func (api *ResourceUtilizationAPI) GetOptimizationHistoryHandler(w http.ResponseWriter, r *http.Request) {
	limitStr := r.URL.Query().Get("limit")
	limit := 50 // Default limit

	if limitStr != "" {
		if parsedLimit, err := strconv.Atoi(limitStr); err == nil && parsedLimit > 0 {
			limit = parsedLimit
		}
	}

	history := api.manager.GetOptimizationHistory()

	// Apply limit
	if len(history) > limit {
		history = history[len(history)-limit:]
	}

	response := OptimizationHistoryResponse{
		Success: true,
		History: history,
		Count:   len(history),
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(response)
}

// RunOptimizationHandler manually triggers resource optimization
func (api *ResourceUtilizationAPI) RunOptimizationHandler(w http.ResponseWriter, r *http.Request) {
	var req OptimizationRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		response := OptimizationResponse{
			Success:   false,
			Error:     "Invalid request body",
			Timestamp: time.Now(),
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(response)
		return
	}

	err := api.manager.OptimizeResources()
	if err != nil {
		response := OptimizationResponse{
			Success:   false,
			Error:     err.Error(),
			Timestamp: time.Now(),
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(response)
		return
	}

	response := OptimizationResponse{
		Success:   true,
		Message:   "Resource optimization completed successfully",
		Timestamp: time.Now(),
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(response)
}

// GetResourceStatusHandler returns comprehensive resource status
func (api *ResourceUtilizationAPI) GetResourceStatusHandler(w http.ResponseWriter, r *http.Request) {
	metrics := api.manager.GetResourceMetrics()
	alerts := api.manager.GetResourceAlerts()
	history := api.manager.GetOptimizationHistory()

	// Get recent optimization events (last 10)
	recentHistory := history
	if len(recentHistory) > 10 {
		recentHistory = recentHistory[len(recentHistory)-10:]
	}

	status := map[string]interface{}{
		"status":    "operational",
		"timestamp": time.Now(),
		"resource_utilization": map[string]interface{}{
			"cpu_usage":       metrics.CPUUsage,
			"memory_usage":    metrics.MemoryUsage,
			"goroutine_count": metrics.GoroutineCount,
			"heap_alloc":      metrics.HeapAlloc,
			"gc_cycles":       metrics.GCCycles,
			"cpu_cores":       metrics.CPUCores,
			"process_memory":  metrics.ProcessMemory,
			"last_gc_time":    metrics.LastGCTime,
		},
		"alerts": map[string]interface{}{
			"total_count":  len(alerts),
			"active_count": len(api.manager.alerts.GetActiveAlerts()),
			"recent_alerts": func() []ResourceAlert {
				if len(alerts) > 5 {
					return alerts[len(alerts)-5:]
				}
				return alerts
			}(),
		},
		"optimization": map[string]interface{}{
			"last_run":             api.manager.optimizer.lastOptimization,
			"total_runs":           len(history),
			"recent_optimizations": recentHistory,
		},
		"thresholds": map[string]interface{}{
			"cpu_warning":        api.manager.config.AlertThresholds.CPUWarning,
			"cpu_critical":       api.manager.config.AlertThresholds.CPUCritical,
			"memory_warning":     api.manager.config.AlertThresholds.MemoryWarning,
			"memory_critical":    api.manager.config.AlertThresholds.MemoryCritical,
			"goroutine_warning":  api.manager.config.AlertThresholds.GoroutineWarning,
			"goroutine_critical": api.manager.config.AlertThresholds.GoroutineCritical,
		},
		"features": map[string]interface{}{
			"resource_monitoring":   "active",
			"resource_optimization": "active",
			"alert_management":      "active",
			"memory_optimization":   "active",
			"cpu_optimization":      "active",
			"gc_optimization":       "active",
			"goroutine_monitoring":  "active",
		},
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(status)
}

// calculateHealthStatus calculates overall health status and score
func (api *ResourceUtilizationAPI) calculateHealthStatus(metrics *ResourceMetrics, alerts []ResourceAlert) (string, float64) {
	score := 100.0
	health := "healthy"

	// Deduct points for high resource usage
	if metrics.CPUUsage > api.manager.config.AlertThresholds.CPUCritical {
		score -= 30
		health = "critical"
	} else if metrics.CPUUsage > api.manager.config.AlertThresholds.CPUWarning {
		score -= 15
		if health == "healthy" {
			health = "warning"
		}
	}

	if metrics.MemoryUsage > api.manager.config.AlertThresholds.MemoryCritical {
		score -= 30
		health = "critical"
	} else if metrics.MemoryUsage > api.manager.config.AlertThresholds.MemoryWarning {
		score -= 15
		if health == "healthy" {
			health = "warning"
		}
	}

	if metrics.GoroutineCount > api.manager.config.AlertThresholds.GoroutineCritical {
		score -= 20
		health = "critical"
	} else if metrics.GoroutineCount > api.manager.config.AlertThresholds.GoroutineWarning {
		score -= 10
		if health == "healthy" {
			health = "warning"
		}
	}

	// Deduct points for active alerts
	activeAlerts := api.manager.alerts.GetActiveAlerts()
	for _, alert := range activeAlerts {
		if alert.Level == "Critical" {
			score -= 10
		} else {
			score -= 5
		}
	}

	if score < 0 {
		score = 0
	}

	if score < 50 && health != "critical" {
		health = "critical"
	} else if score < 80 && health == "healthy" {
		health = "warning"
	}

	return health, score
}

// getResourceStatus returns status string for a resource metric
func (api *ResourceUtilizationAPI) getResourceStatus(current, warning, critical float64) string {
	if current > critical {
		return "critical"
	} else if current > warning {
		return "warning"
	}
	return "healthy"
}

// getGoroutineStatus returns status string for goroutine count
func (api *ResourceUtilizationAPI) getGoroutineStatus(count int) string {
	if count > api.manager.config.AlertThresholds.GoroutineCritical {
		return "critical"
	} else if count > api.manager.config.AlertThresholds.GoroutineWarning {
		return "warning"
	}
	return "healthy"
}
