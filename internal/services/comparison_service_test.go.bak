package services

import (
	"context"
	"strings"
	"testing"
	"time"

	"github.com/pcraw4d/business-verification/internal/models"
)

// MockMerchantPortfolioService is a mock implementation for testing
type MockMerchantPortfolioService struct {
	merchants map[string]*models.Merchant
}

func NewMockMerchantPortfolioService() *MockMerchantPortfolioService {
	return &MockMerchantPortfolioService{
		merchants: make(map[string]*models.Merchant),
	}
}

func (m *MockMerchantPortfolioService) GetMerchant(ctx context.Context, merchantID string) (*models.Merchant, error) {
	merchant, exists := m.merchants[merchantID]
	if !exists {
		return nil, ErrMerchantNotFound
	}
	return merchant, nil
}

func (m *MockMerchantPortfolioService) AddMerchant(merchant *models.Merchant) {
	m.merchants[merchant.ID] = merchant
}

func TestComparisonService_CompareMerchants(t *testing.T) {
	// Setup mock service
	mockPortfolioService := NewMockMerchantPortfolioService()
	comparisonService := NewComparisonService(mockPortfolioService, nil)

	// Create test merchants
	merchant1 := &models.Merchant{
		ID:               "merchant1",
		Name:             "Test Company 1",
		Industry:         "Technology",
		BusinessType:     "Corporation",
		EmployeeCount:    100,
		PortfolioType:    models.PortfolioTypeOnboarded,
		RiskLevel:        models.RiskLevelLow,
		ComplianceStatus: "compliant",
		CreatedAt:        time.Now(),
		UpdatedAt:        time.Now(),
	}

	merchant2 := &models.Merchant{
		ID:               "merchant2",
		Name:             "Test Company 2",
		Industry:         "Finance",
		BusinessType:     "LLC",
		EmployeeCount:    50,
		PortfolioType:    models.PortfolioTypeProspective,
		RiskLevel:        models.RiskLevelHigh,
		ComplianceStatus: "pending",
		CreatedAt:        time.Now(),
		UpdatedAt:        time.Now(),
	}

	// Add merchants to mock service
	mockPortfolioService.AddMerchant(merchant1)
	mockPortfolioService.AddMerchant(merchant2)

	tests := []struct {
		name           string
		request        *ComparisonRequest
		expectedError  string
		expectedResult func(*ComparisonResult) bool
	}{
		{
			name: "successful comparison",
			request: &ComparisonRequest{
				Merchant1ID: "merchant1",
				Merchant2ID: "merchant2",
				UserID:      "user1",
			},
			expectedError: "",
			expectedResult: func(result *ComparisonResult) bool {
				return result != nil &&
					result.Merchant1.ID == "merchant1" &&
					result.Merchant2.ID == "merchant2" &&
					len(result.Differences) > 0 &&
					len(result.Recommendations) > 0 &&
					result.Summary.TotalDifferences > 0
			},
		},
		{
			name: "invalid request - missing merchant1 ID",
			request: &ComparisonRequest{
				Merchant1ID: "",
				Merchant2ID: "merchant2",
				UserID:      "user1",
			},
			expectedError: "both merchant IDs are required",
		},
		{
			name: "invalid request - missing merchant2 ID",
			request: &ComparisonRequest{
				Merchant1ID: "merchant1",
				Merchant2ID: "",
				UserID:      "user1",
			},
			expectedError: "both merchant IDs are required",
		},
		{
			name: "invalid request - same merchant",
			request: &ComparisonRequest{
				Merchant1ID: "merchant1",
				Merchant2ID: "merchant1",
				UserID:      "user1",
			},
			expectedError: "cannot compare merchant with itself",
		},
		{
			name: "invalid request - missing user ID",
			request: &ComparisonRequest{
				Merchant1ID: "merchant1",
				Merchant2ID: "merchant2",
				UserID:      "",
			},
			expectedError: "user ID is required",
		},
		{
			name: "merchant not found",
			request: &ComparisonRequest{
				Merchant1ID: "nonexistent",
				Merchant2ID: "merchant2",
				UserID:      "user1",
			},
			expectedError: "merchant 1 not found",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := context.Background()
			result, err := comparisonService.CompareMerchants(ctx, tt.request)

			if tt.expectedError != "" {
				if err == nil {
					t.Errorf("Expected error '%s', but got none", tt.expectedError)
					return
				}
				if !strings.Contains(err.Error(), tt.expectedError) {
					t.Errorf("Expected error to contain '%s', but got '%s'", tt.expectedError, err.Error())
				}
				return
			}

			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			if tt.expectedResult != nil && !tt.expectedResult(result) {
				t.Errorf("Result validation failed")
			}
		})
	}
}

func TestComparisonService_FindDifferences(t *testing.T) {
	comparisonService := NewComparisonService(nil, nil)

	merchant1 := &models.Merchant{
		ID:               "merchant1",
		Name:             "Test Company 1",
		Industry:         "Technology",
		BusinessType:     "Corporation",
		EmployeeCount:    100,
		PortfolioType:    models.PortfolioTypeOnboarded,
		RiskLevel:        models.RiskLevelLow,
		ComplianceStatus: "compliant",
	}

	merchant2 := &models.Merchant{
		ID:               "merchant2",
		Name:             "Test Company 2",
		Industry:         "Finance",
		BusinessType:     "LLC",
		EmployeeCount:    50,
		PortfolioType:    models.PortfolioTypeProspective,
		RiskLevel:        models.RiskLevelHigh,
		ComplianceStatus: "pending",
	}

	differences := comparisonService.findDifferences(merchant1, merchant2)

	// Check that we have expected differences
	expectedCategories := []string{"Portfolio Type", "Risk Level", "Industry", "Business Type", "Employee Count", "Compliance Status"}

	if len(differences) < len(expectedCategories) {
		t.Errorf("Expected at least %d differences, got %d", len(expectedCategories), len(differences))
	}

	// Check that all expected categories are present
	categories := make(map[string]bool)
	for _, diff := range differences {
		categories[diff.Category] = true
	}

	for _, expected := range expectedCategories {
		if !categories[expected] {
			t.Errorf("Expected difference category '%s' not found", expected)
		}
	}

	// Check impact levels
	for _, diff := range differences {
		if diff.Impact != "low" && diff.Impact != "medium" && diff.Impact != "high" {
			t.Errorf("Invalid impact level: %s", diff.Impact)
		}
	}
}

func TestComparisonService_CompareRiskLevels(t *testing.T) {
	comparisonService := NewComparisonService(nil, nil)

	tests := []struct {
		name              string
		merchant1         *models.Merchant
		merchant2         *models.Merchant
		expectedAdvantage string
	}{
		{
			name:              "merchant1 has lower risk",
			merchant1:         &models.Merchant{RiskLevel: models.RiskLevelLow},
			merchant2:         &models.Merchant{RiskLevel: models.RiskLevelHigh},
			expectedAdvantage: "merchant1",
		},
		{
			name:              "merchant2 has lower risk",
			merchant1:         &models.Merchant{RiskLevel: models.RiskLevelHigh},
			merchant2:         &models.Merchant{RiskLevel: models.RiskLevelLow},
			expectedAdvantage: "merchant2",
		},
		{
			name:              "equal risk levels",
			merchant1:         &models.Merchant{RiskLevel: models.RiskLevelMedium},
			merchant2:         &models.Merchant{RiskLevel: models.RiskLevelMedium},
			expectedAdvantage: "equal",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := comparisonService.compareRiskLevels(tt.merchant1, tt.merchant2)

			if result.Advantage != tt.expectedAdvantage {
				t.Errorf("Expected advantage '%s', got '%s'", tt.expectedAdvantage, result.Advantage)
			}

			// Check risk values
			if result.Merchant1.Value < 1 || result.Merchant1.Value > 3 {
				t.Errorf("Invalid risk value for merchant1: %d", result.Merchant1.Value)
			}

			if result.Merchant2.Value < 1 || result.Merchant2.Value > 3 {
				t.Errorf("Invalid risk value for merchant2: %d", result.Merchant2.Value)
			}

			// Check risk scores
			if result.Merchant1.Score < 0 || result.Merchant1.Score > 1 {
				t.Errorf("Invalid risk score for merchant1: %f", result.Merchant1.Score)
			}

			if result.Merchant2.Score < 0 || result.Merchant2.Score > 1 {
				t.Errorf("Invalid risk score for merchant2: %f", result.Merchant2.Score)
			}
		})
	}
}

func TestComparisonService_GenerateRecommendations(t *testing.T) {
	comparisonService := NewComparisonService(nil, nil)

	merchant1 := &models.Merchant{
		Name:             "Test Company 1",
		Industry:         "Technology",
		PortfolioType:    models.PortfolioTypeProspective,
		RiskLevel:        models.RiskLevelHigh,
		ComplianceStatus: "pending",
	}

	merchant2 := &models.Merchant{
		Name:             "Test Company 2",
		Industry:         "Finance",
		PortfolioType:    models.PortfolioTypeOnboarded,
		RiskLevel:        models.RiskLevelLow,
		ComplianceStatus: "compliant",
	}

	differences := []ComparisonDifference{
		{Category: "Risk Level", Impact: "high"},
		{Category: "Portfolio Type", Impact: "medium"},
		{Category: "Industry", Impact: "medium"},
	}

	recommendations := comparisonService.generateRecommendations(merchant1, merchant2, differences)

	// Check that we have recommendations
	if len(recommendations) == 0 {
		t.Error("Expected recommendations, got none")
	}

	// Check recommendation types and priorities
	validTypes := map[string]bool{"risk": true, "onboarding": true, "diversification": true, "compliance": true, "business": true}
	validPriorities := map[string]bool{"low": true, "medium": true, "high": true}

	for _, rec := range recommendations {
		if !validTypes[rec.Type] {
			t.Errorf("Invalid recommendation type: %s", rec.Type)
		}

		if !validPriorities[rec.Priority] {
			t.Errorf("Invalid recommendation priority: %s", rec.Priority)
		}

		if rec.Message == "" {
			t.Error("Recommendation message should not be empty")
		}

		if rec.Action == "" {
			t.Error("Recommendation action should not be empty")
		}
	}
}

func TestComparisonService_GenerateSummary(t *testing.T) {
	comparisonService := NewComparisonService(nil, nil)

	merchant1 := &models.Merchant{
		Name:          "Test Company 1",
		PortfolioType: models.PortfolioTypeOnboarded,
		RiskLevel:     models.RiskLevelLow,
	}

	merchant2 := &models.Merchant{
		Name:          "Test Company 2",
		PortfolioType: models.PortfolioTypeProspective,
		RiskLevel:     models.RiskLevelHigh,
	}

	differences := []ComparisonDifference{
		{Impact: "high"},
		{Impact: "medium"},
		{Impact: "medium"},
		{Impact: "low"},
	}

	riskComparison := RiskComparison{
		Advantage: "merchant1",
	}

	summary := comparisonService.generateSummary(merchant1, merchant2, differences, riskComparison)

	// Check summary counts
	if summary.TotalDifferences != 4 {
		t.Errorf("Expected 4 total differences, got %d", summary.TotalDifferences)
	}

	if summary.HighImpactDifferences != 1 {
		t.Errorf("Expected 1 high impact difference, got %d", summary.HighImpactDifferences)
	}

	if summary.MediumImpactDifferences != 2 {
		t.Errorf("Expected 2 medium impact differences, got %d", summary.MediumImpactDifferences)
	}

	if summary.LowImpactDifferences != 1 {
		t.Errorf("Expected 1 low impact difference, got %d", summary.LowImpactDifferences)
	}

	// Check advantages
	if summary.RiskAdvantage != "Test Company 1" {
		t.Errorf("Expected risk advantage 'Test Company 1', got '%s'", summary.RiskAdvantage)
	}

	if summary.PortfolioAdvantage != "Test Company 1" {
		t.Errorf("Expected portfolio advantage 'Test Company 1', got '%s'", summary.PortfolioAdvantage)
	}

	// Check overall recommendation
	if summary.OverallRecommendation == "" {
		t.Error("Overall recommendation should not be empty")
	}
}

func TestComparisonService_GenerateComparisonReport(t *testing.T) {
	comparisonService := NewComparisonService(nil, nil)

	comparison := &ComparisonResult{
		ID: "test_comparison",
		Merchant1: &models.Merchant{
			Name:          "Test Company 1",
			PortfolioType: models.PortfolioTypeOnboarded,
			RiskLevel:     models.RiskLevelLow,
		},
		Merchant2: &models.Merchant{
			Name:          "Test Company 2",
			PortfolioType: models.PortfolioTypeProspective,
			RiskLevel:     models.RiskLevelHigh,
		},
		GeneratedBy: "user1",
	}

	tests := []struct {
		name   string
		format string
	}{
		{"JSON format", "json"},
		{"HTML format", "html"},
		{"CSV format", "csv"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := context.Background()
			report, err := comparisonService.GenerateComparisonReport(ctx, comparison, tt.format)

			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			if report == nil {
				t.Error("Expected report, got nil")
				return
			}

			if report.ReportID == "" {
				t.Error("Report ID should not be empty")
			}

			if report.Title == "" {
				t.Error("Report title should not be empty")
			}

			if report.Format != tt.format {
				t.Errorf("Expected format '%s', got '%s'", tt.format, report.Format)
			}

			if report.ExecutiveSummary == "" {
				t.Error("Executive summary should not be empty")
			}

			if report.DetailedAnalysis == "" {
				t.Error("Detailed analysis should not be empty")
			}
		})
	}
}

func TestComparisonService_ExportComparisonReport(t *testing.T) {
	comparisonService := NewComparisonService(nil, nil)

	report := &ComparisonReport{
		ReportID:    "test_report",
		Title:       "Test Report",
		GeneratedAt: time.Now(),
		GeneratedBy: "user1",
		Format:      "json",
		Merchants: ComparisonResult{
			Merchant1: &models.Merchant{Name: "Test Company 1"},
			Merchant2: &models.Merchant{Name: "Test Company 2"},
		},
	}

	tests := []struct {
		name   string
		format string
	}{
		{"JSON export", "json"},
		{"HTML export", "html"},
		{"CSV export", "csv"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			report.Format = tt.format
			ctx := context.Background()
			exportData, err := comparisonService.ExportComparisonReport(ctx, report)

			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			if len(exportData) == 0 {
				t.Error("Export data should not be empty")
			}

			// Basic format validation
			switch tt.format {
			case "json":
				if !strings.Contains(string(exportData), "Test Company 1") {
					t.Error("JSON export should contain merchant data")
				}
			case "html":
				if !strings.Contains(string(exportData), "<html>") {
					t.Error("HTML export should contain HTML tags")
				}
			case "csv":
				if !strings.Contains(string(exportData), "Test Company 1") {
					t.Error("CSV export should contain merchant data")
				}
			}
		})
	}
}

func TestComparisonService_ExportComparisonReport_UnsupportedFormat(t *testing.T) {
	comparisonService := NewComparisonService(nil, nil)

	report := &ComparisonReport{
		ReportID: "test_report",
		Format:   "unsupported",
	}

	ctx := context.Background()
	_, err := comparisonService.ExportComparisonReport(ctx, report)

	if err == nil {
		t.Error("Expected error for unsupported format")
	}

	if !strings.Contains(err.Error(), "unsupported export format") {
		t.Errorf("Expected error about unsupported format, got: %v", err)
	}
}

func TestComparisonService_CalculateRiskScore(t *testing.T) {
	comparisonService := NewComparisonService(nil, nil)

	tests := []struct {
		name          string
		riskLevel     models.RiskLevel
		expectedScore float64
	}{
		{"Low risk", models.RiskLevelLow, 0.2},
		{"Medium risk", models.RiskLevelMedium, 0.5},
		{"High risk", models.RiskLevelHigh, 0.8},
		{"Invalid risk", models.RiskLevel("invalid"), 0.5},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			score := comparisonService.calculateRiskScore(tt.riskLevel)
			if score != tt.expectedScore {
				t.Errorf("Expected score %f, got %f", tt.expectedScore, score)
			}
		})
	}
}

func TestComparisonService_FormatRevenue(t *testing.T) {
	comparisonService := NewComparisonService(nil, nil)

	tests := []struct {
		name     string
		revenue  *float64
		expected string
	}{
		{"Nil revenue", nil, "Not specified"},
		{"Zero revenue", floatPtr(0), "$0"},
		{"Positive revenue", floatPtr(1000000), "$1000000"},
		{"Negative revenue", floatPtr(-500000), "$-500000"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := comparisonService.formatRevenue(tt.revenue)
			if result != tt.expected {
				t.Errorf("Expected '%s', got '%s'", tt.expected, result)
			}
		})
	}
}

// Helper functions

func floatPtr(f float64) *float64 {
	return &f
}
