package services

import (
	"context"
	"database/sql"
	"log"
	"os"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// MockDB implements a minimal database interface for testing
type MockDB struct {
	queries []string
	results []interface{}
}

func (m *MockDB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
	m.queries = append(m.queries, query)
	// Return a mock rows object - in a real test, you'd use sqlmock
	return nil, nil
}

func (m *MockDB) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
	m.queries = append(m.queries, query)
	// Return a mock result
	return &MockResult{}, nil
}

type MockResult struct{}

func (m *MockResult) LastInsertId() (int64, error) { return 1, nil }
func (m *MockResult) RowsAffected() (int64, error) { return 1, nil }

func TestQueryPerformanceService_MonitorQuery(t *testing.T) {
	logger := log.New(os.Stdout, "TEST: ", log.LstdFlags)
	service := NewQueryPerformanceService(nil, logger)

	ctx := context.Background()
	queryName := "test_query"

	// Test successful query
	err := service.MonitorQuery(ctx, queryName, func() error {
		time.Sleep(10 * time.Millisecond) // Simulate query execution
		return nil
	})

	require.NoError(t, err)

	// Verify metrics were recorded
	metrics, exists := service.GetQueryMetrics(queryName)
	require.True(t, exists)
	assert.Equal(t, queryName, metrics.QueryName)
	assert.Equal(t, int64(1), metrics.ExecutionCount)
	assert.Equal(t, int64(0), metrics.ErrorCount)
	assert.Greater(t, metrics.AverageTime, 5*time.Millisecond)
	assert.Less(t, metrics.AverageTime, 20*time.Millisecond)

	// Test failed query
	err = service.MonitorQuery(ctx, queryName, func() error {
		time.Sleep(5 * time.Millisecond)
		return assert.AnError
	})

	require.Error(t, err)

	// Verify error was recorded
	metrics, exists = service.GetQueryMetrics(queryName)
	require.True(t, exists)
	assert.Equal(t, int64(2), metrics.ExecutionCount)
	assert.Equal(t, int64(1), metrics.ErrorCount)
}

func TestQueryPerformanceService_MonitorQueryWithResult(t *testing.T) {
	logger := log.New(os.Stdout, "TEST: ", log.LstdFlags)
	service := NewQueryPerformanceService(nil, logger)

	ctx := context.Background()
	queryName := "test_query_with_result"

	// Test successful query with result
	result, err := service.MonitorQueryWithResult(ctx, queryName, func() (string, error) {
		time.Sleep(10 * time.Millisecond)
		return "test_result", nil
	})

	require.NoError(t, err)
	assert.Equal(t, "test_result", result)

	// Verify metrics were recorded
	metrics, exists := service.GetQueryMetrics(queryName)
	require.True(t, exists)
	assert.Equal(t, int64(1), metrics.ExecutionCount)
	assert.Equal(t, int64(0), metrics.ErrorCount)

	// Test failed query with result
	_, err = service.MonitorQueryWithResult(ctx, queryName, func() (string, error) {
		time.Sleep(5 * time.Millisecond)
		return "", assert.AnError
	})

	require.Error(t, err)

	// Verify error was recorded
	metrics, exists = service.GetQueryMetrics(queryName)
	require.True(t, exists)
	assert.Equal(t, int64(2), metrics.ExecutionCount)
	assert.Equal(t, int64(1), metrics.ErrorCount)
}

func TestQueryPerformanceService_GeneratePerformanceReport(t *testing.T) {
	logger := log.New(os.Stdout, "TEST: ", log.LstdFlags)
	service := NewQueryPerformanceService(nil, logger)

	ctx := context.Background()

	// Add some test metrics
	service.MonitorQuery(ctx, "fast_query", func() error {
		time.Sleep(1 * time.Millisecond)
		return nil
	})

	service.MonitorQuery(ctx, "slow_query", func() error {
		time.Sleep(2 * time.Second) // This should be flagged as slow
		return nil
	})

	service.MonitorQuery(ctx, "error_query", func() error {
		return assert.AnError
	})

	// Generate performance report
	report, err := service.GeneratePerformanceReport(ctx, nil)
	require.NoError(t, err)

	assert.NotNil(t, report)
	assert.Equal(t, int64(3), report.TotalQueries)
	assert.Greater(t, report.AverageTime, 0)

	// Should have one slow query
	assert.Len(t, report.SlowQueries, 1)
	assert.Equal(t, "slow_query", report.SlowQueries[0].QueryName)

	// Should have recommendations
	assert.NotEmpty(t, report.Recommendations)
}

func TestQueryPerformanceService_GetSlowQueries(t *testing.T) {
	logger := log.New(os.Stdout, "TEST: ", log.LstdFlags)
	service := NewQueryPerformanceService(nil, logger)
	service.SetSlowQueryThreshold(100 * time.Millisecond)

	ctx := context.Background()

	// Add fast query
	service.MonitorQuery(ctx, "fast_query", func() error {
		time.Sleep(10 * time.Millisecond)
		return nil
	})

	// Add slow query
	service.MonitorQuery(ctx, "slow_query", func() error {
		time.Sleep(200 * time.Millisecond)
		return nil
	})

	slowQueries := service.GetSlowQueries()
	assert.Len(t, slowQueries, 1)
	assert.Equal(t, "slow_query", slowQueries[0].QueryName)
}

func TestQueryPerformanceService_OptimizeSlowQueries(t *testing.T) {
	logger := log.New(os.Stdout, "TEST: ", log.LstdFlags)
	service := NewQueryPerformanceService(nil, logger)
	service.SetSlowQueryThreshold(100 * time.Millisecond)

	ctx := context.Background()

	// Add a very slow query
	service.MonitorQuery(ctx, "very_slow_query", func() error {
		time.Sleep(5 * time.Second)
		return nil
	})

	// Add a query with high error rate
	for i := 0; i < 10; i++ {
		service.MonitorQuery(ctx, "error_prone_query", func() error {
			if i%2 == 0 {
				return assert.AnError
			}
			return nil
		})
	}

	optimizations, err := service.OptimizeSlowQueries(ctx)
	require.NoError(t, err)

	assert.NotEmpty(t, optimizations)

	// Should have optimization suggestions
	foundSlowQueryOptimization := false
	foundErrorOptimization := false

	for _, opt := range optimizations {
		if contains(opt, "very_slow_query") {
			foundSlowQueryOptimization = true
		}
		if contains(opt, "error_prone_query") {
			foundErrorOptimization = true
		}
	}

	assert.True(t, foundSlowQueryOptimization, "Should have optimization for slow query")
	assert.True(t, foundErrorOptimization, "Should have optimization for error-prone query")
}

func TestQueryPerformanceService_ResetMetrics(t *testing.T) {
	logger := log.New(os.Stdout, "TEST: ", log.LstdFlags)
	service := NewQueryPerformanceService(nil, logger)

	ctx := context.Background()

	// Add some metrics
	service.MonitorQuery(ctx, "test_query", func() error {
		return nil
	})

	// Verify metrics exist
	metrics := service.GetAllMetrics()
	assert.Len(t, metrics, 1)

	// Reset metrics
	service.ResetMetrics()

	// Verify metrics are cleared
	metrics = service.GetAllMetrics()
	assert.Len(t, metrics, 0)
}

func TestQueryPerformanceService_AnalyzeTables(t *testing.T) {
	mockDB := &MockDB{}
	logger := log.New(os.Stdout, "TEST: ", log.LstdFlags)
	service := NewQueryPerformanceService(mockDB, logger)

	ctx := context.Background()

	err := service.AnalyzeTables(ctx)
	require.NoError(t, err)

	// Verify that ANALYZE commands were executed
	assert.Greater(t, len(mockDB.queries), 0)

	// Check that ANALYZE commands were issued for expected tables
	expectedTables := []string{
		"merchants",
		"portfolio_types",
		"risk_levels",
		"merchant_sessions",
		"merchant_audit_logs",
		"compliance_records",
		"merchant_analytics",
		"merchant_notifications",
		"bulk_operations",
		"bulk_operation_items",
	}

	for _, table := range expectedTables {
		found := false
		for _, query := range mockDB.queries {
			if contains(query, "ANALYZE "+table) {
				found = true
				break
			}
		}
		assert.True(t, found, "Should have ANALYZE command for table: %s", table)
	}
}

func TestQueryPerformanceService_VacuumTables(t *testing.T) {
	mockDB := &MockDB{}
	logger := log.New(os.Stdout, "TEST: ", log.LstdFlags)
	service := NewQueryPerformanceService(mockDB, logger)

	ctx := context.Background()

	err := service.VacuumTables(ctx)
	require.NoError(t, err)

	// Verify that VACUUM commands were executed
	assert.Greater(t, len(mockDB.queries), 0)

	// Check that VACUUM commands were issued for expected tables
	expectedTables := []string{
		"merchants",
		"merchant_audit_logs",
		"compliance_records",
		"merchant_analytics",
		"merchant_notifications",
	}

	for _, table := range expectedTables {
		found := false
		for _, query := range mockDB.queries {
			if contains(query, "VACUUM ANALYZE "+table) {
				found = true
				break
			}
		}
		assert.True(t, found, "Should have VACUUM command for table: %s", table)
	}
}

func TestQueryPerformanceService_SetSlowQueryThreshold(t *testing.T) {
	logger := log.New(os.Stdout, "TEST: ", log.LstdFlags)
	service := NewQueryPerformanceService(nil, logger)

	// Test default threshold
	slowQueries := service.GetSlowQueries()
	assert.Len(t, slowQueries, 0) // No queries yet

	// Set custom threshold
	service.SetSlowQueryThreshold(50 * time.Millisecond)

	ctx := context.Background()

	// Add query that should be considered slow with new threshold
	service.MonitorQuery(ctx, "medium_query", func() error {
		time.Sleep(100 * time.Millisecond)
		return nil
	})

	slowQueries = service.GetSlowQueries()
	assert.Len(t, slowQueries, 1)
	assert.Equal(t, "medium_query", slowQueries[0].QueryName)
}

// Benchmark tests
func BenchmarkQueryPerformanceService_MonitorQuery(b *testing.B) {
	logger := log.New(os.Stdout, "BENCH: ", log.LstdFlags)
	service := NewQueryPerformanceService(nil, logger)

	ctx := context.Background()
	queryName := "benchmark_query"

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		service.MonitorQuery(ctx, queryName, func() error {
			// Simulate minimal work
			return nil
		})
	}
}

func BenchmarkQueryPerformanceService_GeneratePerformanceReport(b *testing.B) {
	logger := log.New(os.Stdout, "BENCH: ", log.LstdFlags)
	service := NewQueryPerformanceService(nil, logger)

	ctx := context.Background()

	// Pre-populate with some metrics
	for i := 0; i < 100; i++ {
		service.MonitorQuery(ctx, "query_"+string(rune(i)), func() error {
			time.Sleep(time.Duration(i%10) * time.Millisecond)
			return nil
		})
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := service.GeneratePerformanceReport(ctx, nil)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// Helper function
func contains(s, substr string) bool {
	return len(s) >= len(substr) && s[:len(substr)] == substr ||
		len(s) > len(substr) && s[len(s)-len(substr):] == substr ||
		len(s) > len(substr) && contains(s[1:], substr)
}
