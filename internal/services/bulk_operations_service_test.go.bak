package services

import (
	"context"
	"errors"
	"fmt"
	"log"
	"testing"
	"time"

	"github.com/pcraw4d/business-verification/internal/database"
)

// Mock database for testing - implements only the methods needed for bulk operations
type mockDatabase struct {
	businesses map[string]*database.Business
	auditLogs  []*database.AuditLog
}

func newMockDatabase() *mockDatabase {
	return &mockDatabase{
		businesses: make(map[string]*database.Business),
		auditLogs:  []*database.AuditLog{},
	}
}

// Implement only the methods actually used by the bulk operations service
func (m *mockDatabase) CreateBusiness(ctx context.Context, business *database.Business) error {
	m.businesses[business.ID] = business
	return nil
}

func (m *mockDatabase) GetBusinessByID(ctx context.Context, id string) (*database.Business, error) {
	business, exists := m.businesses[id]
	if !exists {
		return nil, database.ErrUserNotFound
	}
	return business, nil
}

func (m *mockDatabase) UpdateBusiness(ctx context.Context, business *database.Business) error {
	if _, exists := m.businesses[business.ID]; !exists {
		return database.ErrUserNotFound
	}
	m.businesses[business.ID] = business
	return nil
}

func (m *mockDatabase) DeleteBusiness(ctx context.Context, id string) error {
	if _, exists := m.businesses[id]; !exists {
		return database.ErrUserNotFound
	}
	delete(m.businesses, id)
	return nil
}

func (m *mockDatabase) ListBusinesses(ctx context.Context, limit, offset int) ([]*database.Business, error) {
	var businesses []*database.Business
	count := 0
	for _, business := range m.businesses {
		if count >= offset && count < offset+limit {
			businesses = append(businesses, business)
		}
		count++
	}
	return businesses, nil
}

func (m *mockDatabase) CreateAuditLog(ctx context.Context, auditLog *database.AuditLog) error {
	m.auditLogs = append(m.auditLogs, auditLog)
	return nil
}

func (m *mockDatabase) BeginTx(ctx context.Context) (database.Database, error) {
	return m, nil
}

func (m *mockDatabase) Close() error {
	return nil
}

func (m *mockDatabase) Commit() error {
	return nil
}

func (m *mockDatabase) Rollback() error {
	return nil
}

func (m *mockDatabase) Connect(ctx context.Context) error {
	return nil
}

func (m *mockDatabase) Ping(ctx context.Context) error {
	return nil
}

// Implement all other required interface methods as no-ops
func (m *mockDatabase) CreateUser(ctx context.Context, user *database.User) error { return nil }
func (m *mockDatabase) GetUserByID(ctx context.Context, id string) (*database.User, error) {
	return nil, nil
}
func (m *mockDatabase) GetUserByEmail(ctx context.Context, email string) (*database.User, error) {
	return nil, nil
}
func (m *mockDatabase) UpdateUser(ctx context.Context, user *database.User) error { return nil }
func (m *mockDatabase) DeleteUser(ctx context.Context, id string) error           { return nil }
func (m *mockDatabase) ListUsers(ctx context.Context, limit, offset int) ([]*database.User, error) {
	return nil, nil
}
func (m *mockDatabase) CreateEmailVerificationToken(ctx context.Context, token *database.EmailVerificationToken) error {
	return nil
}
func (m *mockDatabase) GetEmailVerificationToken(ctx context.Context, token string) (*database.EmailVerificationToken, error) {
	return nil, nil
}
func (m *mockDatabase) MarkEmailVerificationTokenUsed(ctx context.Context, token string) error {
	return nil
}
func (m *mockDatabase) DeleteExpiredEmailVerificationTokens(ctx context.Context) error { return nil }
func (m *mockDatabase) CreatePasswordResetToken(ctx context.Context, token *database.PasswordResetToken) error {
	return nil
}
func (m *mockDatabase) GetPasswordResetToken(ctx context.Context, token string) (*database.PasswordResetToken, error) {
	return nil, nil
}
func (m *mockDatabase) MarkPasswordResetTokenUsed(ctx context.Context, token string) error {
	return nil
}
func (m *mockDatabase) DeleteExpiredPasswordResetTokens(ctx context.Context) error { return nil }
func (m *mockDatabase) CreateTokenBlacklist(ctx context.Context, blacklist *database.TokenBlacklist) error {
	return nil
}
func (m *mockDatabase) IsTokenBlacklisted(ctx context.Context, tokenID string) (bool, error) {
	return false, nil
}
func (m *mockDatabase) DeleteExpiredTokenBlacklist(ctx context.Context) error { return nil }
func (m *mockDatabase) GetBusinessByRegistrationNumber(ctx context.Context, regNumber string) (*database.Business, error) {
	return nil, nil
}
func (m *mockDatabase) SearchBusinesses(ctx context.Context, query string, limit, offset int) ([]*database.Business, error) {
	return nil, nil
}
func (m *mockDatabase) CreateBusinessClassification(ctx context.Context, classification *database.BusinessClassification) error {
	return nil
}
func (m *mockDatabase) GetBusinessClassificationByID(ctx context.Context, id string) (*database.BusinessClassification, error) {
	return nil, nil
}
func (m *mockDatabase) GetBusinessClassificationsByBusinessID(ctx context.Context, businessID string) ([]*database.BusinessClassification, error) {
	return nil, nil
}
func (m *mockDatabase) UpdateBusinessClassification(ctx context.Context, classification *database.BusinessClassification) error {
	return nil
}
func (m *mockDatabase) DeleteBusinessClassification(ctx context.Context, id string) error { return nil }
func (m *mockDatabase) CreateRiskAssessment(ctx context.Context, assessment *database.RiskAssessment) error {
	return nil
}
func (m *mockDatabase) GetRiskAssessmentByID(ctx context.Context, id string) (*database.RiskAssessment, error) {
	return nil, nil
}
func (m *mockDatabase) GetRiskAssessmentsByBusinessID(ctx context.Context, businessID string) ([]*database.RiskAssessment, error) {
	return nil, nil
}
func (m *mockDatabase) UpdateRiskAssessment(ctx context.Context, assessment *database.RiskAssessment) error {
	return nil
}
func (m *mockDatabase) DeleteRiskAssessment(ctx context.Context, id string) error { return nil }
func (m *mockDatabase) GetRiskAssessmentHistory(ctx context.Context, businessID string, limit, offset int) ([]*database.RiskAssessment, error) {
	return nil, nil
}
func (m *mockDatabase) GetRiskAssessmentHistoryByDateRange(ctx context.Context, businessID string, startDate, endDate time.Time) ([]*database.RiskAssessment, error) {
	return nil, nil
}
func (m *mockDatabase) GetLatestRiskAssessment(ctx context.Context, businessID string) (*database.RiskAssessment, error) {
	return nil, nil
}
func (m *mockDatabase) GetRiskAssessmentTrends(ctx context.Context, businessID string, days int) ([]*database.RiskAssessment, error) {
	return nil, nil
}
func (m *mockDatabase) GetRiskAssessmentsByLevel(ctx context.Context, businessID string, riskLevel string) ([]*database.RiskAssessment, error) {
	return nil, nil
}
func (m *mockDatabase) GetRiskAssessmentsByScoreRange(ctx context.Context, businessID string, minScore, maxScore float64) ([]*database.RiskAssessment, error) {
	return nil, nil
}
func (m *mockDatabase) GetRiskAssessmentStatistics(ctx context.Context, businessID string) (map[string]interface{}, error) {
	return nil, nil
}
func (m *mockDatabase) CreateComplianceCheck(ctx context.Context, check *database.ComplianceCheck) error {
	return nil
}
func (m *mockDatabase) GetComplianceCheckByID(ctx context.Context, id string) (*database.ComplianceCheck, error) {
	return nil, nil
}
func (m *mockDatabase) GetComplianceChecksByBusinessID(ctx context.Context, businessID string) ([]*database.ComplianceCheck, error) {
	return nil, nil
}
func (m *mockDatabase) UpdateComplianceCheck(ctx context.Context, check *database.ComplianceCheck) error {
	return nil
}
func (m *mockDatabase) DeleteComplianceCheck(ctx context.Context, id string) error      { return nil }
func (m *mockDatabase) CreateAPIKey(ctx context.Context, apiKey *database.APIKey) error { return nil }
func (m *mockDatabase) GetAPIKeyByID(ctx context.Context, id string) (*database.APIKey, error) {
	return nil, nil
}
func (m *mockDatabase) GetAPIKeyByHash(ctx context.Context, keyHash string) (*database.APIKey, error) {
	return nil, nil
}
func (m *mockDatabase) UpdateAPIKey(ctx context.Context, apiKey *database.APIKey) error { return nil }
func (m *mockDatabase) DeleteAPIKey(ctx context.Context, id string) error               { return nil }
func (m *mockDatabase) ListAPIKeysByUserID(ctx context.Context, userID string) ([]*database.APIKey, error) {
	return nil, nil
}
func (m *mockDatabase) GetAuditLogsByUserID(ctx context.Context, userID string, limit, offset int) ([]*database.AuditLog, error) {
	return nil, nil
}
func (m *mockDatabase) GetAuditLogsByResource(ctx context.Context, resourceType, resourceID string, limit, offset int) ([]*database.AuditLog, error) {
	return nil, nil
}
func (m *mockDatabase) CreateExternalServiceCall(ctx context.Context, call *database.ExternalServiceCall) error {
	return nil
}
func (m *mockDatabase) GetExternalServiceCallsByUserID(ctx context.Context, userID string, limit, offset int) ([]*database.ExternalServiceCall, error) {
	return nil, nil
}
func (m *mockDatabase) GetExternalServiceCallsByService(ctx context.Context, serviceName string, limit, offset int) ([]*database.ExternalServiceCall, error) {
	return nil, nil
}
func (m *mockDatabase) CreateWebhook(ctx context.Context, webhook *database.Webhook) error {
	return nil
}
func (m *mockDatabase) GetWebhookByID(ctx context.Context, id string) (*database.Webhook, error) {
	return nil, nil
}
func (m *mockDatabase) GetWebhooksByUserID(ctx context.Context, userID string) ([]*database.Webhook, error) {
	return nil, nil
}
func (m *mockDatabase) UpdateWebhook(ctx context.Context, webhook *database.Webhook) error {
	return nil
}
func (m *mockDatabase) DeleteWebhook(ctx context.Context, id string) error { return nil }
func (m *mockDatabase) CreateWebhookEvent(ctx context.Context, event *database.WebhookEvent) error {
	return nil
}
func (m *mockDatabase) GetWebhookEventByID(ctx context.Context, id string) (*database.WebhookEvent, error) {
	return nil, nil
}
func (m *mockDatabase) GetWebhookEventsByWebhookID(ctx context.Context, webhookID string, limit, offset int) ([]*database.WebhookEvent, error) {
	return nil, nil
}
func (m *mockDatabase) UpdateWebhookEvent(ctx context.Context, event *database.WebhookEvent) error {
	return nil
}
func (m *mockDatabase) DeleteWebhookEvent(ctx context.Context, id string) error { return nil }
func (m *mockDatabase) CreateRoleAssignment(ctx context.Context, assignment *database.RoleAssignment) error {
	return nil
}
func (m *mockDatabase) GetRoleAssignmentByID(ctx context.Context, id string) (*database.RoleAssignment, error) {
	return nil, nil
}
func (m *mockDatabase) GetActiveRoleAssignmentByUserID(ctx context.Context, userID string) (*database.RoleAssignment, error) {
	return nil, nil
}
func (m *mockDatabase) GetRoleAssignmentsByUserID(ctx context.Context, userID string) ([]*database.RoleAssignment, error) {
	return nil, nil
}
func (m *mockDatabase) UpdateRoleAssignment(ctx context.Context, assignment *database.RoleAssignment) error {
	return nil
}
func (m *mockDatabase) DeactivateRoleAssignment(ctx context.Context, id string) error { return nil }
func (m *mockDatabase) DeleteExpiredRoleAssignments(ctx context.Context) error        { return nil }
func (m *mockDatabase) UpdateAPIKeyLastUsed(ctx context.Context, id string, lastUsed time.Time) error {
	return nil
}
func (m *mockDatabase) GetActiveAPIKeysByRole(ctx context.Context, role string) ([]*database.APIKey, error) {
	return nil, nil
}
func (m *mockDatabase) DeactivateAPIKey(ctx context.Context, id string) error { return nil }

// Mock merchant service for testing
type mockMerchantService struct {
	merchants map[string]*Merchant
	errors    map[string]error
}

func newMockMerchantService() *mockMerchantService {
	return &mockMerchantService{
		merchants: make(map[string]*Merchant),
		errors:    make(map[string]error),
	}
}

func (m *mockMerchantService) UpdateMerchantPortfolioType(ctx context.Context, merchantID string, portfolioType PortfolioType, userID string) error {
	if err, exists := m.errors["update_portfolio_type"]; exists {
		return err
	}
	if _, exists := m.merchants[merchantID]; !exists {
		return database.ErrMerchantNotFound
	}
	m.merchants[merchantID].PortfolioType = portfolioType
	return nil
}

func (m *mockMerchantService) UpdateMerchantRiskLevel(ctx context.Context, merchantID string, riskLevel RiskLevel, userID string) error {
	if err, exists := m.errors["update_risk_level"]; exists {
		return err
	}
	if _, exists := m.merchants[merchantID]; !exists {
		return database.ErrMerchantNotFound
	}
	m.merchants[merchantID].RiskLevel = riskLevel
	return nil
}

func (m *mockMerchantService) UpdateMerchantStatus(ctx context.Context, merchantID string, status string, userID string) error {
	if err, exists := m.errors["update_status"]; exists {
		return err
	}
	if _, exists := m.merchants[merchantID]; !exists {
		return database.ErrMerchantNotFound
	}
	m.merchants[merchantID].Status = status
	return nil
}

func (m *mockMerchantService) DeleteMerchant(ctx context.Context, merchantID string, userID string) error {
	if err, exists := m.errors["delete"]; exists {
		return err
	}
	if _, exists := m.merchants[merchantID]; !exists {
		return database.ErrMerchantNotFound
	}
	delete(m.merchants, merchantID)
	return nil
}

func (m *mockMerchantService) isValidPortfolioType(portfolioType PortfolioType) bool {
	validTypes := []PortfolioType{
		PortfolioTypeProspective,
		PortfolioTypeOnboarded,
		PortfolioTypeActive,
		PortfolioTypeInactive,
		PortfolioTypeSuspended,
	}
	for _, validType := range validTypes {
		if portfolioType == validType {
			return true
		}
	}
	return false
}

func (m *mockMerchantService) isValidRiskLevel(riskLevel RiskLevel) bool {
	validLevels := []RiskLevel{
		RiskLevelLow,
		RiskLevelMedium,
		RiskLevelHigh,
		RiskLevelCritical,
	}
	for _, validLevel := range validLevels {
		if riskLevel == validLevel {
			return true
		}
	}
	return false
}

func (m *mockMerchantService) SetError(method string, err error) {
	m.errors[method] = err
}

func (m *mockMerchantService) AddMerchant(merchant *Merchant) {
	m.merchants[merchant.ID] = merchant
}

// Mock audit service for testing
type mockAuditService struct {
	events []AuditEvent
}

type AuditEvent struct {
	UserID       string
	Action       string
	ResourceType string
	ResourceID   string
	Details      string
}

func newMockAuditService() *mockAuditService {
	return &mockAuditService{
		events: []AuditEvent{},
	}
}

func (m *mockAuditService) LogMerchantOperation(ctx context.Context, req *LogMerchantOperationRequest) error {
	m.events = append(m.events, AuditEvent{
		UserID:       req.UserID,
		Action:       req.Action,
		ResourceType: req.ResourceType,
		ResourceID:   req.ResourceID,
		Details:      req.Details,
	})
	return nil
}

// Mock compliance service for testing
type mockComplianceService struct {
	results map[string]*MerchantComplianceStatus
}

func newMockComplianceService() *mockComplianceService {
	return &mockComplianceService{
		results: make(map[string]*MerchantComplianceStatus),
	}
}

func (m *mockComplianceService) ValidateMerchantCompliance(ctx context.Context, merchantID string) (*MerchantComplianceStatus, error) {
	result, exists := m.results[merchantID]
	if !exists {
		return &MerchantComplianceStatus{
			OverallStatus:   ComplianceStatusCompleted,
			ComplianceScore: 0.95,
		}, nil
	}
	return result, nil
}

func (m *mockComplianceService) SetComplianceResult(merchantID string, result *MerchantComplianceStatus) {
	m.results[merchantID] = result
}

func TestBulkOperationsService_StartBulkOperation(t *testing.T) {
	tests := []struct {
		name           string
		request        *BulkOperationRequest
		userID         string
		expectedError  string
		expectedStatus BulkOperationStatus
	}{
		{
			name: "successful portfolio type update",
			request: &BulkOperationRequest{
				Type:        BulkOperationTypeUpdatePortfolioType,
				MerchantIDs: []string{"merchant1", "merchant2"},
				Parameters: map[string]interface{}{
					"portfolio_type": "onboarded",
				},
			},
			userID:         "user1",
			expectedStatus: BulkOperationStatusPending,
		},
		{
			name: "successful risk level update",
			request: &BulkOperationRequest{
				Type:        BulkOperationTypeUpdateRiskLevel,
				MerchantIDs: []string{"merchant1"},
				Parameters: map[string]interface{}{
					"risk_level": "high",
				},
			},
			userID:         "user1",
			expectedStatus: BulkOperationStatusPending,
		},
		{
			name: "empty merchant list",
			request: &BulkOperationRequest{
				Type:        BulkOperationTypeUpdatePortfolioType,
				MerchantIDs: []string{},
				Parameters: map[string]interface{}{
					"portfolio_type": "onboarded",
				},
			},
			userID:        "user1",
			expectedError: "merchant list cannot be empty",
		},
		{
			name: "missing portfolio type parameter",
			request: &BulkOperationRequest{
				Type:        BulkOperationTypeUpdatePortfolioType,
				MerchantIDs: []string{"merchant1"},
				Parameters:  map[string]interface{}{},
			},
			userID:        "user1",
			expectedError: "portfolio_type parameter is required",
		},
		{
			name: "invalid operation type",
			request: &BulkOperationRequest{
				Type:        "invalid_type",
				MerchantIDs: []string{"merchant1"},
				Parameters:  map[string]interface{}{},
			},
			userID:        "user1",
			expectedError: "invalid bulk operation type",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup
			mockDB := newMockDatabase()
			mockAudit := newMockAuditService()
			mockCompliance := newMockComplianceService()
			mockMerchantService := newMockMerchantService()
			service := NewBulkOperationsService(mockDB, log.Default(), mockMerchantService, mockAudit, mockCompliance)

			// Add test merchants to mock service
			for _, merchantID := range tt.request.MerchantIDs {
				merchant := &Merchant{
					ID:        merchantID,
					Name:      "Test Merchant " + merchantID,
					Status:    "prospective",
					RiskLevel: RiskLevelMedium,
					CreatedAt: time.Now(),
					UpdatedAt: time.Now(),
				}
				mockMerchantService.AddMerchant(merchant)
			}

			// Execute
			operation, err := service.StartBulkOperation(context.Background(), tt.request, tt.userID)

			// Assert
			if tt.expectedError != "" {
				if err == nil {
					t.Errorf("Expected error %q, got nil", tt.expectedError)
				} else if err.Error() != tt.expectedError {
					t.Errorf("Expected error %q, got %q", tt.expectedError, err.Error())
				}
				return
			}

			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			if operation == nil {
				t.Error("Expected operation, got nil")
				return
			}

			if operation.Type != tt.request.Type {
				t.Errorf("Expected operation type %q, got %q", tt.request.Type, operation.Type)
			}

			if operation.Status != tt.expectedStatus {
				t.Errorf("Expected status %q, got %q", tt.expectedStatus, operation.Status)
			}

			if operation.UserID != tt.userID {
				t.Errorf("Expected user ID %q, got %q", tt.userID, operation.UserID)
			}

			if len(operation.MerchantIDs) != len(tt.request.MerchantIDs) {
				t.Errorf("Expected %d merchant IDs, got %d", len(tt.request.MerchantIDs), len(operation.MerchantIDs))
			}

			// Wait a bit for the operation to start processing
			time.Sleep(100 * time.Millisecond)
		})
	}
}

func TestBulkOperationsService_GetBulkOperation(t *testing.T) {
	// Setup
	mockDB := newMockDatabase()
	mockAudit := newMockAuditService()
	mockCompliance := newMockComplianceService()
	mockMerchantService := newMockMerchantService()
	service := NewBulkOperationsService(mockDB, log.Default(), mockMerchantService, mockAudit, mockCompliance)

	// Create test operation
	request := &BulkOperationRequest{
		Type:        BulkOperationTypeUpdatePortfolioType,
		MerchantIDs: []string{"merchant1"},
		Parameters: map[string]interface{}{
			"portfolio_type": "onboarded",
		},
	}

	operation, err := service.StartBulkOperation(context.Background(), request, "user1")
	if err != nil {
		t.Fatalf("Failed to start operation: %v", err)
	}

	// Test getting existing operation
	retrieved, err := service.GetBulkOperation(context.Background(), operation.ID)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	if retrieved.ID != operation.ID {
		t.Errorf("Expected operation ID %q, got %q", operation.ID, retrieved.ID)
	}

	// Test getting non-existent operation
	_, err = service.GetBulkOperation(context.Background(), "non-existent")
	if err == nil {
		t.Error("Expected error for non-existent operation")
	}

	if !errors.Is(err, ErrBulkOperationNotFound) {
		t.Errorf("Expected ErrBulkOperationNotFound, got %v", err)
	}
}

func TestBulkOperationsService_GetBulkOperationProgress(t *testing.T) {
	// Setup
	mockDB := newMockDatabase()
	mockAudit := newMockAuditService()
	mockCompliance := newMockComplianceService()
	mockMerchantService := newMockMerchantService()
	service := NewBulkOperationsService(mockDB, log.Default(), mockMerchantService, mockAudit, mockCompliance)

	// Add test merchant
	business := &database.Business{
		ID:        "merchant1",
		Name:      "Test Merchant",
		Status:    "prospective",
		RiskLevel: "medium",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	mockDB.CreateBusiness(context.Background(), business)

	// Create test operation
	request := &BulkOperationRequest{
		Type:        BulkOperationTypeUpdatePortfolioType,
		MerchantIDs: []string{"merchant1"},
		Parameters: map[string]interface{}{
			"portfolio_type": "onboarded",
		},
	}

	operation, err := service.StartBulkOperation(context.Background(), request, "user1")
	if err != nil {
		t.Fatalf("Failed to start operation: %v", err)
	}

	// Wait for operation to complete
	time.Sleep(200 * time.Millisecond)

	// Get progress
	progress, err := service.GetBulkOperationProgress(context.Background(), operation.ID)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	if progress.OperationID != operation.ID {
		t.Errorf("Expected operation ID %q, got %q", operation.ID, progress.OperationID)
	}

	if progress.TotalItems != 1 {
		t.Errorf("Expected total items 1, got %d", progress.TotalItems)
	}

	if progress.ProgressPercentage < 0 || progress.ProgressPercentage > 100 {
		t.Errorf("Progress percentage should be between 0 and 100, got %f", progress.ProgressPercentage)
	}
}

func TestBulkOperationsService_PauseResumeBulkOperation(t *testing.T) {
	// Setup
	mockDB := newMockDatabase()
	mockAudit := newMockAuditService()
	mockCompliance := newMockComplianceService()
	mockMerchantService := newMockMerchantService()
	service := NewBulkOperationsService(mockDB, log.Default(), mockMerchantService, mockAudit, mockCompliance)

	// Add test merchants
	for i := 1; i <= 5; i++ {
		business := &database.Business{
			ID:        fmt.Sprintf("merchant%d", i),
			Name:      fmt.Sprintf("Test Merchant %d", i),
			Status:    "prospective",
			RiskLevel: "medium",
			CreatedAt: time.Now(),
			UpdatedAt: time.Now(),
		}
		mockDB.CreateBusiness(context.Background(), business)
	}

	// Create test operation with multiple merchants
	request := &BulkOperationRequest{
		Type:        BulkOperationTypeUpdatePortfolioType,
		MerchantIDs: []string{"merchant1", "merchant2", "merchant3", "merchant4", "merchant5"},
		Parameters: map[string]interface{}{
			"portfolio_type": "onboarded",
		},
		Options: BulkOperationOptions{
			DelayBetweenBatches: 50 * time.Millisecond,
		},
	}

	operation, err := service.StartBulkOperation(context.Background(), request, "user1")
	if err != nil {
		t.Fatalf("Failed to start operation: %v", err)
	}

	// Wait a bit for operation to start
	time.Sleep(50 * time.Millisecond)

	// Pause operation
	err = service.PauseBulkOperation(context.Background(), operation.ID, "user1")
	if err != nil {
		t.Errorf("Unexpected error pausing operation: %v", err)
	}

	// Verify operation is paused
	retrieved, err := service.GetBulkOperation(context.Background(), operation.ID)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	if retrieved.Status != BulkOperationStatusPaused {
		t.Errorf("Expected status %q, got %q", BulkOperationStatusPaused, retrieved.Status)
	}

	// Resume operation
	err = service.ResumeBulkOperation(context.Background(), operation.ID, "user1")
	if err != nil {
		t.Errorf("Unexpected error resuming operation: %v", err)
	}

	// Wait for operation to complete
	time.Sleep(500 * time.Millisecond)

	// Verify operation completed
	retrieved, err = service.GetBulkOperation(context.Background(), operation.ID)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	if retrieved.Status != BulkOperationStatusCompleted {
		t.Errorf("Expected status %q, got %q", BulkOperationStatusCompleted, retrieved.Status)
	}
}

func TestBulkOperationsService_CancelBulkOperation(t *testing.T) {
	// Setup
	mockDB := newMockDatabase()
	mockAudit := newMockAuditService()
	mockCompliance := newMockComplianceService()
	mockMerchantService := newMockMerchantService()
	service := NewBulkOperationsService(mockDB, log.Default(), mockMerchantService, mockAudit, mockCompliance)

	// Add test merchants
	for i := 1; i <= 3; i++ {
		business := &database.Business{
			ID:        fmt.Sprintf("merchant%d", i),
			Name:      fmt.Sprintf("Test Merchant %d", i),
			Status:    "prospective",
			RiskLevel: "medium",
			CreatedAt: time.Now(),
			UpdatedAt: time.Now(),
		}
		mockDB.CreateBusiness(context.Background(), business)
	}

	// Create test operation
	request := &BulkOperationRequest{
		Type:        BulkOperationTypeUpdatePortfolioType,
		MerchantIDs: []string{"merchant1", "merchant2", "merchant3"},
		Parameters: map[string]interface{}{
			"portfolio_type": "onboarded",
		},
		Options: BulkOperationOptions{
			DelayBetweenBatches: 100 * time.Millisecond,
		},
	}

	operation, err := service.StartBulkOperation(context.Background(), request, "user1")
	if err != nil {
		t.Fatalf("Failed to start operation: %v", err)
	}

	// Wait a bit for operation to start
	time.Sleep(50 * time.Millisecond)

	// Cancel operation
	err = service.CancelBulkOperation(context.Background(), operation.ID, "user1")
	if err != nil {
		t.Errorf("Unexpected error cancelling operation: %v", err)
	}

	// Verify operation is cancelled
	retrieved, err := service.GetBulkOperation(context.Background(), operation.ID)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	if retrieved.Status != BulkOperationStatusCancelled {
		t.Errorf("Expected status %q, got %q", BulkOperationStatusCancelled, retrieved.Status)
	}
}

func TestBulkOperationsService_ListBulkOperations(t *testing.T) {
	// Setup
	mockDB := newMockDatabase()
	mockAudit := newMockAuditService()
	mockCompliance := newMockComplianceService()
	mockMerchantService := newMockMerchantService()
	service := NewBulkOperationsService(mockDB, log.Default(), mockMerchantService, mockAudit, mockCompliance)

	// Add test merchant
	business := &database.Business{
		ID:        "merchant1",
		Name:      "Test Merchant",
		Status:    "prospective",
		RiskLevel: "medium",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	mockDB.CreateBusiness(context.Background(), business)

	// Create multiple operations for user1
	for i := 1; i <= 3; i++ {
		request := &BulkOperationRequest{
			Type:        BulkOperationTypeUpdatePortfolioType,
			MerchantIDs: []string{"merchant1"},
			Parameters: map[string]interface{}{
				"portfolio_type": "onboarded",
			},
		}

		_, err := service.StartBulkOperation(context.Background(), request, "user1")
		if err != nil {
			t.Fatalf("Failed to start operation %d: %v", i, err)
		}
	}

	// Create operation for user2
	request := &BulkOperationRequest{
		Type:        BulkOperationTypeUpdateRiskLevel,
		MerchantIDs: []string{"merchant1"},
		Parameters: map[string]interface{}{
			"risk_level": "high",
		},
	}

	_, err := service.StartBulkOperation(context.Background(), request, "user2")
	if err != nil {
		t.Fatalf("Failed to start operation for user2: %v", err)
	}

	// List operations for user1
	operations, err := service.ListBulkOperations(context.Background(), "user1", 0)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	if len(operations) != 3 {
		t.Errorf("Expected 3 operations for user1, got %d", len(operations))
	}

	// List operations for user2
	operations, err = service.ListBulkOperations(context.Background(), "user2", 0)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	if len(operations) != 1 {
		t.Errorf("Expected 1 operation for user2, got %d", len(operations))
	}

	// Test limit
	operations, err = service.ListBulkOperations(context.Background(), "user1", 2)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	if len(operations) != 2 {
		t.Errorf("Expected 2 operations with limit, got %d", len(operations))
	}
}

func TestBulkOperationsService_ProcessMerchant(t *testing.T) {
	tests := []struct {
		name           string
		operationType  BulkOperationType
		parameters     map[string]interface{}
		expectedError  bool
		expectedResult bool
	}{
		{
			name:          "successful portfolio type update",
			operationType: BulkOperationTypeUpdatePortfolioType,
			parameters: map[string]interface{}{
				"portfolio_type": "onboarded",
			},
			expectedError:  false,
			expectedResult: true,
		},
		{
			name:          "successful risk level update",
			operationType: BulkOperationTypeUpdateRiskLevel,
			parameters: map[string]interface{}{
				"risk_level": "high",
			},
			expectedError:  false,
			expectedResult: true,
		},
		{
			name:          "successful status update",
			operationType: BulkOperationTypeUpdateStatus,
			parameters: map[string]interface{}{
				"status": "active",
			},
			expectedError:  false,
			expectedResult: true,
		},
		{
			name:           "successful compliance check",
			operationType:  BulkOperationTypeComplianceCheck,
			parameters:     map[string]interface{}{},
			expectedError:  false,
			expectedResult: true,
		},
		{
			name:          "invalid portfolio type",
			operationType: BulkOperationTypeUpdatePortfolioType,
			parameters: map[string]interface{}{
				"portfolio_type": "invalid",
			},
			expectedError:  true,
			expectedResult: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup
			mockDB := newMockDatabase()
			mockAudit := newMockAuditService()
			mockCompliance := newMockComplianceService()
			mockMerchantService := newMockMerchantService()
			service := NewBulkOperationsService(mockDB, log.Default(), mockMerchantService, mockAudit, mockCompliance)

			// Add test merchant
			business := &database.Business{
				ID:        "merchant1",
				Name:      "Test Merchant",
				Status:    "prospective",
				RiskLevel: "medium",
				CreatedAt: time.Now(),
				UpdatedAt: time.Now(),
			}
			mockDB.CreateBusiness(context.Background(), business)

			// Create operation
			operation := &BulkOperation{
				ID:          "test-operation",
				Type:        tt.operationType,
				Status:      BulkOperationStatusRunning,
				UserID:      "user1",
				MerchantIDs: []string{"merchant1"},
				TotalItems:  1,
				Results:     make([]BulkOperationItemResult, 1),
				Metadata:    tt.parameters,
				StartedAt:   time.Now(),
				CreatedAt:   time.Now(),
				UpdatedAt:   time.Now(),
			}

			// Process merchant
			service.processMerchant(context.Background(), operation, 0, "merchant1")

			// Verify result
			if tt.expectedError {
				if operation.Results[0].Status != BulkOperationItemStatusFailed {
					t.Errorf("Expected failed status, got %q", operation.Results[0].Status)
				}
				if operation.Results[0].Error == "" {
					t.Error("Expected error message, got empty")
				}
			} else {
				if operation.Results[0].Status != BulkOperationItemStatusSuccess {
					t.Errorf("Expected success status, got %q", operation.Results[0].Status)
				}
				if tt.expectedResult && operation.Results[0].Result == nil {
					t.Error("Expected result, got nil")
				}
			}
		})
	}
}

func TestBulkOperationsService_CleanupCompletedOperations(t *testing.T) {
	// Setup
	mockDB := newMockDatabase()
	mockAudit := newMockAuditService()
	mockCompliance := newMockComplianceService()
	mockMerchantService := newMockMerchantService()
	service := NewBulkOperationsService(mockDB, log.Default(), mockMerchantService, mockAudit, mockCompliance)

	// Add test merchant
	business := &database.Business{
		ID:        "merchant1",
		Name:      "Test Merchant",
		Status:    "prospective",
		RiskLevel: "medium",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	mockDB.CreateBusiness(context.Background(), business)

	// Create and complete an operation
	request := &BulkOperationRequest{
		Type:        BulkOperationTypeUpdatePortfolioType,
		MerchantIDs: []string{"merchant1"},
		Parameters: map[string]interface{}{
			"portfolio_type": "onboarded",
		},
	}

	operation, err := service.StartBulkOperation(context.Background(), request, "user1")
	if err != nil {
		t.Fatalf("Failed to start operation: %v", err)
	}

	// Wait for operation to complete
	time.Sleep(200 * time.Millisecond)

	// Manually set the operation as old
	service.operationsMutex.Lock()
	operation.UpdatedAt = time.Now().Add(-2 * time.Hour) // 2 hours ago
	service.operations[operation.ID] = operation
	service.operationsMutex.Unlock()

	// Cleanup operations older than 1 hour
	service.CleanupCompletedOperations(1 * time.Hour)

	// Verify operation was cleaned up
	_, err = service.GetBulkOperation(context.Background(), operation.ID)
	if err == nil {
		t.Error("Expected operation to be cleaned up")
	}

	if !errors.Is(err, ErrBulkOperationNotFound) {
		t.Errorf("Expected ErrBulkOperationNotFound, got %v", err)
	}
}

func TestBulkOperationsService_ValidateBulkOperationRequest(t *testing.T) {
	tests := []struct {
		name          string
		request       *BulkOperationRequest
		expectedError string
	}{
		{
			name:          "nil request",
			request:       nil,
			expectedError: "request cannot be nil",
		},
		{
			name: "empty operation type",
			request: &BulkOperationRequest{
				Type:        "",
				MerchantIDs: []string{"merchant1"},
			},
			expectedError: "invalid bulk operation type",
		},
		{
			name: "empty merchant list",
			request: &BulkOperationRequest{
				Type:        BulkOperationTypeUpdatePortfolioType,
				MerchantIDs: []string{},
			},
			expectedError: "merchant list cannot be empty",
		},
		{
			name: "too many merchants",
			request: &BulkOperationRequest{
				Type:        BulkOperationTypeUpdatePortfolioType,
				MerchantIDs: make([]string, 10001), // More than 10000
			},
			expectedError: "merchant list too large for bulk operation",
		},
		{
			name: "missing portfolio type parameter",
			request: &BulkOperationRequest{
				Type:        BulkOperationTypeUpdatePortfolioType,
				MerchantIDs: []string{"merchant1"},
				Parameters:  map[string]interface{}{},
			},
			expectedError: "portfolio_type parameter is required",
		},
		{
			name: "missing risk level parameter",
			request: &BulkOperationRequest{
				Type:        BulkOperationTypeUpdateRiskLevel,
				MerchantIDs: []string{"merchant1"},
				Parameters:  map[string]interface{}{},
			},
			expectedError: "risk_level parameter is required",
		},
		{
			name: "missing status parameter",
			request: &BulkOperationRequest{
				Type:        BulkOperationTypeUpdateStatus,
				MerchantIDs: []string{"merchant1"},
				Parameters:  map[string]interface{}{},
			},
			expectedError: "status parameter is required",
		},
		{
			name: "valid portfolio type update",
			request: &BulkOperationRequest{
				Type:        BulkOperationTypeUpdatePortfolioType,
				MerchantIDs: []string{"merchant1"},
				Parameters: map[string]interface{}{
					"portfolio_type": "onboarded",
				},
			},
			expectedError: "",
		},
		{
			name: "valid risk level update",
			request: &BulkOperationRequest{
				Type:        BulkOperationTypeUpdateRiskLevel,
				MerchantIDs: []string{"merchant1"},
				Parameters: map[string]interface{}{
					"risk_level": "high",
				},
			},
			expectedError: "",
		},
		{
			name: "valid status update",
			request: &BulkOperationRequest{
				Type:        BulkOperationTypeUpdateStatus,
				MerchantIDs: []string{"merchant1"},
				Parameters: map[string]interface{}{
					"status": "active",
				},
			},
			expectedError: "",
		},
		{
			name: "valid compliance check",
			request: &BulkOperationRequest{
				Type:        BulkOperationTypeComplianceCheck,
				MerchantIDs: []string{"merchant1"},
				Parameters:  map[string]interface{}{},
			},
			expectedError: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup
			mockDB := newMockDatabase()
			mockAudit := newMockAuditService()
			mockCompliance := newMockComplianceService()
			mockMerchantService := newMockMerchantService()
			service := NewBulkOperationsService(mockDB, log.Default(), mockMerchantService, mockAudit, mockCompliance)

			// Execute
			err := service.validateBulkOperationRequest(tt.request)

			// Assert
			if tt.expectedError != "" {
				if err == nil {
					t.Errorf("Expected error %q, got nil", tt.expectedError)
				} else if err.Error() != tt.expectedError {
					t.Errorf("Expected error %q, got %q", tt.expectedError, err.Error())
				}
			} else {
				if err != nil {
					t.Errorf("Unexpected error: %v", err)
				}
			}
		})
	}
}
