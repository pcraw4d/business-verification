package handlers

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"

	"kyb-platform/internal/middleware"
)

// AuthHandler handles authentication-related endpoints
type AuthHandler struct {
	authMiddleware *middleware.AuthMiddleware
	logger         *log.Logger
}

// NewAuthHandler creates a new authentication handler
func NewAuthHandler(authMiddleware *middleware.AuthMiddleware, logger *log.Logger) *AuthHandler {
	return &AuthHandler{
		authMiddleware: authMiddleware,
		logger:         logger,
	}
}

// LoginRequest represents a login request
type LoginRequest struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

// LoginResponse represents a login response
type LoginResponse struct {
	Success   bool   `json:"success"`
	Token     string `json:"token,omitempty"`
	ExpiresAt int64  `json:"expires_at,omitempty"`
	Message   string `json:"message"`
}

// APIKeyRequest represents an API key generation request
type APIKeyRequest struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	ExpiresIn   int    `json:"expires_in"` // days
}

// APIKeyResponse represents an API key response
type APIKeyResponse struct {
	Success   bool   `json:"success"`
	APIKey    string `json:"api_key,omitempty"`
	ExpiresAt int64  `json:"expires_at,omitempty"`
	Message   string `json:"message"`
}

// Login handles user authentication
func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req LoginRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.writeErrorResponse(w, http.StatusBadRequest, "Invalid request format")
		return
	}

	// For MVP, we'll use simple hardcoded credentials
	// In production, this would validate against a user database
	if req.Username == "admin" && req.Password == "kyb2024" {
		// Generate JWT token
		token, err := h.authMiddleware.GenerateToken("admin", "admin")
		if err != nil {
			h.logger.Printf("Failed to generate token: %v", err)
			h.writeErrorResponse(w, http.StatusInternalServerError, "Failed to generate token")
			return
		}

		response := LoginResponse{
			Success:   true,
			Token:     token,
			ExpiresAt: time.Now().Add(24 * time.Hour).Unix(),
			Message:   "Login successful",
		}

		h.writeJSONResponse(w, http.StatusOK, response)
		h.logger.Printf("User %s logged in successfully", req.Username)
		return
	}

	// Invalid credentials
	response := LoginResponse{
		Success: false,
		Message: "Invalid username or password",
	}

	h.writeJSONResponse(w, http.StatusUnauthorized, response)
	h.logger.Printf("Failed login attempt for username: %s", req.Username)
}

// GenerateAPIKey generates a new API key
func (h *AuthHandler) GenerateAPIKey(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Check if user is authenticated
	userID, role, authType := middleware.GetUserFromContext(r.Context())
	if authType == "" {
		h.writeErrorResponse(w, http.StatusUnauthorized, "Authentication required")
		return
	}

	// Only admins can generate API keys
	if role != "admin" {
		h.writeErrorResponse(w, http.StatusForbidden, "Admin privileges required")
		return
	}

	var req APIKeyRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.writeErrorResponse(w, http.StatusBadRequest, "Invalid request format")
		return
	}

	// Set default expiration if not provided
	if req.ExpiresIn == 0 {
		req.ExpiresIn = 365 // 1 year default
	}

	// Generate API key
	apiKey := h.generateAPIKey(req.Name)
	expiresAt := time.Now().Add(time.Duration(req.ExpiresIn) * 24 * time.Hour)

	response := APIKeyResponse{
		Success:   true,
		APIKey:    apiKey,
		ExpiresAt: expiresAt.Unix(),
		Message:   fmt.Sprintf("API key generated for %s", req.Name),
	}

	h.writeJSONResponse(w, http.StatusOK, response)
	h.logger.Printf("API key generated by user %s for %s", userID, req.Name)
}

// ValidateToken validates a JWT token
func (h *AuthHandler) ValidateToken(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Extract token from Authorization header
	authHeader := r.Header.Get("Authorization")
	if authHeader == "" {
		h.writeErrorResponse(w, http.StatusBadRequest, "Authorization header required")
		return
	}

	token := authHeader
	if strings.HasPrefix(authHeader, "Bearer ") {
		token = strings.TrimPrefix(authHeader, "Bearer ")
	}

	// Validate token
	claims, err := h.authMiddleware.ValidateJWT(token)
	if err != nil {
		h.writeErrorResponse(w, http.StatusUnauthorized, "Invalid token")
		return
	}

	response := map[string]interface{}{
		"valid":      true,
		"user_id":    claims.UserID,
		"role":       claims.Role,
		"expires_at": claims.ExpiresAt,
		"message":    "Token is valid",
	}

	h.writeJSONResponse(w, http.StatusOK, response)
}

// GetAuthStatus returns the current authentication status
func (h *AuthHandler) GetAuthStatus(w http.ResponseWriter, r *http.Request) {
	userID, role, authType := middleware.GetUserFromContext(r.Context())

	status := map[string]interface{}{
		"authenticated": authType != "",
		"auth_type":     authType,
		"user_id":       userID,
		"role":          role,
		"timestamp":     time.Now().Unix(),
	}

	h.writeJSONResponse(w, http.StatusOK, status)
}

// generateAPIKey generates a new API key (simplified version)
func (h *AuthHandler) generateAPIKey(name string) string {
	// In production, this would be more sophisticated
	return fmt.Sprintf("kyb_%s_%d", name, time.Now().Unix())
}

// writeJSONResponse writes a JSON response
func (h *AuthHandler) writeJSONResponse(w http.ResponseWriter, statusCode int, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(data)
}

// writeErrorResponse writes an error response
func (h *AuthHandler) writeErrorResponse(w http.ResponseWriter, statusCode int, message string) {
	response := map[string]interface{}{
		"error":   true,
		"message": message,
		"code":    statusCode,
	}
	h.writeJSONResponse(w, statusCode, response)
}
