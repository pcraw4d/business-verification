package database

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/pcraw4d/business-verification/internal/models"
)

// OptimizedMerchantRepository provides optimized database operations for merchant portfolio
type OptimizedMerchantRepository struct {
	db     *sql.DB
	logger *log.Logger
	cache  QueryCache // Interface for query result caching
}

// QueryCache interface for caching query results
type QueryCache interface {
	Get(ctx context.Context, key string) (interface{}, error)
	Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error
	Delete(ctx context.Context, key string) error
	InvalidatePattern(ctx context.Context, pattern string) error
}

// CursorPaginationParams represents cursor-based pagination parameters
type CursorPaginationParams struct {
	Cursor        *time.Time
	Limit         int
	PortfolioType *models.PortfolioType
	RiskLevel     *models.RiskLevel
	Industry      string
	Status        string
}

// PaginatedResult represents a paginated result with cursor information
type PaginatedResult struct {
	Merchants  []*models.Merchant
	NextCursor *time.Time
	HasMore    bool
	TotalCount int
}

// QueryPerformanceMetrics tracks query performance
type QueryPerformanceMetrics struct {
	QueryName     string
	ExecutionTime time.Duration
	RowsReturned  int
	CacheHit      bool
	IndexUsed     string
}

// NewOptimizedMerchantRepository creates a new optimized merchant repository
func NewOptimizedMerchantRepository(db *sql.DB, logger *log.Logger, cache QueryCache) *OptimizedMerchantRepository {
	return &OptimizedMerchantRepository{
		db:     db,
		logger: logger,
		cache:  cache,
	}
}

// =============================================================================
// OPTIMIZED QUERY METHODS
// =============================================================================

// GetMerchantsCursorPaginated retrieves merchants using cursor-based pagination
func (r *OptimizedMerchantRepository) GetMerchantsCursorPaginated(ctx context.Context, params CursorPaginationParams) (*PaginatedResult, error) {
	start := time.Now()
	defer func() {
		r.logger.Printf("GetMerchantsCursorPaginated executed in %v", time.Since(start))
	}()

	// Generate cache key
	cacheKey := r.generateCacheKey("merchants_cursor", params)

	// Try to get from cache first
	if r.cache != nil {
		if cached, err := r.cache.Get(ctx, cacheKey); err == nil && cached != nil {
			if result, ok := cached.(*PaginatedResult); ok {
				r.logger.Printf("Cache hit for merchants cursor pagination")
				return result, nil
			}
		}
	}

	// Build optimized query using the database function
	query := `
		SELECT 
			id, name, legal_name, industry, business_type, portfolio_type, 
			risk_level, compliance_status, status, created_at, updated_at
		FROM get_merchants_cursor_paginated($1, $2, $3, $4, $5, $6)
	`

	args := []interface{}{
		params.Cursor,
		params.Limit,
		params.PortfolioType,
		params.RiskLevel,
		params.Industry,
		params.Status,
	}

	rows, err := r.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute cursor pagination query: %w", err)
	}
	defer rows.Close()

	var merchants []*models.Merchant
	var nextCursor *time.Time

	for rows.Next() {
		var merchant models.Merchant
		var portfolioType, riskLevel string

		err := rows.Scan(
			&merchant.ID,
			&merchant.Name,
			&merchant.LegalName,
			&merchant.Industry,
			&merchant.BusinessType,
			&portfolioType,
			&riskLevel,
			&merchant.ComplianceStatus,
			&merchant.Status,
			&merchant.CreatedAt,
			&merchant.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan merchant: %w", err)
		}

		// Convert string enums to proper types
		merchant.PortfolioType = models.PortfolioType(portfolioType)
		merchant.RiskLevel = models.RiskLevel(riskLevel)

		merchants = append(merchants, &merchant)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating merchants: %w", err)
	}

	// Determine next cursor and has more
	hasMore := len(merchants) == params.Limit
	if hasMore && len(merchants) > 0 {
		nextCursor = &merchants[len(merchants)-1].CreatedAt
	}

	// Get total count (cached separately)
	totalCount, err := r.getMerchantCountOptimized(ctx, params)
	if err != nil {
		r.logger.Printf("Warning: failed to get total count: %v", err)
		totalCount = len(merchants) // Fallback
	}

	result := &PaginatedResult{
		Merchants:  merchants,
		NextCursor: nextCursor,
		HasMore:    hasMore,
		TotalCount: totalCount,
	}

	// Cache the result
	if r.cache != nil {
		r.cache.Set(ctx, cacheKey, result, 5*time.Minute)
	}

	return result, nil
}

// SearchMerchantsOptimized performs optimized merchant search with full-text search
func (r *OptimizedMerchantRepository) SearchMerchantsOptimized(ctx context.Context, searchQuery string, filters *models.MerchantSearchFilters, limit int) ([]*models.Merchant, error) {
	start := time.Now()
	defer func() {
		r.logger.Printf("SearchMerchantsOptimized executed in %v", time.Since(start))
	}()

	// Generate cache key
	cacheKey := r.generateCacheKey("merchants_search", searchQuery, filters, limit)

	// Try to get from cache first
	if r.cache != nil {
		if cached, err := r.cache.Get(ctx, cacheKey); err == nil && cached != nil {
			if merchants, ok := cached.([]*models.Merchant); ok {
				r.logger.Printf("Cache hit for merchant search")
				return merchants, nil
			}
		}
	}

	// Use full-text search for better performance
	query := `
		SELECT 
			m.id, m.name, m.legal_name, m.registration_number, m.tax_id, m.industry, m.industry_code,
			m.business_type, m.founded_date, m.employee_count, m.annual_revenue,
			m.address_street1, m.address_street2, m.address_city, m.address_state, 
			m.address_postal_code, m.address_country, m.address_country_code,
			m.contact_phone, m.contact_email, m.contact_website, m.contact_primary_contact,
			pt.type as portfolio_type, rl.level as risk_level, m.compliance_status, m.status,
			m.created_by, m.created_at, m.updated_at,
			ts_rank(to_tsvector('english', m.name || ' ' || m.legal_name), plainto_tsquery('english', $1)) as rank
		FROM merchants m
		JOIN portfolio_types pt ON m.portfolio_type_id = pt.id
		JOIN risk_levels rl ON m.risk_level_id = rl.id
		WHERE m.status = 'active'
		AND (
			to_tsvector('english', m.name || ' ' || m.legal_name) @@ plainto_tsquery('english', $1)
			OR m.name ILIKE $2
			OR m.legal_name ILIKE $2
			OR m.industry ILIKE $2
		)
	`

	var conditions []string
	var args []interface{}
	argIndex := 3

	// Add search query parameters
	args = append(args, searchQuery, "%"+searchQuery+"%")

	// Add filter conditions
	if filters != nil {
		if filters.PortfolioType != nil {
			conditions = append(conditions, fmt.Sprintf("pt.type = $%d", argIndex))
			args = append(args, string(*filters.PortfolioType))
			argIndex++
		}

		if filters.RiskLevel != nil {
			conditions = append(conditions, fmt.Sprintf("rl.level = $%d", argIndex))
			args = append(args, string(*filters.RiskLevel))
			argIndex++
		}

		if filters.Industry != "" {
			conditions = append(conditions, fmt.Sprintf("m.industry ILIKE $%d", argIndex))
			args = append(args, "%"+filters.Industry+"%")
			argIndex++
		}
	}

	if len(conditions) > 0 {
		query += " AND " + strings.Join(conditions, " AND ")
	}

	query += " ORDER BY rank DESC, m.created_at DESC LIMIT $" + fmt.Sprintf("%d", argIndex)
	args = append(args, limit)

	rows, err := r.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute optimized search query: %w", err)
	}
	defer rows.Close()

	var merchants []*models.Merchant
	for rows.Next() {
		merchant, err := r.scanMerchantWithRank(rows)
		if err != nil {
			return nil, fmt.Errorf("failed to scan merchant: %w", err)
		}
		merchants = append(merchants, merchant)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating merchants: %w", err)
	}

	// Cache the result
	if r.cache != nil {
		r.cache.Set(ctx, cacheKey, merchants, 2*time.Minute)
	}

	return merchants, nil
}

// GetMerchantPortfolioDashboard retrieves optimized dashboard data
func (r *OptimizedMerchantRepository) GetMerchantPortfolioDashboard(ctx context.Context, userID string) ([]*models.Merchant, error) {
	start := time.Now()
	defer func() {
		r.logger.Printf("GetMerchantPortfolioDashboard executed in %v", time.Since(start))
	}()

	// Generate cache key
	cacheKey := r.generateCacheKey("merchant_dashboard", userID)

	// Try to get from cache first
	if r.cache != nil {
		if cached, err := r.cache.Get(ctx, cacheKey); err == nil && cached != nil {
			if merchants, ok := cached.([]*models.Merchant); ok {
				r.logger.Printf("Cache hit for merchant dashboard")
				return merchants, nil
			}
		}
	}

	// Use the optimized view
	query := `
		SELECT 
			id, name, legal_name, industry, business_type, portfolio_type, 
			risk_level, compliance_status, status, created_at, updated_at,
			risk_score, compliance_score, transaction_volume, last_activity,
			unread_notifications, recent_audit_count
		FROM merchant_portfolio_dashboard
		WHERE created_by = $1
		ORDER BY created_at DESC
		LIMIT 100
	`

	rows, err := r.db.QueryContext(ctx, query, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to execute dashboard query: %w", err)
	}
	defer rows.Close()

	var merchants []*models.Merchant
	for rows.Next() {
		merchant, err := r.scanMerchantDashboard(rows)
		if err != nil {
			return nil, fmt.Errorf("failed to scan merchant: %w", err)
		}
		merchants = append(merchants, merchant)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating merchants: %w", err)
	}

	// Cache the result
	if r.cache != nil {
		r.cache.Set(ctx, cacheKey, merchants, 1*time.Minute)
	}

	return merchants, nil
}

// =============================================================================
// BULK OPERATIONS OPTIMIZATION
// =============================================================================

// BulkUpdateMerchants performs optimized bulk updates
func (r *OptimizedMerchantRepository) BulkUpdateMerchants(ctx context.Context, updates []models.MerchantUpdate) error {
	start := time.Now()
	defer func() {
		r.logger.Printf("BulkUpdateMerchants executed in %v", time.Since(start))
	}()

	if len(updates) == 0 {
		return nil
	}

	// Use batch processing for large updates
	batchSize := 1000
	for i := 0; i < len(updates); i += batchSize {
		end := i + batchSize
		if end > len(updates) {
			end = len(updates)
		}

		batch := updates[i:end]
		if err := r.processBatchUpdate(ctx, batch); err != nil {
			return fmt.Errorf("failed to process batch %d-%d: %w", i, end, err)
		}
	}

	// Invalidate relevant caches
	if r.cache != nil {
		r.cache.InvalidatePattern(ctx, "merchants_*")
	}

	return nil
}

// processBatchUpdate processes a batch of merchant updates
func (r *OptimizedMerchantRepository) processBatchUpdate(ctx context.Context, updates []models.MerchantUpdate) error {
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	// Prepare statement for better performance
	stmt, err := tx.PrepareContext(ctx, `
		UPDATE merchants 
		SET portfolio_type_id = $2, risk_level_id = $3, compliance_status = $4, 
		    status = $5, updated_at = CURRENT_TIMESTAMP
		WHERE id = $1
	`)
	if err != nil {
		return fmt.Errorf("failed to prepare statement: %w", err)
	}
	defer stmt.Close()

	for _, update := range updates {
		_, err := stmt.ExecContext(ctx, update.ID, update.PortfolioTypeID, update.RiskLevelID, update.ComplianceStatus, update.Status)
		if err != nil {
			return fmt.Errorf("failed to update merchant %s: %w", update.ID, err)
		}
	}

	return tx.Commit()
}

// =============================================================================
// PERFORMANCE MONITORING
// =============================================================================

// GetQueryPerformanceStats retrieves query performance statistics
func (r *OptimizedMerchantRepository) GetQueryPerformanceStats(ctx context.Context) ([]QueryPerformanceMetrics, error) {
	query := `SELECT * FROM get_query_performance_stats()`

	rows, err := r.db.QueryContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to get performance stats: %w", err)
	}
	defer rows.Close()

	var stats []QueryPerformanceMetrics
	for rows.Next() {
		var stat QueryPerformanceMetrics
		var tableName, indexName, indexSize string
		var usageCount int64
		var lastUsed *time.Time

		err := rows.Scan(&tableName, &indexName, &indexSize, &usageCount, &lastUsed)
		if err != nil {
			return nil, fmt.Errorf("failed to scan performance stat: %w", err)
		}

		stat.QueryName = tableName + "." + indexName
		stat.RowsReturned = int(usageCount)
		stats = append(stats, stat)
	}

	return stats, nil
}

// =============================================================================
// HELPER METHODS
// =============================================================================

// getMerchantCountOptimized gets merchant count using optimized function
func (r *OptimizedMerchantRepository) getMerchantCountOptimized(ctx context.Context, params CursorPaginationParams) (int, error) {
	var count int
	err := r.db.QueryRowContext(ctx, `
		SELECT get_merchant_count_by_filters($1, $2, $3, $4)
	`, params.PortfolioType, params.RiskLevel, params.Industry, params.Status).Scan(&count)

	if err != nil {
		return 0, fmt.Errorf("failed to get merchant count: %w", err)
	}

	return count, nil
}

// generateCacheKey generates a cache key for the given parameters
func (r *OptimizedMerchantRepository) generateCacheKey(prefix string, params ...interface{}) string {
	key := prefix
	for _, param := range params {
		key += fmt.Sprintf("_%v", param)
	}
	return key
}

// scanMerchantWithRank scans a merchant with search rank
func (r *OptimizedMerchantRepository) scanMerchantWithRank(rows *sql.Rows) (*models.Merchant, error) {
	var merchant models.Merchant
	var portfolioType, riskLevel string
	var rank float64

	err := rows.Scan(
		&merchant.ID,
		&merchant.Name,
		&merchant.LegalName,
		&merchant.RegistrationNumber,
		&merchant.TaxID,
		&merchant.Industry,
		&merchant.IndustryCode,
		&merchant.BusinessType,
		&merchant.FoundedDate,
		&merchant.EmployeeCount,
		&merchant.AnnualRevenue,
		&merchant.AddressStreet1,
		&merchant.AddressStreet2,
		&merchant.AddressCity,
		&merchant.AddressState,
		&merchant.AddressPostalCode,
		&merchant.AddressCountry,
		&merchant.AddressCountryCode,
		&merchant.ContactPhone,
		&merchant.ContactEmail,
		&merchant.ContactWebsite,
		&merchant.ContactPrimaryContact,
		&portfolioType,
		&riskLevel,
		&merchant.ComplianceStatus,
		&merchant.Status,
		&merchant.CreatedBy,
		&merchant.CreatedAt,
		&merchant.UpdatedAt,
		&rank,
	)
	if err != nil {
		return nil, err
	}

	merchant.PortfolioType = models.PortfolioType(portfolioType)
	merchant.RiskLevel = models.RiskLevel(riskLevel)

	return &merchant, nil
}

// scanMerchantDashboard scans a merchant with dashboard data
func (r *OptimizedMerchantRepository) scanMerchantDashboard(rows *sql.Rows) (*models.Merchant, error) {
	var merchant models.Merchant
	var portfolioType, riskLevel string
	var riskScore, complianceScore, transactionVolume sql.NullFloat64
	var lastActivity sql.NullTime
	var unreadNotifications, recentAuditCount int

	err := rows.Scan(
		&merchant.ID,
		&merchant.Name,
		&merchant.LegalName,
		&merchant.Industry,
		&merchant.BusinessType,
		&portfolioType,
		&riskLevel,
		&merchant.ComplianceStatus,
		&merchant.Status,
		&merchant.CreatedAt,
		&merchant.UpdatedAt,
		&riskScore,
		&complianceScore,
		&transactionVolume,
		&lastActivity,
		&unreadNotifications,
		&recentAuditCount,
	)
	if err != nil {
		return nil, err
	}

	merchant.PortfolioType = models.PortfolioType(portfolioType)
	merchant.RiskLevel = models.RiskLevel(riskLevel)

	// Add analytics data if available
	if riskScore.Valid {
		merchant.Analytics = &models.MerchantAnalytics{
			RiskScore:         riskScore.Float64,
			ComplianceScore:   complianceScore.Float64,
			TransactionVolume: transactionVolume.Float64,
			LastActivity:      lastActivity.Time,
		}
	}

	return &merchant, nil
}

// =============================================================================
// MAINTENANCE OPERATIONS
// =============================================================================

// CleanupOldData performs maintenance cleanup operations
func (r *OptimizedMerchantRepository) CleanupOldData(ctx context.Context) error {
	start := time.Now()
	defer func() {
		r.logger.Printf("CleanupOldData executed in %v", time.Since(start))
	}()

	// Clean up old audit logs
	auditCount, err := r.db.ExecContext(ctx, "SELECT cleanup_old_audit_logs()")
	if err != nil {
		r.logger.Printf("Warning: failed to cleanup audit logs: %v", err)
	} else {
		rowsAffected, _ := auditCount.RowsAffected()
		r.logger.Printf("Cleaned up %d old audit log entries", rowsAffected)
	}

	// Clean up old notifications
	notificationCount, err := r.db.ExecContext(ctx, "SELECT cleanup_old_notifications()")
	if err != nil {
		r.logger.Printf("Warning: failed to cleanup notifications: %v", err)
	} else {
		rowsAffected, _ := notificationCount.RowsAffected()
		r.logger.Printf("Cleaned up %d old notification entries", rowsAffected)
	}

	// Clean up expired sessions
	sessionCount, err := r.db.ExecContext(ctx, "SELECT cleanup_expired_sessions()")
	if err != nil {
		r.logger.Printf("Warning: failed to cleanup sessions: %v", err)
	} else {
		rowsAffected, _ := sessionCount.RowsAffected()
		r.logger.Printf("Cleaned up %d expired session entries", rowsAffected)
	}

	// Invalidate all caches after cleanup
	if r.cache != nil {
		r.cache.InvalidatePattern(ctx, "*")
	}

	return nil
}
