package database

import (
	"context"
	"database/sql"
	"log"
	"os"
	"testing"
	"time"

	"github.com/pcraw4d/business-verification/internal/models"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// MockCache implements QueryCache interface for testing
type MockCache struct {
	data map[string]interface{}
}

func NewMockCache() *MockCache {
	return &MockCache{
		data: make(map[string]interface{}),
	}
}

func (m *MockCache) Get(ctx context.Context, key string) (interface{}, error) {
	if val, exists := m.data[key]; exists {
		return val, nil
	}
	return nil, nil
}

func (m *MockCache) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error {
	m.data[key] = value
	return nil
}

func (m *MockCache) Delete(ctx context.Context, key string) error {
	delete(m.data, key)
	return nil
}

func (m *MockCache) InvalidatePattern(ctx context.Context, pattern string) error {
	// Simple pattern matching for testing
	for key := range m.data {
		if len(pattern) > 0 && pattern[len(pattern)-1] == '*' {
			prefix := pattern[:len(pattern)-1]
			if len(key) >= len(prefix) && key[:len(prefix)] == prefix {
				delete(m.data, key)
			}
		}
	}
	return nil
}

// Test database setup
func setupTestDB(t *testing.T) *sql.DB {
	// Use test database connection
	db, err := sql.Open("postgres", "postgres://test:test@localhost:5432/kyb_test?sslmode=disable")
	if err != nil {
		t.Skip("Skipping test - database not available")
	}

	// Test connection
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := db.PingContext(ctx); err != nil {
		t.Skip("Skipping test - database connection failed")
	}

	return db
}

func TestOptimizedMerchantRepository_GetMerchantsCursorPaginated(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test")
	}

	db := setupTestDB(t)
	defer db.Close()

	logger := log.New(os.Stdout, "TEST: ", log.LstdFlags)
	cache := NewMockCache()
	repo := NewOptimizedMerchantRepository(db, logger, cache)

	ctx := context.Background()

	tests := []struct {
		name   string
		params CursorPaginationParams
		want   int // Expected number of results
	}{
		{
			name: "first page",
			params: CursorPaginationParams{
				Limit:  10,
				Status: "active",
			},
			want: 10,
		},
		{
			name: "with portfolio type filter",
			params: CursorPaginationParams{
				Limit:         5,
				Status:        "active",
				PortfolioType: func() *models.PortfolioType { pt := models.PortfolioTypeOnboarded; return &pt }(),
			},
			want: 5,
		},
		{
			name: "with risk level filter",
			params: CursorPaginationParams{
				Limit:     5,
				Status:    "active",
				RiskLevel: func() *models.RiskLevel { rl := models.RiskLevelLow; return &rl }(),
			},
			want: 5,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := repo.GetMerchantsCursorPaginated(ctx, tt.params)
			require.NoError(t, err)
			assert.NotNil(t, result)
			assert.LessOrEqual(t, len(result.Merchants), tt.want)

			// Test cursor pagination
			if len(result.Merchants) > 0 {
				assert.NotNil(t, result.NextCursor)
				assert.True(t, result.HasMore || len(result.Merchants) < tt.params.Limit)
			}
		})
	}
}

func TestOptimizedMerchantRepository_SearchMerchantsOptimized(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test")
	}

	db := setupTestDB(t)
	defer db.Close()

	logger := log.New(os.Stdout, "TEST: ", log.LstdFlags)
	cache := NewMockCache()
	repo := NewOptimizedMerchantRepository(db, logger, cache)

	ctx := context.Background()

	tests := []struct {
		name        string
		searchQuery string
		filters     *models.MerchantSearchFilters
		limit       int
		wantMin     int
		wantMax     int
	}{
		{
			name:        "search by name",
			searchQuery: "test",
			limit:       10,
			wantMin:     0,
			wantMax:     10,
		},
		{
			name:        "search with filters",
			searchQuery: "company",
			filters: &models.MerchantSearchFilters{
				PortfolioType: func() *models.PortfolioType { pt := models.PortfolioTypeOnboarded; return &pt }(),
			},
			limit:   5,
			wantMin: 0,
			wantMax: 5,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			merchants, err := repo.SearchMerchantsOptimized(ctx, tt.searchQuery, tt.filters, tt.limit)
			require.NoError(t, err)
			assert.NotNil(t, merchants)
			assert.GreaterOrEqual(t, len(merchants), tt.wantMin)
			assert.LessOrEqual(t, len(merchants), tt.wantMax)
		})
	}
}

func TestOptimizedMerchantRepository_GetMerchantPortfolioDashboard(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test")
	}

	db := setupTestDB(t)
	defer db.Close()

	logger := log.New(os.Stdout, "TEST: ", log.LstdFlags)
	cache := NewMockCache()
	repo := NewOptimizedMerchantRepository(db, logger, cache)

	ctx := context.Background()

	// Test with a valid user ID (you may need to adjust this based on your test data)
	userID := "test-user-id"

	merchants, err := repo.GetMerchantPortfolioDashboard(ctx, userID)
	require.NoError(t, err)
	assert.NotNil(t, merchants)

	// Verify that merchants have the expected structure
	for _, merchant := range merchants {
		assert.NotEmpty(t, merchant.ID)
		assert.NotEmpty(t, merchant.Name)
		assert.NotEmpty(t, merchant.PortfolioType)
		assert.NotEmpty(t, merchant.RiskLevel)
	}
}

func TestOptimizedMerchantRepository_BulkUpdateMerchants(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test")
	}

	db := setupTestDB(t)
	defer db.Close()

	logger := log.New(os.Stdout, "TEST: ", log.LstdFlags)
	cache := NewMockCache()
	repo := NewOptimizedMerchantRepository(db, logger, cache)

	ctx := context.Background()

	// Create test updates
	updates := []models.MerchantUpdate{
		{
			ID:               "test-merchant-1",
			PortfolioTypeID:  "onboarded-type-id",
			RiskLevelID:      "low-risk-id",
			ComplianceStatus: "compliant",
			Status:           "active",
		},
		{
			ID:               "test-merchant-2",
			PortfolioTypeID:  "prospective-type-id",
			RiskLevelID:      "medium-risk-id",
			ComplianceStatus: "pending",
			Status:           "active",
		},
	}

	err := repo.BulkUpdateMerchants(ctx, updates)
	// Note: This might fail if the test merchants don't exist, which is expected
	if err != nil {
		t.Logf("Bulk update failed (expected if test data doesn't exist): %v", err)
	}
}

func TestOptimizedMerchantRepository_GetQueryPerformanceStats(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test")
	}

	db := setupTestDB(t)
	defer db.Close()

	logger := log.New(os.Stdout, "TEST: ", log.LstdFlags)
	cache := NewMockCache()
	repo := NewOptimizedMerchantRepository(db, logger, cache)

	ctx := context.Background()

	stats, err := repo.GetQueryPerformanceStats(ctx)
	require.NoError(t, err)
	assert.NotNil(t, stats)

	// Verify that we get some performance statistics
	t.Logf("Retrieved %d performance statistics", len(stats))
}

func TestOptimizedMerchantRepository_CleanupOldData(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test")
	}

	db := setupTestDB(t)
	defer db.Close()

	logger := log.New(os.Stdout, "TEST: ", log.LstdFlags)
	cache := NewMockCache()
	repo := NewOptimizedMerchantRepository(db, logger, cache)

	ctx := context.Background()

	err := repo.CleanupOldData(ctx)
	require.NoError(t, err)

	// Verify that cache was invalidated
	assert.Empty(t, cache.data, "Cache should be empty after cleanup")
}

func TestOptimizedMerchantRepository_CacheIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test")
	}

	db := setupTestDB(t)
	defer db.Close()

	logger := log.New(os.Stdout, "TEST: ", log.LstdFlags)
	cache := NewMockCache()
	repo := NewOptimizedMerchantRepository(db, logger, cache)

	ctx := context.Background()

	// First call should populate cache
	params := CursorPaginationParams{
		Limit:  5,
		Status: "active",
	}

	result1, err := repo.GetMerchantsCursorPaginated(ctx, params)
	require.NoError(t, err)

	// Second call should use cache
	result2, err := repo.GetMerchantsCursorPaginated(ctx, params)
	require.NoError(t, err)

	// Results should be the same
	assert.Equal(t, len(result1.Merchants), len(result2.Merchants))

	// Cache should contain the result
	cacheKey := repo.generateCacheKey("merchants_cursor", params)
	cached, err := cache.Get(ctx, cacheKey)
	require.NoError(t, err)
	assert.NotNil(t, cached)
}

func TestOptimizedMerchantRepository_GenerateCacheKey(t *testing.T) {
	repo := &OptimizedMerchantRepository{}

	tests := []struct {
		name     string
		prefix   string
		params   []interface{}
		expected string
	}{
		{
			name:     "simple key",
			prefix:   "test",
			params:   []interface{}{"param1", "param2"},
			expected: "test_param1_param2",
		},
		{
			name:     "with nil values",
			prefix:   "test",
			params:   []interface{}{"param1", nil, "param3"},
			expected: "test_param1_<nil>_param3",
		},
		{
			name:     "with complex types",
			prefix:   "test",
			params:   []interface{}{models.PortfolioTypeOnboarded, 123},
			expected: "test_onboarded_123",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			key := repo.generateCacheKey(tt.prefix, tt.params...)
			assert.Equal(t, tt.expected, key)
		})
	}
}

// Benchmark tests
func BenchmarkOptimizedMerchantRepository_GetMerchantsCursorPaginated(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark test")
	}

	db := setupTestDB(&testing.T{})
	defer db.Close()

	logger := log.New(os.Stdout, "BENCH: ", log.LstdFlags)
	cache := NewMockCache()
	repo := NewOptimizedMerchantRepository(db, logger, cache)

	ctx := context.Background()
	params := CursorPaginationParams{
		Limit:  50,
		Status: "active",
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := repo.GetMerchantsCursorPaginated(ctx, params)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkOptimizedMerchantRepository_SearchMerchantsOptimized(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark test")
	}

	db := setupTestDB(&testing.T{})
	defer db.Close()

	logger := log.New(os.Stdout, "BENCH: ", log.LstdFlags)
	cache := NewMockCache()
	repo := NewOptimizedMerchantRepository(db, logger, cache)

	ctx := context.Background()
	searchQuery := "test"
	limit := 20

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := repo.SearchMerchantsOptimized(ctx, searchQuery, nil, limit)
		if err != nil {
			b.Fatal(err)
		}
	}
}
