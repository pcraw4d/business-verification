package classification

import (
	"context"
	"math"
	"strings"
	"time"

	"github.com/pcraw4d/business-verification/internal/observability"
)

// ConfidenceRange represents a range of confidence scores for a specific method
type ConfidenceRange struct {
	MinConfidence float64 `json:"min_confidence"`
	MaxConfidence float64 `json:"max_confidence"`
	Method        string  `json:"method"`
	Description   string  `json:"description"`
}

// ConfidenceScoringEngine provides sophisticated industry confidence scoring
type ConfidenceScoringEngine struct {
	logger  *observability.Logger
	metrics *observability.Metrics

	// Configuration
	baseConfidenceWeight   float64
	keywordMatchWeight     float64
	descriptionMatchWeight float64
	businessTypeWeight     float64
	industryHintWeight     float64
	fuzzyMatchWeight       float64
	consistencyWeight      float64
	diversityWeight        float64
	popularityWeight       float64
	recencyWeight          float64
	validationWeight       float64

	// Method-based confidence ranges (as specified in PRD)
	methodConfidenceRanges map[string]ConfidenceRange

	// Industry-specific scoring data
	industryPopularity      map[string]float64
	industryValidationRates map[string]float64
	keywordReliability      map[string]float64

	// Dynamic confidence adjustment
	dynamicAdjuster *DynamicConfidenceAdjuster
}

// NewConfidenceScoringEngine creates a new confidence scoring engine
func NewConfidenceScoringEngine(logger *observability.Logger, metrics *observability.Metrics) *ConfidenceScoringEngine {
	engine := &ConfidenceScoringEngine{
		logger:  logger,
		metrics: metrics,

		// Configuration weights
		baseConfidenceWeight:   0.25,
		keywordMatchWeight:     0.20,
		descriptionMatchWeight: 0.15,
		businessTypeWeight:     0.10,
		industryHintWeight:     0.10,
		fuzzyMatchWeight:       0.05,
		consistencyWeight:      0.05,
		diversityWeight:        0.03,
		popularityWeight:       0.03,
		recencyWeight:          0.02,
		validationWeight:       0.02,

		// Initialize data maps
		industryPopularity:      make(map[string]float64),
		industryValidationRates: make(map[string]float64),
		keywordReliability:      make(map[string]float64),
	}

	// Initialize method-based confidence ranges (as specified in PRD)
	engine.initializeMethodConfidenceRanges()

	// Initialize dynamic confidence adjuster
	engine.dynamicAdjuster = NewDynamicConfidenceAdjuster(logger, metrics)

	return engine
}

// ConfidenceScore represents a comprehensive confidence score with breakdown
type ConfidenceScore struct {
	OverallScore       float64   `json:"overall_score"`
	BaseConfidence     float64   `json:"base_confidence"`
	KeywordScore       float64   `json:"keyword_score"`
	DescriptionScore   float64   `json:"description_score"`
	BusinessTypeScore  float64   `json:"business_type_score"`
	IndustryHintScore  float64   `json:"industry_hint_score"`
	FuzzyMatchScore    float64   `json:"fuzzy_match_score"`
	ConsistencyScore   float64   `json:"consistency_score"`
	DiversityScore     float64   `json:"diversity_score"`
	PopularityScore    float64   `json:"popularity_score"`
	RecencyScore       float64   `json:"recency_score"`
	ValidationScore    float64   `json:"validation_score"`
	ConfidenceLevel    string    `json:"confidence_level"`
	ReliabilityFactors []string  `json:"reliability_factors"`
	UncertaintyFactors []string  `json:"uncertainty_factors"`
	ScoringTimestamp   time.Time `json:"scoring_timestamp"`
	ScoringMethod      string    `json:"scoring_method"`
}

// CalculateConfidenceScore calculates comprehensive confidence score for an industry classification
func (c *ConfidenceScoringEngine) CalculateConfidenceScore(ctx context.Context, classification IndustryClassification, request *ClassificationRequest, allClassifications []IndustryClassification) *ConfidenceScore {
	start := time.Now()

	// Log scoring start
	if c.logger != nil {
		c.logger.WithComponent("confidence_scoring").LogBusinessEvent(ctx, "confidence_scoring_started", "", map[string]interface{}{
			"industry_code": classification.IndustryCode,
			"method":        classification.ClassificationMethod,
		})
	}

	// Calculate individual component scores
	baseConfidence := c.calculateBaseConfidence(classification)
	keywordScore := c.calculateKeywordScore(classification, request)
	descriptionScore := c.calculateDescriptionScore(classification, request)
	businessTypeScore := c.calculateBusinessTypeScore(classification, request)
	industryHintScore := c.calculateIndustryHintScore(classification, request)
	fuzzyMatchScore := c.calculateFuzzyMatchScore(classification, request)
	consistencyScore := c.calculateConsistencyScore(classification, allClassifications)
	diversityScore := c.calculateDiversityScore(classification, allClassifications)
	popularityScore := c.calculatePopularityScore(classification)
	recencyScore := c.calculateRecencyScore(classification)
	validationScore := c.calculateValidationScore(classification)

	// Calculate weighted overall score
	overallScore := (baseConfidence * c.baseConfidenceWeight) +
		(keywordScore * c.keywordMatchWeight) +
		(descriptionScore * c.descriptionMatchWeight) +
		(businessTypeScore * c.businessTypeWeight) +
		(industryHintScore * c.industryHintWeight) +
		(fuzzyMatchScore * c.fuzzyMatchWeight) +
		(consistencyScore * c.consistencyWeight) +
		(diversityScore * c.diversityWeight) +
		(popularityScore * c.popularityWeight) +
		(recencyScore * c.recencyWeight) +
		(validationScore * c.validationWeight)

	// Ensure score is within valid range
	overallScore = math.Max(0.0, math.Min(1.0, overallScore))

	// Apply dynamic confidence adjustment
	adjustedScore := c.applyDynamicConfidenceAdjustment(ctx, overallScore, classification, request)

	// Determine confidence level
	confidenceLevel := c.determineConfidenceLevel(adjustedScore)

	// Identify reliability and uncertainty factors
	reliabilityFactors := c.identifyReliabilityFactors(classification, request)
	uncertaintyFactors := c.identifyUncertaintyFactors(classification, request)

	// Create confidence score result
	result := &ConfidenceScore{
		OverallScore:       adjustedScore,
		BaseConfidence:     baseConfidence,
		KeywordScore:       keywordScore,
		DescriptionScore:   descriptionScore,
		BusinessTypeScore:  businessTypeScore,
		IndustryHintScore:  industryHintScore,
		FuzzyMatchScore:    fuzzyMatchScore,
		ConsistencyScore:   consistencyScore,
		DiversityScore:     diversityScore,
		PopularityScore:    popularityScore,
		RecencyScore:       recencyScore,
		ValidationScore:    validationScore,
		ConfidenceLevel:    confidenceLevel,
		ReliabilityFactors: reliabilityFactors,
		UncertaintyFactors: uncertaintyFactors,
		ScoringTimestamp:   time.Now(),
		ScoringMethod:      "enhanced_confidence_scoring",
	}

	// Log scoring completion
	if c.logger != nil {
		c.logger.WithComponent("confidence_scoring").LogBusinessEvent(ctx, "confidence_scoring_completed", "", map[string]interface{}{
			"industry_code":      classification.IndustryCode,
			"overall_score":      overallScore,
			"confidence_level":   confidenceLevel,
			"processing_time_ms": time.Since(start).Milliseconds(),
		})
	}

	// Record confidence scoring metrics
	c.RecordConfidenceScoringMetrics(ctx, classification, result)

	return result
}

// initializeMethodConfidenceRanges initializes the method-based confidence ranges as specified in PRD
func (c *ConfidenceScoringEngine) initializeMethodConfidenceRanges() {
	c.methodConfidenceRanges = map[string]ConfidenceRange{
		"website_analysis": {
			MinConfidence: 0.85,
			MaxConfidence: 0.95,
			Method:        "website_analysis",
			Description:   "Website analysis provides highest confidence due to direct content analysis",
		},
		"web_search_analysis": {
			MinConfidence: 0.75,
			MaxConfidence: 0.85,
			Method:        "web_search_analysis",
			Description:   "Web search analysis provides high confidence through external validation",
		},
		"keyword_based": {
			MinConfidence: 0.60,
			MaxConfidence: 0.75,
			Method:        "keyword_based",
			Description:   "Keyword-based classification provides moderate confidence",
		},
		"fuzzy_matching": {
			MinConfidence: 0.50,
			MaxConfidence: 0.70,
			Method:        "fuzzy_matching",
			Description:   "Fuzzy matching provides lower confidence due to approximate matching",
		},
		"crosswalk_mapping": {
			MinConfidence: 0.40,
			MaxConfidence: 0.60,
			Method:        "crosswalk_mapping",
			Description:   "Crosswalk mapping provides lowest confidence due to indirect mapping",
		},
		"search_analysis": {
			MinConfidence: 0.75,
			MaxConfidence: 0.85,
			Method:        "search_analysis",
			Description:   "Search-based analysis provides high confidence through external validation",
		},
		"search_result_analysis": {
			MinConfidence: 0.70,
			MaxConfidence: 0.80,
			Method:        "search_result_analysis",
			Description:   "Search result analysis provides good confidence through result validation",
		},
	}
}

// calculateBaseConfidence calculates the base confidence score using method-based ranges
func (c *ConfidenceScoringEngine) calculateBaseConfidence(classification IndustryClassification) float64 {
	// Get the confidence range for the classification method
	confidenceRange, exists := c.methodConfidenceRanges[classification.ClassificationMethod]
	if !exists {
		// Default range for unknown methods
		confidenceRange = ConfidenceRange{
			MinConfidence: 0.50,
			MaxConfidence: 0.70,
			Method:        classification.ClassificationMethod,
			Description:   "Default confidence range for unknown method",
		}
	}

	// Calculate the base score within the method's confidence range
	rangeSize := confidenceRange.MaxConfidence - confidenceRange.MinConfidence
	baseScore := confidenceRange.MinConfidence + (rangeSize * classification.ConfidenceScore)

	// Ensure the score is within the valid range
	baseScore = math.Max(confidenceRange.MinConfidence, math.Min(confidenceRange.MaxConfidence, baseScore))

	// Log the method-based confidence calculation
	if c.logger != nil {
		c.logger.WithComponent("confidence_scoring").Debug("method_based_confidence_calculation", map[string]interface{}{
			"method":         classification.ClassificationMethod,
			"min_confidence": confidenceRange.MinConfidence,
			"max_confidence": confidenceRange.MaxConfidence,
			"original_score": classification.ConfidenceScore,
			"adjusted_score": baseScore,
			"description":    confidenceRange.Description,
		})
	}

	return baseScore
}

// calculateKeywordScore calculates keyword-based confidence score
func (c *ConfidenceScoringEngine) calculateKeywordScore(classification IndustryClassification, request *ClassificationRequest) float64 {
	if request.Keywords == "" || len(classification.Keywords) == 0 {
		return 0.0
	}

	// Extract keywords from request
	requestKeywords := strings.Split(strings.ToLower(request.Keywords), ",")
	for i, keyword := range requestKeywords {
		requestKeywords[i] = strings.TrimSpace(keyword)
	}

	// Calculate keyword overlap
	matches := 0
	totalRequestKeywords := len(requestKeywords)

	for _, requestKeyword := range requestKeywords {
		for _, classificationKeyword := range classification.Keywords {
			if strings.Contains(strings.ToLower(classificationKeyword), requestKeyword) ||
				strings.Contains(requestKeyword, strings.ToLower(classificationKeyword)) {
				matches++
				break
			}
		}
	}

	if totalRequestKeywords == 0 {
		return 0.0
	}

	// Calculate base keyword score
	keywordScore := float64(matches) / float64(totalRequestKeywords)

	// Apply keyword reliability factor
	reliabilityFactor := c.getKeywordReliabilityFactor(classification.IndustryCode)
	keywordScore *= reliabilityFactor

	return keywordScore
}

// calculateDescriptionScore calculates description-based confidence score
func (c *ConfidenceScoringEngine) calculateDescriptionScore(classification IndustryClassification, request *ClassificationRequest) float64 {
	if request.Description == "" {
		return 0.0
	}

	// Calculate text similarity between description and industry keywords
	description := strings.ToLower(request.Description)
	keywordMatches := 0
	totalKeywords := len(classification.Keywords)

	if totalKeywords == 0 {
		return 0.0
	}

	for _, keyword := range classification.Keywords {
		if strings.Contains(description, strings.ToLower(keyword)) {
			keywordMatches++
		}
	}

	// Calculate base description score
	descriptionScore := float64(keywordMatches) / float64(totalKeywords)

	// Apply length factor (longer descriptions get higher scores)
	lengthFactor := math.Min(1.0, float64(len(description))/100.0)
	descriptionScore *= (0.7 + 0.3*lengthFactor)

	return descriptionScore
}

// calculateBusinessTypeScore calculates business type-based confidence score
func (c *ConfidenceScoringEngine) calculateBusinessTypeScore(classification IndustryClassification, request *ClassificationRequest) float64 {
	if request.BusinessType == "" {
		return 0.0
	}

	// Map business types to confidence scores
	businessTypeScores := map[string]float64{
		"corporation":         0.8,
		"llc":                 0.7,
		"partnership":         0.6,
		"sole_proprietorship": 0.5,
		"nonprofit":           0.9,
		"government":          0.9,
		"cooperative":         0.6,
	}

	businessType := strings.ToLower(request.BusinessType)
	if score, exists := businessTypeScores[businessType]; exists {
		return score
	}

	// Default score for unknown business types
	return 0.5
}

// calculateIndustryHintScore calculates industry hint-based confidence score
func (c *ConfidenceScoringEngine) calculateIndustryHintScore(classification IndustryClassification, request *ClassificationRequest) float64 {
	if request.Industry == "" {
		return 0.0
	}

	// Check if the provided industry hint matches the classification
	industryHint := strings.ToLower(request.Industry)
	industryName := strings.ToLower(classification.IndustryName)

	// Direct match
	if strings.Contains(industryName, industryHint) || strings.Contains(industryHint, industryName) {
		return 0.9
	}

	// Check keyword matches
	for _, keyword := range classification.Keywords {
		if strings.Contains(industryHint, strings.ToLower(keyword)) {
			return 0.7
		}
	}

	// No match
	return 0.0
}

// calculateFuzzyMatchScore calculates fuzzy match-based confidence score
func (c *ConfidenceScoringEngine) calculateFuzzyMatchScore(classification IndustryClassification, request *ClassificationRequest) float64 {
	if request.BusinessName == "" {
		return 0.0
	}

	// Calculate similarity between business name and industry name
	businessName := strings.ToLower(request.BusinessName)
	industryName := strings.ToLower(classification.IndustryName)

	// Simple similarity calculation (can be enhanced with more sophisticated algorithms)
	similarity := c.calculateStringSimilarity(businessName, industryName)

	// Apply fuzzy match penalty
	fuzzyScore := similarity * 0.8

	return fuzzyScore
}

// calculateConsistencyScore calculates consistency with other classifications
func (c *ConfidenceScoringEngine) calculateConsistencyScore(classification IndustryClassification, allClassifications []IndustryClassification) float64 {
	if len(allClassifications) < 2 {
		return 1.0
	}

	// Count related classifications
	relatedCount := 0
	totalComparisons := 0

	for _, other := range allClassifications {
		if other.IndustryCode == classification.IndustryCode {
			continue
		}

		if c.areIndustriesRelated(classification, other) {
			relatedCount++
		}
		totalComparisons++
	}

	if totalComparisons == 0 {
		return 1.0
	}

	return float64(relatedCount) / float64(totalComparisons)
}

// calculateDiversityScore calculates diversity score
func (c *ConfidenceScoringEngine) calculateDiversityScore(classification IndustryClassification, allClassifications []IndustryClassification) float64 {
	if len(allClassifications) < 2 {
		return 1.0
	}

	// Count unique major categories
	categories := make(map[string]bool)
	for _, other := range allClassifications {
		if len(other.IndustryCode) >= 2 {
			categories[other.IndustryCode[:2]] = true
		}
	}

	// Higher diversity means this classification is more unique
	diversityRatio := float64(len(categories)) / float64(len(allClassifications))
	return diversityRatio
}

// calculatePopularityScore calculates industry popularity score
func (c *ConfidenceScoringEngine) calculatePopularityScore(classification IndustryClassification) float64 {
	if popularity, exists := c.industryPopularity[classification.IndustryCode]; exists {
		return popularity
	}

	// Default to moderate popularity
	return 0.5
}

// calculateRecencyScore calculates recency score
func (c *ConfidenceScoringEngine) calculateRecencyScore(classification IndustryClassification) float64 {
	// This could be based on when the industry classification was last updated
	// For now, return a default score
	return 0.8
}

// calculateValidationScore calculates validation score
func (c *ConfidenceScoringEngine) calculateValidationScore(classification IndustryClassification) float64 {
	if validationRate, exists := c.industryValidationRates[classification.IndustryCode]; exists {
		return validationRate
	}

	// Default validation rate
	return 0.7
}

// determineConfidenceLevel determines the confidence level based on overall score
func (c *ConfidenceScoringEngine) determineConfidenceLevel(overallScore float64) string {
	switch {
	case overallScore >= 0.9:
		return "very_high"
	case overallScore >= 0.8:
		return "high"
	case overallScore >= 0.7:
		return "medium_high"
	case overallScore >= 0.6:
		return "medium"
	case overallScore >= 0.5:
		return "medium_low"
	case overallScore >= 0.3:
		return "low"
	default:
		return "very_low"
	}
}

// identifyReliabilityFactors identifies factors that increase confidence
func (c *ConfidenceScoringEngine) identifyReliabilityFactors(classification IndustryClassification, request *ClassificationRequest) []string {
	var factors []string

	// Check for strong keyword matches
	if request.Keywords != "" && len(classification.Keywords) > 0 {
		factors = append(factors, "strong_keyword_matches")
	}

	// Check for detailed description
	if request.Description != "" && len(request.Description) > 50 {
		factors = append(factors, "detailed_description")
	}

	// Check for specific business type
	if request.BusinessType != "" {
		factors = append(factors, "specific_business_type")
	}

	// Check for industry hint
	if request.Industry != "" {
		factors = append(factors, "industry_hint_provided")
	}

	// Check for high base confidence
	if classification.ConfidenceScore > 0.8 {
		factors = append(factors, "high_base_confidence")
	}

	// Check for reliable classification method
	if classification.ClassificationMethod == "keyword_match" || classification.ClassificationMethod == "description_match" {
		factors = append(factors, "reliable_classification_method")
	}

	return factors
}

// identifyUncertaintyFactors identifies factors that decrease confidence
func (c *ConfidenceScoringEngine) identifyUncertaintyFactors(classification IndustryClassification, request *ClassificationRequest) []string {
	var factors []string

	// Check for missing keywords
	if request.Keywords == "" {
		factors = append(factors, "no_keywords_provided")
	}

	// Check for missing description
	if request.Description == "" {
		factors = append(factors, "no_description_provided")
	}

	// Check for low base confidence
	if classification.ConfidenceScore < 0.5 {
		factors = append(factors, "low_base_confidence")
	}

	// Check for unreliable classification method
	if classification.ClassificationMethod == "fuzzy_match" {
		factors = append(factors, "fuzzy_match_method")
	}

	// Check for generic business type
	if request.BusinessType == "" {
		factors = append(factors, "no_business_type_specified")
	}

	return factors
}

// calculateStringSimilarity calculates similarity between two strings
func (c *ConfidenceScoringEngine) calculateStringSimilarity(str1, str2 string) float64 {
	// Simple Jaccard similarity implementation
	words1 := strings.Fields(str1)
	words2 := strings.Fields(str2)

	if len(words1) == 0 && len(words2) == 0 {
		return 1.0
	}

	// Create word sets
	set1 := make(map[string]bool)
	set2 := make(map[string]bool)

	for _, word := range words1 {
		set1[word] = true
	}
	for _, word := range words2 {
		set2[word] = true
	}

	// Calculate intersection
	intersection := 0
	for word := range set1 {
		if set2[word] {
			intersection++
		}
	}

	// Calculate union
	union := len(set1) + len(set2) - intersection

	if union == 0 {
		return 0.0
	}

	return float64(intersection) / float64(union)
}

// areIndustriesRelated checks if two industries are related
func (c *ConfidenceScoringEngine) areIndustriesRelated(industry1, industry2 IndustryClassification) bool {
	// Check if industries are in the same major category
	if len(industry1.IndustryCode) >= 2 && len(industry2.IndustryCode) >= 2 {
		if industry1.IndustryCode[:2] == industry2.IndustryCode[:2] {
			return true
		}
	}

	// Check for keyword overlap
	if len(industry1.Keywords) > 0 && len(industry2.Keywords) > 0 {
		overlap := c.calculateKeywordOverlap(industry1.Keywords, industry2.Keywords)
		return overlap > 0.3
	}

	return false
}

// calculateKeywordOverlap calculates overlap between keyword sets
func (c *ConfidenceScoringEngine) calculateKeywordOverlap(keywords1, keywords2 []string) float64 {
	if len(keywords1) == 0 || len(keywords2) == 0 {
		return 0.0
	}

	// Create keyword sets
	set1 := make(map[string]bool)
	set2 := make(map[string]bool)

	for _, keyword := range keywords1 {
		set1[strings.ToLower(keyword)] = true
	}
	for _, keyword := range keywords2 {
		set2[strings.ToLower(keyword)] = true
	}

	// Calculate intersection
	intersection := 0
	for keyword := range set1 {
		if set2[keyword] {
			intersection++
		}
	}

	// Calculate union
	union := len(set1) + len(set2) - intersection

	if union == 0 {
		return 0.0
	}

	return float64(intersection) / float64(union)
}

// getKeywordReliabilityFactor gets the reliability factor for keywords in an industry
func (c *ConfidenceScoringEngine) getKeywordReliabilityFactor(industryCode string) float64 {
	if reliability, exists := c.keywordReliability[industryCode]; exists {
		return reliability
	}

	// Default reliability factor
	return 0.8
}

// SetIndustryData sets industry-specific scoring data
func (c *ConfidenceScoringEngine) SetIndustryData(popularity, validationRates, keywordReliability map[string]float64) {
	c.industryPopularity = popularity
	c.industryValidationRates = validationRates
	c.keywordReliability = keywordReliability
}

// SetWeights allows customization of scoring weights
func (c *ConfidenceScoringEngine) SetWeights(weights map[string]float64) {
	if baseConfidence, exists := weights["base_confidence"]; exists {
		c.baseConfidenceWeight = baseConfidence
	}
	if keywordMatch, exists := weights["keyword_match"]; exists {
		c.keywordMatchWeight = keywordMatch
	}
	if descriptionMatch, exists := weights["description_match"]; exists {
		c.descriptionMatchWeight = descriptionMatch
	}
	if businessType, exists := weights["business_type"]; exists {
		c.businessTypeWeight = businessType
	}
	if industryHint, exists := weights["industry_hint"]; exists {
		c.industryHintWeight = industryHint
	}
	if fuzzyMatch, exists := weights["fuzzy_match"]; exists {
		c.fuzzyMatchWeight = fuzzyMatch
	}
	if consistency, exists := weights["consistency"]; exists {
		c.consistencyWeight = consistency
	}
	if diversity, exists := weights["diversity"]; exists {
		c.diversityWeight = diversity
	}
	if popularity, exists := weights["popularity"]; exists {
		c.popularityWeight = popularity
	}
	if recency, exists := weights["recency"]; exists {
		c.recencyWeight = recency
	}
	if validation, exists := weights["validation"]; exists {
		c.validationWeight = validation
	}
}

// GetWeights returns current scoring weights
func (c *ConfidenceScoringEngine) GetWeights() map[string]float64 {
	return map[string]float64{
		"base_confidence":   c.baseConfidenceWeight,
		"keyword_match":     c.keywordMatchWeight,
		"description_match": c.descriptionMatchWeight,
		"business_type":     c.businessTypeWeight,
		"industry_hint":     c.industryHintWeight,
		"fuzzy_match":       c.fuzzyMatchWeight,
		"consistency":       c.consistencyWeight,
		"diversity":         c.diversityWeight,
		"popularity":        c.popularityWeight,
		"recency":           c.recencyWeight,
		"validation":        c.validationWeight,
	}
}

// ValidateConfidenceRange validates that a confidence score is within the expected range for its method
func (c *ConfidenceScoringEngine) ValidateConfidenceRange(classification IndustryClassification) (bool, string) {
	confidenceRange, exists := c.methodConfidenceRanges[classification.ClassificationMethod]
	if !exists {
		return false, "unknown_classification_method"
	}

	if classification.ConfidenceScore < confidenceRange.MinConfidence {
		return false, "below_minimum_confidence"
	}

	if classification.ConfidenceScore > confidenceRange.MaxConfidence {
		return false, "above_maximum_confidence"
	}

	return true, "within_valid_range"
}

// GetMethodConfidenceRange returns the confidence range for a specific method
func (c *ConfidenceScoringEngine) GetMethodConfidenceRange(method string) (ConfidenceRange, bool) {
	confidenceRange, exists := c.methodConfidenceRanges[method]
	return confidenceRange, exists
}

// GetAllMethodConfidenceRanges returns all method confidence ranges
func (c *ConfidenceScoringEngine) GetAllMethodConfidenceRanges() map[string]ConfidenceRange {
	return c.methodConfidenceRanges
}

// UpdateMethodConfidenceRange updates the confidence range for a specific method
func (c *ConfidenceScoringEngine) UpdateMethodConfidenceRange(method string, minConfidence, maxConfidence float64, description string) {
	c.methodConfidenceRanges[method] = ConfidenceRange{
		MinConfidence: minConfidence,
		MaxConfidence: maxConfidence,
		Method:        method,
		Description:   description,
	}

	// Log the update
	if c.logger != nil {
		c.logger.WithComponent("confidence_scoring").Info("method_confidence_range_updated", map[string]interface{}{
			"method":         method,
			"min_confidence": minConfidence,
			"max_confidence": maxConfidence,
			"description":    description,
		})
	}
}

// GetConfidenceScoringMetrics returns comprehensive confidence scoring metrics
func (c *ConfidenceScoringEngine) GetConfidenceScoringMetrics() map[string]interface{} {
	metrics := map[string]interface{}{
		"method_ranges":           c.methodConfidenceRanges,
		"scoring_weights":         c.GetWeights(),
		"total_methods_supported": len(c.methodConfidenceRanges),
		"supported_methods":       make([]string, 0, len(c.methodConfidenceRanges)),
	}

	// Add supported methods list
	for method := range c.methodConfidenceRanges {
		metrics["supported_methods"] = append(metrics["supported_methods"].([]string), method)
	}

	return metrics
}

// RecordConfidenceScoringMetrics records metrics for confidence scoring
func (c *ConfidenceScoringEngine) RecordConfidenceScoringMetrics(ctx context.Context, classification IndustryClassification, confidenceScore *ConfidenceScore) {
	if c.metrics == nil {
		return
	}

	// Record business classification with confidence level
	c.metrics.RecordBusinessClassification("success", confidenceScore.ConfidenceLevel)

	// Record classification duration (using a default duration since we don't have timing info here)
	c.metrics.RecordClassificationDuration(classification.ClassificationMethod, time.Millisecond*100)

	// Log confidence scoring metrics
	if c.logger != nil {
		// Record confidence range validation
		isValid, validationReason := c.ValidateConfidenceRange(classification)

		c.logger.WithComponent("confidence_scoring").Info("confidence_scoring_metrics_recorded", map[string]interface{}{
			"method":            classification.ClassificationMethod,
			"confidence_score":  confidenceScore.OverallScore,
			"confidence_level":  confidenceScore.ConfidenceLevel,
			"is_valid_range":    isValid,
			"validation_reason": validationReason,
			"min_confidence":    c.methodConfidenceRanges[classification.ClassificationMethod].MinConfidence,
			"max_confidence":    c.methodConfidenceRanges[classification.ClassificationMethod].MaxConfidence,
		})
	}
}

// applyDynamicConfidenceAdjustment applies dynamic confidence adjustment based on various factors
func (c *ConfidenceScoringEngine) applyDynamicConfidenceAdjustment(ctx context.Context, baseConfidence float64, classification IndustryClassification, request *ClassificationRequest) float64 {
	// Create adjustment factors based on available data
	adjustmentFactors := &ConfidenceAdjustmentFactors{
		ContentQuality:    c.extractContentQuality(classification, request),
		GeographicRegion:  c.extractGeographicRegion(classification, request),
		IndustryFactors:   c.extractIndustryFactors(classification),
		BusinessSize:      c.extractBusinessSize(request),
		BusinessAge:       c.extractBusinessAge(request),
		DataSourceQuality: c.extractDataSourceQuality(classification),
		CrossValidation:   c.extractCrossValidation(classification, request),
		LastUpdated:       c.extractLastUpdated(classification),
	}

	// Apply dynamic adjustment
	adjustedConfidence := c.dynamicAdjuster.AdjustConfidence(ctx, baseConfidence, adjustmentFactors)

	// Log the adjustment
	if c.logger != nil {
		c.logger.WithComponent("confidence_scoring").LogBusinessEvent(ctx, "dynamic_confidence_adjustment_applied", "", map[string]interface{}{
			"base_confidence":       baseConfidence,
			"adjusted_confidence":   adjustedConfidence,
			"adjustment_delta":      adjustedConfidence - baseConfidence,
			"industry_code":         classification.IndustryCode,
			"classification_method": classification.ClassificationMethod,
		})
	}

	return adjustedConfidence
}

// extractContentQuality extracts content quality factors from classification and request
func (c *ConfidenceScoringEngine) extractContentQuality(classification IndustryClassification, request *ClassificationRequest) *ContentQuality {
	// Default content quality assessment
	quality := &ContentQuality{
		Completeness:      0.8, // Default completeness
		Relevance:         0.8, // Default relevance
		Freshness:         0.8, // Default freshness
		Accuracy:          0.8, // Default accuracy
		Consistency:       0.8, // Default consistency
		SourceReliability: 0.8, // Default source reliability
	}

	// Adjust based on classification method
	switch classification.ClassificationMethod {
	case "website_analysis":
		quality.Completeness = 0.9
		quality.Relevance = 0.9
		quality.SourceReliability = 0.9
	case "web_search_analysis":
		quality.Completeness = 0.8
		quality.Relevance = 0.8
		quality.SourceReliability = 0.8
	case "keyword_based":
		quality.Completeness = 0.7
		quality.Relevance = 0.7
		quality.SourceReliability = 0.7
	}

	// Adjust based on request data quality
	if request != nil && request.BusinessName != "" {
		quality.Completeness += 0.1
	}
	if request != nil && request.Description != "" {
		quality.Relevance += 0.1
	}

	return quality
}

// extractGeographicRegion extracts geographic region information
func (c *ConfidenceScoringEngine) extractGeographicRegion(classification IndustryClassification, request *ClassificationRequest) *GeographicRegionData {
	region := &GeographicRegionData{
		Country:     "US", // Default to US
		State:       "",
		City:        "",
		Region:      "",
		Confidence:  0.8,
		DataQuality: 0.8,
	}

	// Extract from request if available
	// Note: Geographic fields are not available in the current ClassificationRequest structure
	// This would need to be enhanced when geographic fields are added to the request

	return region
}

// extractIndustryFactors extracts industry-specific factors
func (c *ConfidenceScoringEngine) extractIndustryFactors(classification IndustryClassification) *IndustrySpecificFactors {
	factors := &IndustrySpecificFactors{
		IndustryCode:     classification.IndustryCode,
		IndustryCategory: classification.IndustryName, // Use IndustryName as category
		CodeDensity:      0.5,                         // Default code density
		ValidationRate:   0.8,                         // Default validation rate
		Popularity:       0.5,                         // Default popularity
		Complexity:       0.5,                         // Default complexity
	}

	// Get industry-specific data if available
	if validationRate, exists := c.industryValidationRates[classification.IndustryCode]; exists {
		factors.ValidationRate = validationRate
	}
	if popularity, exists := c.industryPopularity[classification.IndustryCode]; exists {
		factors.Popularity = popularity
	}

	return factors
}

// extractBusinessSize extracts business size information
func (c *ConfidenceScoringEngine) extractBusinessSize(request *ClassificationRequest) string {
	if request == nil {
		return "unknown"
	}

	// Note: EmployeeCount is not available in the current ClassificationRequest structure
	// This would need to be enhanced when employee count is added to the request
	// For now, return unknown as default

	return "unknown"
}

// extractBusinessAge extracts business age information
func (c *ConfidenceScoringEngine) extractBusinessAge(request *ClassificationRequest) int {
	if request == nil {
		return 0
	}

	// Extract business age from request
	// This would need to be implemented based on available data
	return 0 // Default to unknown age
}

// extractDataSourceQuality extracts data source quality information
func (c *ConfidenceScoringEngine) extractDataSourceQuality(classification IndustryClassification) float64 {
	// Default data source quality based on classification method
	switch classification.ClassificationMethod {
	case "website_analysis":
		return 0.9
	case "web_search_analysis":
		return 0.8
	case "keyword_based":
		return 0.7
	case "fuzzy_matching":
		return 0.6
	case "crosswalk_mapping":
		return 0.5
	default:
		return 0.7
	}
}

// extractCrossValidation extracts cross-validation information
func (c *ConfidenceScoringEngine) extractCrossValidation(classification IndustryClassification, request *ClassificationRequest) float64 {
	// Default cross-validation score
	// This would be enhanced based on actual cross-validation results
	return 0.8
}

// extractLastUpdated extracts last updated information
func (c *ConfidenceScoringEngine) extractLastUpdated(classification IndustryClassification) time.Time {
	// Return current time as default
	// This would be enhanced based on actual data freshness information
	return time.Now()
}
