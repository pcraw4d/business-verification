package classification

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/pcraw4d/business-verification/internal/observability"
)

// AccuracyMetricType represents different types of accuracy metrics
type AccuracyMetricType string

const (
	AccuracyMetricTypeOverall      AccuracyMetricType = "overall"
	AccuracyMetricTypeIndustry     AccuracyMetricType = "industry"
	AccuracyMetricTypeBusinessType AccuracyMetricType = "business_type"
	AccuracyMetricTypeRegion       AccuracyMetricType = "region"
	AccuracyMetricTypeConfidence   AccuracyMetricType = "confidence"
	AccuracyMetricTypeTimeRange    AccuracyMetricType = "time_range"
)

// AccuracyThreshold represents accuracy thresholds for alerting
type AccuracyThreshold struct {
	MetricType    AccuracyMetricType `json:"metric_type"`
	Threshold     float64            `json:"threshold"`
	Severity      string             `json:"severity"` // "low", "medium", "high", "critical"
	AlertEnabled  bool               `json:"alert_enabled"`
	Description   string             `json:"description"`
	LastTriggered *time.Time         `json:"last_triggered,omitempty"`
}

// AccuracyReport represents an accuracy report for a specific dimension
type AccuracyReport struct {
	MetricType               AccuracyMetricType     `json:"metric_type"`
	Dimension                string                 `json:"dimension"`
	TotalClassifications     int                    `json:"total_classifications"`
	CorrectClassifications   int                    `json:"correct_classifications"`
	IncorrectClassifications int                    `json:"incorrect_classifications"`
	AccuracyScore            float64                `json:"accuracy_score"`
	ConfidenceScore          float64                `json:"confidence_score"`
	ProcessingTime           time.Duration          `json:"processing_time"`
	TimeRange                time.Duration          `json:"time_range"`
	LastUpdated              time.Time              `json:"last_updated"`
	Metadata                 map[string]interface{} `json:"metadata"`
}

// AccuracyAlert represents an accuracy alert
type AccuracyAlert struct {
	ID             string                 `json:"id"`
	MetricType     AccuracyMetricType     `json:"metric_type"`
	Dimension      string                 `json:"dimension"`
	Threshold      float64                `json:"threshold"`
	CurrentValue   float64                `json:"current_value"`
	Severity       string                 `json:"severity"`
	Message        string                 `json:"message"`
	Status         string                 `json:"status"` // "active", "acknowledged", "resolved"
	CreatedAt      time.Time              `json:"created_at"`
	AcknowledgedAt *time.Time             `json:"acknowledged_at,omitempty"`
	ResolvedAt     *time.Time             `json:"resolved_at,omitempty"`
	Metadata       map[string]interface{} `json:"metadata"`
}

// AccuracyValidator provides automated accuracy validation capabilities
type AccuracyValidator struct {
	logger  *observability.Logger
	metrics *observability.Metrics

	// Accuracy tracking
	accuracyReports map[string]*AccuracyReport
	reportsMutex    sync.RWMutex

	// Alerting
	alerts          map[string]*AccuracyAlert
	alertsMutex     sync.RWMutex
	thresholds      map[string]*AccuracyThreshold
	thresholdsMutex sync.RWMutex

	// Performance tracking
	performanceMetrics map[string]float64
	metricsMutex       sync.RWMutex

	// Configuration
	enableAutomatedValidation bool
	validationInterval        time.Duration
	alertRetentionDays        int
	maxReportsPerDimension    int
}

// NewAccuracyValidator creates a new accuracy validator
func NewAccuracyValidator(logger *observability.Logger, metrics *observability.Metrics) *AccuracyValidator {
	validator := &AccuracyValidator{
		logger:  logger,
		metrics: metrics,

		// Initialize storage
		accuracyReports:    make(map[string]*AccuracyReport),
		alerts:             make(map[string]*AccuracyAlert),
		thresholds:         make(map[string]*AccuracyThreshold),
		performanceMetrics: make(map[string]float64),

		// Configuration
		enableAutomatedValidation: true,
		validationInterval:        time.Hour,
		alertRetentionDays:        7,
		maxReportsPerDimension:    100,
	}

	// Initialize default thresholds
	validator.initializeDefaultThresholds()

	// Start validation loop
	go validator.startValidationLoop()

	return validator
}

// ValidateAccuracy performs automated accuracy validation
func (av *AccuracyValidator) ValidateAccuracy(ctx context.Context, classifications []IndustryClassification, feedback []*Feedback) (*AccuracyReport, error) {
	start := time.Now()

	// Log validation start
	if av.logger != nil {
		av.logger.WithComponent("accuracy_validator").LogBusinessEvent(ctx, "accuracy_validation_started", "", map[string]interface{}{
			"classifications": len(classifications),
			"feedback":        len(feedback),
		})
	}

	// Calculate overall accuracy
	overallReport := av.calculateOverallAccuracy(classifications, feedback)

	// Calculate accuracy by dimensions
	industryReports := av.calculateAccuracyByIndustry(classifications, feedback)
	businessTypeReports := av.calculateAccuracyByBusinessType(classifications, feedback)
	regionReports := av.calculateAccuracyByRegion(classifications, feedback)
	confidenceReports := av.calculateAccuracyByConfidence(classifications, feedback)

	// Store reports
	av.storeAccuracyReports(overallReport, industryReports, businessTypeReports, regionReports, confidenceReports)

	// Check thresholds and generate alerts
	alerts := av.checkThresholdsAndGenerateAlerts(overallReport, industryReports, businessTypeReports, regionReports, confidenceReports)

	// Log validation completion
	if av.logger != nil {
		av.logger.WithComponent("accuracy_validator").LogBusinessEvent(ctx, "accuracy_validation_completed", "", map[string]interface{}{
			"overall_accuracy":   overallReport.AccuracyScore,
			"alerts_generated":   len(alerts),
			"processing_time_ms": time.Since(start).Milliseconds(),
		})
	}

	// Record metrics
	av.RecordValidationMetrics(ctx, overallReport, len(alerts), time.Since(start))

	return overallReport, nil
}

// GetAccuracyReport retrieves an accuracy report by metric type and dimension
func (av *AccuracyValidator) GetAccuracyReport(ctx context.Context, metricType AccuracyMetricType, dimension string) (*AccuracyReport, error) {
	av.reportsMutex.RLock()
	defer av.reportsMutex.RUnlock()

	key := av.generateReportKey(metricType, dimension)
	report, exists := av.accuracyReports[key]
	if !exists {
		return nil, fmt.Errorf("accuracy report not found for %s: %s", metricType, dimension)
	}

	return report, nil
}

// ListAccuracyReports returns accuracy reports with optional filtering
func (av *AccuracyValidator) ListAccuracyReports(ctx context.Context, filters map[string]interface{}) ([]*AccuracyReport, error) {
	av.reportsMutex.RLock()
	defer av.reportsMutex.RUnlock()

	var reports []*AccuracyReport
	for _, report := range av.accuracyReports {
		if av.matchesReportFilters(report, filters) {
			reports = append(reports, report)
		}
	}

	return reports, nil
}

// GetAccuracyAlerts returns accuracy alerts with optional filtering
func (av *AccuracyValidator) GetAccuracyAlerts(ctx context.Context, filters map[string]interface{}) ([]*AccuracyAlert, error) {
	av.alertsMutex.RLock()
	defer av.alertsMutex.RUnlock()

	var alerts []*AccuracyAlert
	for _, alert := range av.alerts {
		if av.matchesAlertFilters(alert, filters) {
			alerts = append(alerts, alert)
		}
	}

	return alerts, nil
}

// UpdateAlertStatus updates the status of an accuracy alert
func (av *AccuracyValidator) UpdateAlertStatus(ctx context.Context, alertID string, status string) error {
	av.alertsMutex.Lock()
	defer av.alertsMutex.Unlock()

	alert, exists := av.alerts[alertID]
	if !exists {
		return fmt.Errorf("alert not found: %s", alertID)
	}

	alert.Status = status
	switch status {
	case "acknowledged":
		now := time.Now()
		alert.AcknowledgedAt = &now
	case "resolved":
		now := time.Now()
		alert.ResolvedAt = &now
	}

	// Log alert status update
	if av.logger != nil {
		av.logger.WithComponent("accuracy_validator").LogBusinessEvent(ctx, "alert_status_updated", alertID, map[string]interface{}{
			"new_status": status,
		})
	}

	return nil
}

// AddAccuracyThreshold adds a new accuracy threshold
func (av *AccuracyValidator) AddAccuracyThreshold(ctx context.Context, threshold *AccuracyThreshold) error {
	av.thresholdsMutex.Lock()
	defer av.thresholdsMutex.Unlock()

	key := av.generateThresholdKey(threshold.MetricType, threshold.Severity)
	av.thresholds[key] = threshold

	// Log threshold addition
	if av.logger != nil {
		av.logger.WithComponent("accuracy_validator").LogBusinessEvent(ctx, "accuracy_threshold_added", key, map[string]interface{}{
			"metric_type": string(threshold.MetricType),
			"threshold":   threshold.Threshold,
			"severity":    threshold.Severity,
		})
	}

	return nil
}

// GetValidatorStats returns statistics about the accuracy validator
func (av *AccuracyValidator) GetValidatorStats() map[string]interface{} {
	av.reportsMutex.RLock()
	defer av.reportsMutex.RUnlock()
	av.alertsMutex.RLock()
	defer av.alertsMutex.RUnlock()
	av.thresholdsMutex.RLock()
	defer av.thresholdsMutex.RUnlock()

	stats := map[string]interface{}{
		"total_reports":                len(av.accuracyReports),
		"total_alerts":                 len(av.alerts),
		"total_thresholds":             len(av.thresholds),
		"automated_validation":         av.enableAutomatedValidation,
		"validation_interval":          av.validationInterval.String(),
		"alert_retention_days":         av.alertRetentionDays,
		"max_reports_per_dimension":    av.maxReportsPerDimension,
		"metric_types":                 make(map[string]int),
		"alert_status_breakdown":       make(map[string]int),
		"threshold_severity_breakdown": make(map[string]int),
	}

	// Calculate breakdowns
	for _, report := range av.accuracyReports {
		stats["metric_types"].(map[string]int)[string(report.MetricType)]++
	}

	for _, alert := range av.alerts {
		stats["alert_status_breakdown"].(map[string]int)[alert.Status]++
	}

	for _, threshold := range av.thresholds {
		stats["threshold_severity_breakdown"].(map[string]int)[threshold.Severity]++
	}

	return stats
}

// Helper methods

// calculateOverallAccuracy calculates overall accuracy metrics
func (av *AccuracyValidator) calculateOverallAccuracy(classifications []IndustryClassification, feedback []*Feedback) *AccuracyReport {
	report := &AccuracyReport{
		MetricType:  AccuracyMetricTypeOverall,
		Dimension:   "overall",
		LastUpdated: time.Now(),
		Metadata:    make(map[string]interface{}),
	}

	// Calculate from classifications
	for _, classification := range classifications {
		report.TotalClassifications++
		// Assume high confidence classifications are more likely to be correct
		if classification.ConfidenceScore >= 0.8 {
			report.CorrectClassifications++
		} else {
			report.IncorrectClassifications++
		}
	}

	// Adjust based on feedback
	for _, fb := range feedback {
		if fb.FeedbackType == FeedbackTypeAccuracy {
			if av.isPositiveFeedback(fb) {
				report.CorrectClassifications++
			} else {
				report.IncorrectClassifications++
			}
		}
	}

	// Calculate accuracy score
	if report.TotalClassifications > 0 {
		report.AccuracyScore = float64(report.CorrectClassifications) / float64(report.TotalClassifications)
	}

	// Calculate confidence score
	totalConfidence := 0.0
	for _, classification := range classifications {
		totalConfidence += classification.ConfidenceScore
	}
	if len(classifications) > 0 {
		report.ConfidenceScore = totalConfidence / float64(len(classifications))
	}

	return report
}

// calculateAccuracyByIndustry calculates accuracy by industry
func (av *AccuracyValidator) calculateAccuracyByIndustry(classifications []IndustryClassification, feedback []*Feedback) map[string]*AccuracyReport {
	reports := make(map[string]*AccuracyReport)

	// Group classifications by industry
	industryGroups := make(map[string][]IndustryClassification)
	for _, classification := range classifications {
		industry := classification.IndustryName
		if industry == "" {
			industry = "unknown"
		}
		industryGroups[industry] = append(industryGroups[industry], classification)
	}

	// Calculate accuracy for each industry
	for industry, industryClassifications := range industryGroups {
		report := &AccuracyReport{
			MetricType:  AccuracyMetricTypeIndustry,
			Dimension:   industry,
			LastUpdated: time.Now(),
			Metadata:    make(map[string]interface{}),
		}

		for _, classification := range industryClassifications {
			report.TotalClassifications++
			if classification.ConfidenceScore >= 0.8 {
				report.CorrectClassifications++
			} else {
				report.IncorrectClassifications++
			}
		}

		// Adjust based on feedback for this industry
		for _, fb := range feedback {
			if fb.FeedbackType == FeedbackTypeAccuracy && fb.OriginalClassification != nil {
				if fb.OriginalClassification.IndustryName == industry {
					if av.isPositiveFeedback(fb) {
						report.CorrectClassifications++
					} else {
						report.IncorrectClassifications++
					}
				}
			}
		}

		if report.TotalClassifications > 0 {
			report.AccuracyScore = float64(report.CorrectClassifications) / float64(report.TotalClassifications)
		}

		reports[industry] = report
	}

	return reports
}

// calculateAccuracyByBusinessType calculates accuracy by business type
func (av *AccuracyValidator) calculateAccuracyByBusinessType(classifications []IndustryClassification, feedback []*Feedback) map[string]*AccuracyReport {
	reports := make(map[string]*AccuracyReport)

	// This would be implemented based on business type data
	// For now, return empty map
	return reports
}

// calculateAccuracyByRegion calculates accuracy by region
func (av *AccuracyValidator) calculateAccuracyByRegion(classifications []IndustryClassification, feedback []*Feedback) map[string]*AccuracyReport {
	reports := make(map[string]*AccuracyReport)

	// This would be implemented based on geographic data
	// For now, return empty map
	return reports
}

// calculateAccuracyByConfidence calculates accuracy by confidence level
func (av *AccuracyValidator) calculateAccuracyByConfidence(classifications []IndustryClassification, feedback []*Feedback) map[string]*AccuracyReport {
	reports := make(map[string]*AccuracyReport)

	// Define confidence ranges
	confidenceRanges := []struct {
		rangeName string
		min       float64
		max       float64
	}{
		{"low", 0.0, 0.5},
		{"medium", 0.5, 0.8},
		{"high", 0.8, 1.0},
	}

	for _, confidenceRange := range confidenceRanges {
		report := &AccuracyReport{
			MetricType:  AccuracyMetricTypeConfidence,
			Dimension:   confidenceRange.rangeName,
			LastUpdated: time.Now(),
			Metadata:    make(map[string]interface{}),
		}

		for _, classification := range classifications {
			if classification.ConfidenceScore >= confidenceRange.min && classification.ConfidenceScore < confidenceRange.max {
				report.TotalClassifications++
				if classification.ConfidenceScore >= 0.8 {
					report.CorrectClassifications++
				} else {
					report.IncorrectClassifications++
				}
			}
		}

		if report.TotalClassifications > 0 {
			report.AccuracyScore = float64(report.CorrectClassifications) / float64(report.TotalClassifications)
		}

		reports[confidenceRange.rangeName] = report
	}

	return reports
}

// storeAccuracyReports stores accuracy reports
func (av *AccuracyValidator) storeAccuracyReports(overallReport *AccuracyReport, industryReports, businessTypeReports, regionReports, confidenceReports map[string]*AccuracyReport) {
	av.reportsMutex.Lock()
	defer av.reportsMutex.Unlock()

	// Store overall report
	overallKey := av.generateReportKey(overallReport.MetricType, overallReport.Dimension)
	av.accuracyReports[overallKey] = overallReport

	// Store industry reports
	for _, report := range industryReports {
		key := av.generateReportKey(report.MetricType, report.Dimension)
		av.accuracyReports[key] = report
	}

	// Store business type reports
	for _, report := range businessTypeReports {
		key := av.generateReportKey(report.MetricType, report.Dimension)
		av.accuracyReports[key] = report
	}

	// Store region reports
	for _, report := range regionReports {
		key := av.generateReportKey(report.MetricType, report.Dimension)
		av.accuracyReports[key] = report
	}

	// Store confidence reports
	for _, report := range confidenceReports {
		key := av.generateReportKey(report.MetricType, report.Dimension)
		av.accuracyReports[key] = report
	}
}

// checkThresholdsAndGenerateAlerts checks thresholds and generates alerts
func (av *AccuracyValidator) checkThresholdsAndGenerateAlerts(overallReport *AccuracyReport, industryReports, businessTypeReports, regionReports, confidenceReports map[string]*AccuracyReport) []*AccuracyAlert {
	var alerts []*AccuracyAlert

	// Check overall accuracy threshold
	alerts = append(alerts, av.checkThreshold(overallReport)...)

	// Check industry accuracy thresholds
	for _, report := range industryReports {
		alerts = append(alerts, av.checkThreshold(report)...)
	}

	// Check business type accuracy thresholds
	for _, report := range businessTypeReports {
		alerts = append(alerts, av.checkThreshold(report)...)
	}

	// Check region accuracy thresholds
	for _, report := range regionReports {
		alerts = append(alerts, av.checkThreshold(report)...)
	}

	// Check confidence accuracy thresholds
	for _, report := range confidenceReports {
		alerts = append(alerts, av.checkThreshold(report)...)
	}

	// Store alerts
	av.alertsMutex.Lock()
	for _, alert := range alerts {
		av.alerts[alert.ID] = alert
	}
	av.alertsMutex.Unlock()

	return alerts
}

// checkThreshold checks if a report violates any thresholds
func (av *AccuracyValidator) checkThreshold(report *AccuracyReport) []*AccuracyAlert {
	var alerts []*AccuracyAlert

	av.thresholdsMutex.RLock()
	defer av.thresholdsMutex.RUnlock()

	for _, threshold := range av.thresholds {
		if threshold.MetricType == report.MetricType && threshold.AlertEnabled {
			if report.AccuracyScore < threshold.Threshold {
				alert := &AccuracyAlert{
					ID:           av.generateAlertID(),
					MetricType:   threshold.MetricType,
					Dimension:    report.Dimension,
					Threshold:    threshold.Threshold,
					CurrentValue: report.AccuracyScore,
					Severity:     threshold.Severity,
					Message:      fmt.Sprintf("Accuracy for %s %s is %.2f, below threshold of %.2f", threshold.MetricType, report.Dimension, report.AccuracyScore, threshold.Threshold),
					Status:       "active",
					CreatedAt:    time.Now(),
					Metadata:     make(map[string]interface{}),
				}

				// Update threshold last triggered
				now := time.Now()
				threshold.LastTriggered = &now

				alerts = append(alerts, alert)
			}
		}
	}

	return alerts
}

// isPositiveFeedback determines if feedback is positive
func (av *AccuracyValidator) isPositiveFeedback(feedback *Feedback) bool {
	switch feedback.FeedbackType {
	case FeedbackTypeAccuracy:
		if value, ok := feedback.FeedbackValue.(bool); ok {
			return value
		}
		if value, ok := feedback.FeedbackValue.(float64); ok {
			return value >= 0.7
		}
	}
	return false
}

// matchesReportFilters checks if a report matches the specified filters
func (av *AccuracyValidator) matchesReportFilters(report *AccuracyReport, filters map[string]interface{}) bool {
	if filters == nil {
		return true
	}

	for key, value := range filters {
		switch key {
		case "metric_type":
			if metricType, ok := value.(AccuracyMetricType); ok && report.MetricType != metricType {
				return false
			}
		case "dimension":
			if dimension, ok := value.(string); ok && report.Dimension != dimension {
				return false
			}
		case "min_accuracy":
			if minAccuracy, ok := value.(float64); ok && report.AccuracyScore < minAccuracy {
				return false
			}
		}
	}

	return true
}

// matchesAlertFilters checks if an alert matches the specified filters
func (av *AccuracyValidator) matchesAlertFilters(alert *AccuracyAlert, filters map[string]interface{}) bool {
	if filters == nil {
		return true
	}

	for key, value := range filters {
		switch key {
		case "status":
			if status, ok := value.(string); ok && alert.Status != status {
				return false
			}
		case "severity":
			if severity, ok := value.(string); ok && alert.Severity != severity {
				return false
			}
		case "metric_type":
			if metricType, ok := value.(AccuracyMetricType); ok && alert.MetricType != metricType {
				return false
			}
		}
	}

	return true
}

// generateReportKey generates a key for accuracy reports
func (av *AccuracyValidator) generateReportKey(metricType AccuracyMetricType, dimension string) string {
	return fmt.Sprintf("%s_%s", metricType, dimension)
}

// generateThresholdKey generates a key for accuracy thresholds
func (av *AccuracyValidator) generateThresholdKey(metricType AccuracyMetricType, severity string) string {
	return fmt.Sprintf("%s_%s", metricType, severity)
}

// generateAlertID generates a unique alert ID
func (av *AccuracyValidator) generateAlertID() string {
	return fmt.Sprintf("alert_%d", time.Now().UnixNano())
}

// startValidationLoop starts the automated validation loop
func (av *AccuracyValidator) startValidationLoop() {
	ticker := time.NewTicker(av.validationInterval)
	defer ticker.Stop()

	for range ticker.C {
		// Perform automated validation
		// This would typically involve fetching recent classifications and feedback
		// For now, just clean up old alerts
		av.cleanupOldAlerts()
	}
}

// cleanupOldAlerts removes alerts older than retention period
func (av *AccuracyValidator) cleanupOldAlerts() {
	av.alertsMutex.Lock()
	defer av.alertsMutex.Unlock()

	cutoff := time.Now().AddDate(0, 0, -av.alertRetentionDays)
	for id, alert := range av.alerts {
		if alert.CreatedAt.Before(cutoff) {
			delete(av.alerts, id)
		}
	}
}

// initializeDefaultThresholds initializes default accuracy thresholds
func (av *AccuracyValidator) initializeDefaultThresholds() {
	defaultThresholds := []*AccuracyThreshold{
		{
			MetricType:   AccuracyMetricTypeOverall,
			Threshold:    0.8,
			Severity:     "high",
			AlertEnabled: true,
			Description:  "Overall accuracy below 80%",
		},
		{
			MetricType:   AccuracyMetricTypeIndustry,
			Threshold:    0.7,
			Severity:     "medium",
			AlertEnabled: true,
			Description:  "Industry accuracy below 70%",
		},
		{
			MetricType:   AccuracyMetricTypeConfidence,
			Threshold:    0.6,
			Severity:     "low",
			AlertEnabled: true,
			Description:  "Confidence-based accuracy below 60%",
		},
	}

	for _, threshold := range defaultThresholds {
		key := av.generateThresholdKey(threshold.MetricType, threshold.Severity)
		av.thresholds[key] = threshold
	}
}

// RecordValidationMetrics records metrics for validation operations
func (av *AccuracyValidator) RecordValidationMetrics(ctx context.Context, report *AccuracyReport, alertsGenerated int, processingTime time.Duration) {
	if av.metrics == nil {
		return
	}

	// TODO: Replace with appropriate metrics recording when histogram support is added
	// av.metrics.RecordHistogram(ctx, "accuracy_score", report.AccuracyScore, map[string]string{
	// 	"metric_type": string(report.MetricType),
	// 	"dimension":   report.Dimension,
	// })

	// av.metrics.RecordHistogram(ctx, "accuracy_validation_time", float64(processingTime.Milliseconds()), map[string]string{
	// 	"metric_type": string(report.MetricType),
	// })

	// av.metrics.RecordHistogram(ctx, "accuracy_alerts_generated", float64(alertsGenerated), map[string]string{
	// 	"metric_type": string(report.MetricType),
	// })
}
