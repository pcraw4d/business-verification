package classification

import (
	"context"
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/pcraw4d/business-verification/internal/observability"
)

// GeographicRegion represents a geographic region with classification data
type GeographicRegion struct {
	ID                  string                 `json:"id"`
	Name                string                 `json:"name"`
	Country             string                 `json:"country"`
	State               string                 `json:"state"`
	City                string                 `json:"city"`
	Region              string                 `json:"region"`
	Timezone            string                 `json:"timezone"`
	Population          int                    `json:"population"`
	GDP                 float64                `json:"gdp"`
	IndustryPatterns    map[string]float64     `json:"industry_patterns"`
	ConfidenceModifier  float64                `json:"confidence_modifier"`
	ClassificationRules []ClassificationRule   `json:"classification_rules"`
	LastUpdated         time.Time              `json:"last_updated"`
	Metadata            map[string]interface{} `json:"metadata"`
}

// ClassificationRule represents a region-specific classification rule
type ClassificationRule struct {
	RuleID        string                 `json:"rule_id"`
	RuleType      string                 `json:"rule_type"` // "industry_pattern", "confidence_modifier", "validation"
	Condition     string                 `json:"condition"`
	Action        string                 `json:"action"`
	Parameters    map[string]interface{} `json:"parameters"`
	Priority      int                    `json:"priority"`
	Enabled       bool                   `json:"enabled"`
	LastEvaluated time.Time              `json:"last_evaluated"`
}

// RegionDetectionResult represents the result of geographic region detection
type RegionDetectionResult struct {
	DetectedRegion     *GeographicRegion      `json:"detected_region"`
	Confidence         float64                `json:"confidence"`
	DetectionMethod    string                 `json:"detection_method"`
	AlternativeRegions []*GeographicRegion    `json:"alternative_regions"`
	ProcessingTime     time.Duration          `json:"processing_time"`
	Metadata           map[string]interface{} `json:"metadata"`
}

// RegionClassificationResult represents classification results with geographic context
type RegionClassificationResult struct {
	Region                *GeographicRegion        `json:"region"`
	Classifications       []IndustryClassification `json:"classifications"`
	ConfidenceAdjustments map[string]float64       `json:"confidence_adjustments"`
	AppliedRules          []string                 `json:"applied_rules"`
	ProcessingTime        time.Duration            `json:"processing_time"`
	Metadata              map[string]interface{}   `json:"metadata"`
}

// GeographicManager provides geographic region awareness for classification
type GeographicManager struct {
	logger  *observability.Logger
	metrics *observability.Metrics

	// Region storage
	regions      map[string]*GeographicRegion
	regionsMutex sync.RWMutex

	// Detection patterns
	detectionPatterns map[string][]string
	patternsMutex     sync.RWMutex

	// Confidence modifiers
	confidenceModifiers map[string]float64
	modifiersMutex      sync.RWMutex

	// Performance tracking
	performanceMetrics map[string]float64
	metricsMutex       sync.RWMutex

	// Configuration
	enableRegionDetection bool
	confidenceThreshold   float64
	maxAlternativeRegions int
}

// NewGeographicManager creates a new geographic region manager
func NewGeographicManager(logger *observability.Logger, metrics *observability.Metrics) *GeographicManager {
	manager := &GeographicManager{
		logger:  logger,
		metrics: metrics,

		// Initialize storage
		regions:             make(map[string]*GeographicRegion),
		detectionPatterns:   make(map[string][]string),
		confidenceModifiers: make(map[string]float64),
		performanceMetrics:  make(map[string]float64),

		// Configuration
		enableRegionDetection: true,
		confidenceThreshold:   0.7,
		maxAlternativeRegions: 3,
	}

	// Initialize default regions
	manager.initializeDefaultRegions()

	// Initialize detection patterns
	manager.initializeDetectionPatterns()

	// Initialize confidence modifiers
	manager.initializeConfidenceModifiers()

	return manager
}

// DetectRegion detects the geographic region for a business
func (gm *GeographicManager) DetectRegion(ctx context.Context, businessInfo map[string]interface{}) (*RegionDetectionResult, error) {
	start := time.Now()

	// Log detection start
	if gm.logger != nil {
		gm.logger.WithComponent("geographic_manager").LogBusinessEvent(ctx, "region_detection_started", "", map[string]interface{}{
			"business_name": businessInfo["business_name"],
		})
	}

	// Extract location information
	locationInfo := gm.extractLocationInfo(businessInfo)

	// Perform region detection
	detectedRegion, confidence, method := gm.performRegionDetection(locationInfo)

	if detectedRegion == nil {
		return &RegionDetectionResult{
			DetectedRegion:  nil,
			Confidence:      0.0,
			DetectionMethod: "none",
			ProcessingTime:  time.Since(start),
		}, nil
	}

	// Find alternative regions
	alternativeRegions := gm.findAlternativeRegions(locationInfo, detectedRegion)

	// Create detection result
	result := &RegionDetectionResult{
		DetectedRegion:     detectedRegion,
		Confidence:         confidence,
		DetectionMethod:    method,
		AlternativeRegions: alternativeRegions,
		ProcessingTime:     time.Since(start),
		Metadata: map[string]interface{}{
			"location_info": locationInfo,
			"method":        method,
		},
	}

	// Log detection completion
	if gm.logger != nil {
		gm.logger.WithComponent("geographic_manager").LogBusinessEvent(ctx, "region_detection_completed", "", map[string]interface{}{
			"detected_region":    detectedRegion.Name,
			"confidence":         confidence,
			"method":             method,
			"processing_time_ms": result.ProcessingTime.Milliseconds(),
		})
	}

	// Record metrics
	gm.RecordDetectionMetrics(ctx, result)

	return result, nil
}

// ClassifyWithRegion performs classification with geographic region awareness
func (gm *GeographicManager) ClassifyWithRegion(ctx context.Context, classifications []IndustryClassification, region *GeographicRegion) (*RegionClassificationResult, error) {
	start := time.Now()

	if region == nil {
		return &RegionClassificationResult{
			Classifications: classifications,
			ProcessingTime:  time.Since(start),
		}, nil
	}

	// Apply region-specific rules
	adjustedClassifications := make([]IndustryClassification, 0, len(classifications))
	confidenceAdjustments := make(map[string]float64)
	appliedRules := make([]string, 0)

	for _, classification := range classifications {
		adjustedClassification := classification
		adjustment := gm.calculateRegionConfidenceAdjustment(region, classification)

		// Apply confidence adjustment
		adjustedClassification.ConfidenceScore *= adjustment
		confidenceAdjustments[classification.IndustryCode] = adjustment

		// Apply region-specific rules
		rules := gm.applyRegionClassificationRules(region, classification)
		for _, rule := range rules {
			appliedRules = append(appliedRules, rule.RuleID)
		}

		adjustedClassifications = append(adjustedClassifications, adjustedClassification)
	}

	// Create result
	result := &RegionClassificationResult{
		Region:                region,
		Classifications:       adjustedClassifications,
		ConfidenceAdjustments: confidenceAdjustments,
		AppliedRules:          appliedRules,
		ProcessingTime:        time.Since(start),
		Metadata: map[string]interface{}{
			"region_id":     region.ID,
			"region_name":   region.Name,
			"rules_applied": len(appliedRules),
		},
	}

	// Log classification completion
	if gm.logger != nil {
		gm.logger.WithComponent("geographic_manager").LogBusinessEvent(ctx, "region_classification_completed", "", map[string]interface{}{
			"region_name":        region.Name,
			"classifications":    len(adjustedClassifications),
			"rules_applied":      len(appliedRules),
			"processing_time_ms": result.ProcessingTime.Milliseconds(),
		})
	}

	// Record metrics
	gm.RecordClassificationMetrics(ctx, result)

	return result, nil
}

// AddRegion adds a new geographic region
func (gm *GeographicManager) AddRegion(ctx context.Context, region *GeographicRegion) error {
	gm.regionsMutex.Lock()
	defer gm.regionsMutex.Unlock()

	// Validate region
	if err := gm.validateRegion(region); err != nil {
		return fmt.Errorf("invalid region: %w", err)
	}

	// Set metadata
	region.LastUpdated = time.Now()
	if region.Metadata == nil {
		region.Metadata = make(map[string]interface{})
	}

	// Store region
	gm.regions[region.ID] = region

	// Log region addition
	if gm.logger != nil {
		gm.logger.WithComponent("geographic_manager").LogBusinessEvent(ctx, "region_added", region.ID, map[string]interface{}{
			"region_name": region.Name,
			"country":     region.Country,
			"state":       region.State,
			"city":        region.City,
		})
	}

	// Record metrics
	gm.RecordRegionMetrics(ctx, region, "region_added")

	return nil
}

// GetRegion retrieves a geographic region by ID
func (gm *GeographicManager) GetRegion(ctx context.Context, regionID string) (*GeographicRegion, error) {
	gm.regionsMutex.RLock()
	defer gm.regionsMutex.RUnlock()

	region, exists := gm.regions[regionID]
	if !exists {
		return nil, fmt.Errorf("region not found: %s", regionID)
	}

	return region, nil
}

// UpdateRegion updates an existing geographic region
func (gm *GeographicManager) UpdateRegion(ctx context.Context, regionID string, updates map[string]interface{}) error {
	gm.regionsMutex.Lock()
	defer gm.regionsMutex.Unlock()

	region, exists := gm.regions[regionID]
	if !exists {
		return fmt.Errorf("region not found: %s", regionID)
	}

	// Apply updates
	if name, ok := updates["name"].(string); ok {
		region.Name = name
	}
	if country, ok := updates["country"].(string); ok {
		region.Country = country
	}
	if state, ok := updates["state"].(string); ok {
		region.State = state
	}
	if city, ok := updates["city"].(string); ok {
		region.City = city
	}
	if patterns, ok := updates["industry_patterns"].(map[string]float64); ok {
		region.IndustryPatterns = patterns
	}
	if modifier, ok := updates["confidence_modifier"].(float64); ok {
		region.ConfidenceModifier = modifier
	}

	// Update timestamp
	region.LastUpdated = time.Now()

	// Log region update
	if gm.logger != nil {
		gm.logger.WithComponent("geographic_manager").LogBusinessEvent(ctx, "region_updated", regionID, map[string]interface{}{
			"updates_applied": len(updates),
		})
	}

	return nil
}

// ListRegions returns all geographic regions with optional filters
func (gm *GeographicManager) ListRegions(ctx context.Context, filters map[string]interface{}) ([]*GeographicRegion, error) {
	gm.regionsMutex.RLock()
	defer gm.regionsMutex.RUnlock()

	regions := make([]*GeographicRegion, 0)

	for _, region := range gm.regions {
		if gm.matchesFilters(region, filters) {
			regions = append(regions, region)
		}
	}

	return regions, nil
}

// GetManagerStats returns statistics about the geographic manager
func (gm *GeographicManager) GetManagerStats() map[string]interface{} {
	gm.regionsMutex.RLock()
	defer gm.regionsMutex.RUnlock()

	stats := map[string]interface{}{
		"total_regions":        len(gm.regions),
		"detection_patterns":   len(gm.detectionPatterns),
		"confidence_modifiers": len(gm.confidenceModifiers),
		"confidence_threshold": gm.confidenceThreshold,
		"region_detection":     gm.enableRegionDetection,
		"countries":            make(map[string]int),
		"states":               make(map[string]int),
		"cities":               make(map[string]int),
	}

	// Count regions by location
	for _, region := range gm.regions {
		stats["countries"].(map[string]int)[region.Country]++
		stats["states"].(map[string]int)[region.State]++
		stats["cities"].(map[string]int)[region.City]++
	}

	return stats
}

// Helper methods

// extractLocationInfo extracts location information from business data
func (gm *GeographicManager) extractLocationInfo(businessInfo map[string]interface{}) map[string]string {
	locationInfo := make(map[string]string)

	// Extract from various fields
	if address, ok := businessInfo["address"].(string); ok {
		locationInfo["address"] = address
	}
	if city, ok := businessInfo["city"].(string); ok {
		locationInfo["city"] = city
	}
	if state, ok := businessInfo["state"].(string); ok {
		locationInfo["state"] = state
	}
	if country, ok := businessInfo["country"].(string); ok {
		locationInfo["country"] = country
	}
	if postalCode, ok := businessInfo["postal_code"].(string); ok {
		locationInfo["postal_code"] = postalCode
	}
	if phone, ok := businessInfo["phone"].(string); ok {
		locationInfo["phone"] = phone
	}

	return locationInfo
}

// performRegionDetection performs the actual region detection
func (gm *GeographicManager) performRegionDetection(locationInfo map[string]string) (*GeographicRegion, float64, string) {
	var bestRegion *GeographicRegion
	var bestConfidence float64
	var bestMethod string

	// Try exact match first
	if region, confidence := gm.findExactMatch(locationInfo); region != nil {
		return region, confidence, "exact_match"
	}

	// Try fuzzy match
	if region, confidence := gm.findFuzzyMatch(locationInfo); region != nil && confidence > bestConfidence {
		bestRegion = region
		bestConfidence = confidence
		bestMethod = "fuzzy_match"
	}

	// Try pattern match
	if region, confidence := gm.findPatternMatch(locationInfo); region != nil && confidence > bestConfidence {
		bestRegion = region
		bestConfidence = confidence
		bestMethod = "pattern_match"
	}

	// Try phone number analysis
	if region, confidence := gm.findPhoneMatch(locationInfo); region != nil && confidence > bestConfidence {
		bestRegion = region
		bestConfidence = confidence
		bestMethod = "phone_match"
	}

	if bestRegion != nil && bestConfidence >= gm.confidenceThreshold {
		return bestRegion, bestConfidence, bestMethod
	}

	return nil, 0.0, "none"
}

// findExactMatch finds an exact match for location information
func (gm *GeographicManager) findExactMatch(locationInfo map[string]string) (*GeographicRegion, float64) {
	gm.regionsMutex.RLock()
	defer gm.regionsMutex.RUnlock()

	for _, region := range gm.regions {
		confidence := 0.0
		matches := 0
		total := 0

		// Check city match
		if city, ok := locationInfo["city"]; ok && city != "" {
			total++
			if strings.EqualFold(region.City, city) {
				matches++
				confidence += 0.4
			}
		}

		// Check state match
		if state, ok := locationInfo["state"]; ok && state != "" {
			total++
			if strings.EqualFold(region.State, state) {
				matches++
				confidence += 0.3
			}
		}

		// Check country match
		if country, ok := locationInfo["country"]; ok && country != "" {
			total++
			if strings.EqualFold(region.Country, country) {
				matches++
				confidence += 0.3
			}
		}

		if total > 0 && float64(matches)/float64(total) >= 0.8 {
			return region, confidence
		}
	}

	return nil, 0.0
}

// findFuzzyMatch finds a fuzzy match for location information
func (gm *GeographicManager) findFuzzyMatch(locationInfo map[string]string) (*GeographicRegion, float64) {
	gm.regionsMutex.RLock()
	defer gm.regionsMutex.RUnlock()

	var bestRegion *GeographicRegion
	var bestConfidence float64

	for _, region := range gm.regions {
		confidence := gm.calculateFuzzyConfidence(region, locationInfo)
		if confidence > bestConfidence {
			bestConfidence = confidence
			bestRegion = region
		}
	}

	return bestRegion, bestConfidence
}

// findPatternMatch finds a match using detection patterns
func (gm *GeographicManager) findPatternMatch(locationInfo map[string]string) (*GeographicRegion, float64) {
	gm.patternsMutex.RLock()
	defer gm.patternsMutex.RUnlock()

	var bestRegion *GeographicRegion
	var bestConfidence float64

	for pattern, regionIDs := range gm.detectionPatterns {
		if gm.matchesPattern(locationInfo, pattern) {
			for _, regionID := range regionIDs {
				if region, exists := gm.regions[regionID]; exists {
					confidence := 0.7 // Base confidence for pattern match
					if confidence > bestConfidence {
						bestConfidence = confidence
						bestRegion = region
					}
				}
			}
		}
	}

	return bestRegion, bestConfidence
}

// findPhoneMatch finds a match using phone number analysis
func (gm *GeographicManager) findPhoneMatch(locationInfo map[string]string) (*GeographicRegion, float64) {
	phone, ok := locationInfo["phone"]
	if !ok || phone == "" {
		return nil, 0.0
	}

	// Simple phone number analysis (country code, area code)
	// This would be enhanced with proper phone number parsing library
	if strings.HasPrefix(phone, "+1") {
		// US/Canada
		return gm.findRegionByCountry("US"), 0.6
	} else if strings.HasPrefix(phone, "+44") {
		// UK
		return gm.findRegionByCountry("UK"), 0.6
	}

	return nil, 0.0
}

// findAlternativeRegions finds alternative regions for the detected region
func (gm *GeographicManager) findAlternativeRegions(locationInfo map[string]string, detectedRegion *GeographicRegion) []*GeographicRegion {
	alternatives := make([]*GeographicRegion, 0)

	gm.regionsMutex.RLock()
	defer gm.regionsMutex.RUnlock()

	for _, region := range gm.regions {
		if region.ID == detectedRegion.ID {
			continue
		}

		// Check if region is in same country/state
		if region.Country == detectedRegion.Country || region.State == detectedRegion.State {
			confidence := gm.calculateFuzzyConfidence(region, locationInfo)
			if confidence >= 0.5 {
				alternatives = append(alternatives, region)
			}
		}

		if len(alternatives) >= gm.maxAlternativeRegions {
			break
		}
	}

	return alternatives
}

// calculateFuzzyConfidence calculates fuzzy matching confidence
func (gm *GeographicManager) calculateFuzzyConfidence(region *GeographicRegion, locationInfo map[string]string) float64 {
	confidence := 0.0

	// City similarity
	if city, ok := locationInfo["city"]; ok && city != "" {
		similarity := gm.calculateStringSimilarity(region.City, city)
		confidence += similarity * 0.4
	}

	// State similarity
	if state, ok := locationInfo["state"]; ok && state != "" {
		similarity := gm.calculateStringSimilarity(region.State, state)
		confidence += similarity * 0.3
	}

	// Country similarity
	if country, ok := locationInfo["country"]; ok && country != "" {
		similarity := gm.calculateStringSimilarity(region.Country, country)
		confidence += similarity * 0.3
	}

	return confidence
}

// calculateStringSimilarity calculates similarity between two strings
func (gm *GeographicManager) calculateStringSimilarity(str1, str2 string) float64 {
	// Simple similarity calculation
	// This would be enhanced with proper string similarity algorithms
	str1Lower := strings.ToLower(strings.TrimSpace(str1))
	str2Lower := strings.ToLower(strings.TrimSpace(str2))

	if str1Lower == str2Lower {
		return 1.0
	}

	if strings.Contains(str1Lower, str2Lower) || strings.Contains(str2Lower, str1Lower) {
		return 0.8
	}

	return 0.0
}

// matchesPattern checks if location info matches a detection pattern
func (gm *GeographicManager) matchesPattern(locationInfo map[string]string, pattern string) bool {
	// Simple pattern matching
	// This would be enhanced with regex patterns
	for _, value := range locationInfo {
		if strings.Contains(strings.ToLower(value), strings.ToLower(pattern)) {
			return true
		}
	}
	return false
}

// findRegionByCountry finds a region by country
func (gm *GeographicManager) findRegionByCountry(country string) *GeographicRegion {
	gm.regionsMutex.RLock()
	defer gm.regionsMutex.RUnlock()

	for _, region := range gm.regions {
		if strings.EqualFold(region.Country, country) {
			return region
		}
	}
	return nil
}

// calculateRegionConfidenceAdjustment calculates confidence adjustment for a region
func (gm *GeographicManager) calculateRegionConfidenceAdjustment(region *GeographicRegion, classification IndustryClassification) float64 {
	adjustment := region.ConfidenceModifier

	// Check industry patterns
	if pattern, exists := region.IndustryPatterns[classification.IndustryCode]; exists {
		adjustment *= pattern
	}

	// Apply region-specific modifiers
	gm.modifiersMutex.RLock()
	if modifier, exists := gm.confidenceModifiers[region.ID]; exists {
		adjustment *= modifier
	}
	gm.modifiersMutex.RUnlock()

	return adjustment
}

// applyRegionClassificationRules applies region-specific classification rules
func (gm *GeographicManager) applyRegionClassificationRules(region *GeographicRegion, classification IndustryClassification) []ClassificationRule {
	appliedRules := make([]ClassificationRule, 0)

	for _, rule := range region.ClassificationRules {
		if !rule.Enabled {
			continue
		}

		if gm.evaluateRule(rule, classification) {
			appliedRules = append(appliedRules, rule)
		}
	}

	return appliedRules
}

// evaluateRule evaluates a classification rule
func (gm *GeographicManager) evaluateRule(rule ClassificationRule, classification IndustryClassification) bool {
	// Simple rule evaluation
	// This would be enhanced with proper rule engine
	switch rule.RuleType {
	case "industry_pattern":
		return gm.evaluateIndustryPatternRule(rule, classification)
	case "confidence_modifier":
		return gm.evaluateConfidenceModifierRule(rule, classification)
	default:
		return false
	}
}

// evaluateIndustryPatternRule evaluates an industry pattern rule
func (gm *GeographicManager) evaluateIndustryPatternRule(rule ClassificationRule, classification IndustryClassification) bool {
	// Simple pattern matching
	return strings.Contains(strings.ToLower(classification.IndustryName), strings.ToLower(rule.Condition))
}

// evaluateConfidenceModifierRule evaluates a confidence modifier rule
func (gm *GeographicManager) evaluateConfidenceModifierRule(rule ClassificationRule, classification IndustryClassification) bool {
	// Simple confidence threshold evaluation
	if threshold, ok := rule.Parameters["min_confidence"].(float64); ok {
		return classification.ConfidenceScore >= threshold
	}
	return false
}

// validateRegion validates a geographic region
func (gm *GeographicManager) validateRegion(region *GeographicRegion) error {
	if region.ID == "" {
		return fmt.Errorf("region ID is required")
	}
	if region.Name == "" {
		return fmt.Errorf("region name is required")
	}
	if region.Country == "" {
		return fmt.Errorf("country is required")
	}
	return nil
}

// matchesFilters checks if a region matches the given filters
func (gm *GeographicManager) matchesFilters(region *GeographicRegion, filters map[string]interface{}) bool {
	for key, value := range filters {
		switch key {
		case "country":
			if filterCountry, ok := value.(string); ok && region.Country != filterCountry {
				return false
			}
		case "state":
			if filterState, ok := value.(string); ok && region.State != filterState {
				return false
			}
		case "city":
			if filterCity, ok := value.(string); ok && region.City != filterCity {
				return false
			}
		}
	}
	return true
}

// initializeDefaultRegions initializes default geographic regions
func (gm *GeographicManager) initializeDefaultRegions() {
	defaultRegions := []*GeographicRegion{
		{
			ID:         "us_ca_sf",
			Name:       "San Francisco, CA, US",
			Country:    "US",
			State:      "CA",
			City:       "San Francisco",
			Region:     "West Coast",
			Timezone:   "America/Los_Angeles",
			Population: 873965,
			GDP:        501.0,
			IndustryPatterns: map[string]float64{
				"511200": 1.2, // Software Publishers
				"541511": 1.3, // Custom Computer Programming Services
				"541512": 1.2, // Computer Systems Design Services
			},
			ConfidenceModifier: 1.1,
			LastUpdated:        time.Now(),
		},
		{
			ID:         "us_ny_nyc",
			Name:       "New York City, NY, US",
			Country:    "US",
			State:      "NY",
			City:       "New York",
			Region:     "Northeast",
			Timezone:   "America/New_York",
			Population: 8336817,
			GDP:        1777.0,
			IndustryPatterns: map[string]float64{
				"522100": 1.2, // Depository Credit Intermediation
				"523150": 1.3, // Securities and Commodity Exchanges
				"541100": 1.1, // Legal Services
			},
			ConfidenceModifier: 1.0,
			LastUpdated:        time.Now(),
		},
		{
			ID:         "uk_london",
			Name:       "London, UK",
			Country:    "UK",
			State:      "England",
			City:       "London",
			Region:     "Europe",
			Timezone:   "Europe/London",
			Population: 8982000,
			GDP:        503.0,
			IndustryPatterns: map[string]float64{
				"641100": 1.2, // Central Banking
				"649100": 1.1, // Trust, Fiduciary, and Custody Activities
				"691000": 1.1, // Legal Activities
			},
			ConfidenceModifier: 1.0,
			LastUpdated:        time.Now(),
		},
	}

	for _, region := range defaultRegions {
		gm.regions[region.ID] = region
	}
}

// initializeDetectionPatterns initializes detection patterns
func (gm *GeographicManager) initializeDetectionPatterns() {
	gm.detectionPatterns = map[string][]string{
		"san francisco": {"us_ca_sf"},
		"sf":            {"us_ca_sf"},
		"bay area":      {"us_ca_sf"},
		"new york":      {"us_ny_nyc"},
		"nyc":           {"us_ny_nyc"},
		"manhattan":     {"us_ny_nyc"},
		"london":        {"uk_london"},
		"england":       {"uk_london"},
	}
}

// initializeConfidenceModifiers initializes confidence modifiers
func (gm *GeographicManager) initializeConfidenceModifiers() {
	gm.confidenceModifiers = map[string]float64{
		"us_ca_sf":  1.1, // Tech hub - higher confidence for tech industries
		"us_ny_nyc": 1.0, // Financial hub - baseline
		"uk_london": 1.0, // Financial hub - baseline
	}
}

// RecordDetectionMetrics records metrics for region detection
func (gm *GeographicManager) RecordDetectionMetrics(ctx context.Context, result *RegionDetectionResult) {
	if gm.metrics == nil {
		return
	}

	// TODO: Replace with appropriate metrics recording when histogram support is added
	// gm.metrics.RecordHistogram(ctx, "region_detection_confidence", result.Confidence, map[string]string{
	// 	"detection_method": result.DetectionMethod,
	// })

	// gm.metrics.RecordHistogram(ctx, "region_detection_time", float64(result.ProcessingTime.Milliseconds()), map[string]string{
	// 	"detection_method": result.DetectionMethod,
	// })
}

// RecordClassificationMetrics records metrics for region classification
func (gm *GeographicManager) RecordClassificationMetrics(ctx context.Context, result *RegionClassificationResult) {
	if gm.metrics == nil {
		return
	}

	// TODO: Replace with appropriate metrics recording when histogram support is added
	// gm.metrics.RecordHistogram(ctx, "region_classification_time", float64(result.ProcessingTime.Milliseconds()), map[string]string{
	// 	"region_id": result.Region.ID,
	// })

	// gm.metrics.RecordHistogram(ctx, "region_classification_rules_applied", float64(len(result.AppliedRules)), map[string]string{
	// 	"region_id": result.Region.ID,
	// })
}

// RecordRegionMetrics records metrics for region operations
func (gm *GeographicManager) RecordRegionMetrics(ctx context.Context, region *GeographicRegion, operation string) {
	if gm.metrics == nil {
		return
	}

	// TODO: Replace with appropriate metrics recording when histogram support is added
	// gm.metrics.RecordHistogram(ctx, "region_operations", 1.0, map[string]string{
	// 	"operation": operation,
	// 	"region_id": region.ID,
	// })
}
